题目：[91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1 1 10 6)`
- `"KJF"` ，将消息分组为 `(11 10 6)`

注意，消息不能分组为 `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。

```
示例 1：

输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

示例 2：

输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

示例 3：

输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
```

**提示：**

- `1 <= s.length <= 100`
- `s` 只包含数字，并且可能包含前导零。

## 方法：线性DP

**1. 定义状态**

dp[i] 表示在 [0, i] 范围内，**且以 s[i] 结尾**的方法数

**2. 状态转移方程**

一个字母最多映射两位数字，那么当前的 dp[i] 就有两大类情况，从当前位置 s[i] 或 前一位 s[i-1] 得出

- dp[i] 从当前位置 s[i] 「一位」得出，由于 dp[i-1] 天生满足状态设定，因此我们仅关心 s[i] 是否可形成编码
  - 当 s[i] 为 1到9 时，就可形成编码
  - 若 s[i] 为 0，就不可形成编码
- dp[i] 从 s[i-1] 和 s[i] 「两位」得出，由于 dp[i-2] 天生满足状态设定，因此我们关心 s[i-1] 和 s[i] 是否可形成编码
  - s[i-1] 和 s[i] 组成的数，在 [10, 26] 内，就可形成编码
  - s[i-1] 和 s[i] 组成的数，在 [00, 09] 内，不可形成编码
  - s[i-1] 和 s[i] 组成的数，在 [27, 99] 内，不可形成编码

因此，dp[i] 可以或得状态转移的两种情况就明确了，将下面两种情况的状态进行累加

- 当 s[i] 为 1到9 时，就可形成编码，`dp[i] += dp[i-1]`
- s[i-1] 和 s[i] 组成的数，在 [10, 26] 内，就可形成编码，`dp[i] += dp[i-2]`

注意到 i-1 和  i-2 可能造成数组越界，因此将 dp 数组的开头扩充一位，【很常见的操作】

如果被各种下标搞的很乱的话，当 i = 1 时，做下特殊判断也行

**3. 初始化**

d[0] 辅助位，为 1

检查第一个数 s[0] 是否为 0

- 若为 0，dp[1] = 0
- 若在 [1, 9]，dp[1] = 1

**4. 输出**

返回 dp[n]

**空间优化**

可优化，因为仅跟dp的「前一位」和「前两位」有关

**复杂度分析**

时间复杂度：`O(n)`

空间复杂度：`O(n)` 或`O(1)`

```c++
class Solution {
public:
    int to_num(string &s, int i, int cnt) {
        if (cnt == 1) {
            return s[i] - 48;
        }
        return (s[i] - 48) * 10 + s[i + 1] - 48;
    }
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = s[0] == '0' ? 0 : 1;

        for (int i = 1; i < n; i++) {  // i代表s中的下标，因此下面的dp下标整体加1
            int one = to_num(s, i, 1);
            int tow = to_num(s, i - 1, 2);
            if (1 <= one && one <= 9) {
                dp[i + 1] += dp[i];
            }
            if (10 <= tow && tow <= 26) {
                dp[i + 1] += dp[i - 1];
            }
        }
        return dp[n];
    }
};
```



```c++
class Solution {
public:
    int to_num(string &s, int i, int cnt) {
        if (cnt == 1) {
            return s[i] - 48;
        }
        return (s[i] - 48) * 10 + s[i + 1] - 48;
    }
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n + 1, 0);
        int prepre = 1;
        int pre = s[0] == '0' ? 0 : 1;
        int cur = pre;

        for (int i = 1; i < n; i++) {  // i代表s中的下标
            cur = 0;
            int one = to_num(s, i, 1);
            int tow = to_num(s, i - 1, 2);
            if (1 <= one && one <= 9) cur += pre;
            if (10 <= tow && tow <= 26) cur += prepre;
            prepre = pre;
            pre = cur;
        }

        return cur;
    }
};
```



