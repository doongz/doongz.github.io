题目：[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

[题解来源](https://leetcode.cn/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```
示例 1：

输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

示例 2：

输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

## 方法一：`dp[N][C+1]` 解法

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int total = 0;
        for (int num : nums) total += num;
        if (total & 1) return false;  // 不能为奇数

        int target = total >> 1;
        int n = nums.size();

        // 创建二维状态数组，行：物品索引，列：容量（包括 0）
        vector<vector<bool>> dp(n, vector<bool>(target + 1, false));

        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满
        if (nums[0] <= target) {
            dp[0][nums[0]] = true;
        }

        for (int i = 1; i < n; i++) {
            for (int c = 0; c <= target; c++) {
                if (c - nums[i] < 0) {
                    dp[i][c] = dp[i - 1][c];
                } else if (c == nums[i]) {
                    dp[i][c] = true;
                } else if (c - nums[i] > 0) {
                    dp[i][c] = dp[i - 1][c] || dp[i - 1][c - nums[i]];
                }
            }
        }
        return dp[n - 1][target];
    }
};
```

## 方法二：`dp[C+1]` 解法

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int total = 0;
        for (int num : nums) total += num;
        if (total & 1) return false;  // 不能为奇数

        int target = total >> 1;
        int n = nums.size();

        // 创建二维状态数组，行：物品索引，列：容量（包括 0）
        vector<bool> dp(target + 1, false);

        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满
        if (nums[0] <= target) {
            dp[nums[0]] = true;
        }

        for (int i = 1; i < n; i++) {
            for (int c = target; c - nums[i] >= 0; c--) {
                dp[c] = dp[c] || dp[c - nums[i]];
            }
        }
        return dp[target];
    }
};
```

---

关于背包问题的介绍，大家可以在互联网上搜索「背包九讲」进行学习，其中「0-1」背包问题是这些问题的基础。「力扣」上涉及的背包问题有「0-1」背包问题、完全背包问题、多重背包问题。

本题解有些地方使用了「0-1」背包问题的描述，因此会不加解释的使用「背包」、「容量」这样的名词。

说明：这里感谢很多朋友在这篇题解下提出的建议，对我的启发很大。本题解的阅读建议是：先浏览代码，然后再看代码之前的分析，能更有效理解知识点和整个问题的思考路径。题解后也增加了「总结」，供大家参考。

### 转换为 0 - 1 背包问题

这道问题是我学习「背包」问题的入门问题，做这道题需要做一个等价转换：是否可以从输入数组中挑选出一些正整数，使得这些数的和 等于 整个数组元素的和的一半。很坦白地说，如果不是我的老师告诉我可以这样想，我很难想出来。容易知道：数组的和一定得是偶数。

本题与 0-1 背包问题有一个很大的不同，即：

- 0-1 背包问题选取的物品的容积总量 不能超过 规定的总量；
- 本题选取的数字之和需要 恰好等于 规定的和的一半。

这一点区别，决定了在初始化的时候，所有的值应该初始化为 false。 （《背包九讲》的作者在介绍 「0-1 背包」问题的时候，有强调过这点区别。）

### 0 - 1 背包问题的思路

作为「0-1 背包问题」，它的特点是：「每个数只能用一次」。解决的基本思路是：物品一个一个选，容量也一点一点增加去考虑，这一点是「动态规划」的思想，特别重要。
在实际生活中，我们也是这样做的，一个一个地尝试把候选物品放入「背包」，通过比较得出一个物品要不要拿走。

具体做法是：画一个 len 行，target + 1 列的表格。这里 len 是物品的个数，target 是背包的容量。len 行表示一个一个物品考虑，target + 1多出来的那 1 列，表示背包容量从 0 开始考虑。很多时候，我们需要考虑这个容量为 0 的数值。

状态与状态转移方程

- 状态定义：`dp[i][j]` 表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。
- 状态转移方程：很多时候，状态转移方程思考的角度是「分类讨论」，对于「0-1 背包问题」而言就是「当前考虑到的数字选与不选」。
  - 不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 `dp[i][j]` = true；
  - 选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。

状态转移方程：

`dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]`

一般写出状态转移方程以后，就需要考虑初始化条件。

- j - nums[i] 作为数组的下标，一定得保证大于等于 0 ，因此 nums[i] <= j；

- 注意到一种非常特殊的情况：j 恰好等于 nums[i]，即单独 nums[j] 这个数恰好等于此时「背包的容积」 j，这也是符合题意的。

初始化：`dp[0][0]` = false，因为候选数 nums[0] 是正整数，凑不出和为 00；

输出：`dp[len - 1][target]`，这里 len 表示数组的长度，target 是数组的元素之和（必须是偶数）的一半。



### 考虑空间优化（重要）

说明：这个技巧很常见、很基础，请一定要掌握。

「0-1 背包问题」常规优化：「状态数组」从二维降到一维，减少空间复杂度。

- 在「填表格」的时候，当前行只参考了上一行的值，因此状态数组可以只设置 2 行，使用「滚动数组」的技巧「填表格」即可；

- 实际上，在「滚动数组」的基础上还可以优化，在「填表格」的时候，当前行总是参考了它上面一行 「头顶上」 那个位置和「左上角」某个位置的值。因此，我们可以只开一个一维数组，从后向前依次填表即可。

- 「从后向前」 写的过程中，一旦 nums[i] <= j 不满足，可以马上退出当前循环，因为后面的 j 的值肯定越来越小，没有必要继续做判断，直接进入外层循环的下一层。相当于也是一个剪枝，这一点是「从前向后」填表所不具备的



