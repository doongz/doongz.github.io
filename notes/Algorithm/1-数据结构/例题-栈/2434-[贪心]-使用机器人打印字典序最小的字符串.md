题目：[2434. 使用机器人打印字典序最小的字符串](https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/description/)

给你一个字符串 `s` 和一个机器人，机器人当前有一个空字符串 `t` 。执行以下操作之一，直到 `s` 和 `t` **都变成空字符串：**

- 删除字符串 s 的 第一个 字符，并将该字符给机器人。机器人把这个字符添加到 t 的尾部。
- 删除字符串 t 的 最后一个 字符，并将该字符给机器人。机器人将该字符写到纸上。

请你返回纸上能写出的字典序最小的字符串。

```
示例 1：

输入：s = "zza"
输出："azz"
解释：用 p 表示写出来的字符串。
一开始，p="" ，s="zza" ，t="" 。
执行第一个操作三次，得到 p="" ，s="" ，t="zza" 。
执行第二个操作三次，得到 p="azz" ，s="" ，t="" 。

示例 2：

输入：s = "bac"
输出："abc"
解释：用 p 表示写出来的字符串。
执行第一个操作两次，得到 p="" ，s="c" ，t="ba" 。
执行第二个操作两次，得到 p="ab" ，s="c" ，t="" 。
执行第一个操作，得到 p="ab" ，s="" ，t="c" 。
执行第二个操作，得到 p="abc" ，s="" ，t="" 。

示例 3：

输入：s = "bdda"
输出："addb"
解释：用 p 表示写出来的字符串。
一开始，p="" ，s="bdda" ，t="" 。
执行第一个操作四次，得到 p="" ，s="" ，t="bdda" 。
执行第二个操作四次，得到 p="addb" ，s="" ，t="" 。
```

**提示：**

- `1 <= s.length <= 105`
- `s` 只包含小写英文字母。



本题是经典贪心：求出栈序列的最小字典序。

我们首先将题目描述进行转化：有一个初始为空的栈，给定字符的入栈顺序，求字典序最小的出栈序列。

当一个字符入栈后，我们持续检查栈顶元素 top。设还未入栈的字符中，字典序最小的字符是 min，有以下两种情况。

- top <= min：此时弹出 top 最优。如果此时按兵不动，下一个出栈的将会是大等于 top 的字符，答案不会变优。
- top > min：此时不弹出 top，等待后续更小的字符入栈。

所有字符都入栈后，栈内的剩余字符按顺序弹出即可。复杂度 O(n)。

---

*t* 是一个栈。

问题相当于从左到右遍历 *s*，在允许用一个辅助栈的前提下，计算能得到的字典序最小的字符串。

贪心地思考，为了让字典序最小，在遍历 s 的过程中，如果栈顶字符 ≤ 后续字符（未入栈）的最小值，那么应该出栈并加到答案末尾，否则应当继续遍历，取到比栈顶字符小的那个字符，这样才能保证字典序最小。

代码实现时，为了快速判断剩余字符的最小值，我们可以先统计 s 每个字符的出现次数 cnt，然后在遍历 s 的过程中更新 cnt，这样 cnt 中第一个正数对应的字符就是剩余字符中最小的。

```c++
class Solution {
public:
    string robotWithString(string s) {
        vector<int> cnter(26, 0);
        for (char c : s) {
            cnter[c - 'a']++;
        }

        stack<char> st;
        int min_char = 0;
        string ans = "";

        for (char c : s) {
            cnter[c - 'a']--;  // 从s中获取字符 c
            st.push(c);        // 入栈

            // 找到 s 中剩余中的最小字符
            // 写法上这里要特别注意，可以得到 z
            while (min_char < 25 && cnter[min_char] == 0) ++min_char;

            // 栈顶字符 <= 后续字符（未入栈）的最小值，那么应该出栈并加到答案末尾
            while (!st.empty() && st.top() <= min_char + 'a') {
                ans += st.top();
                st.pop();
            }
        }
        return ans;
    }
};

```

