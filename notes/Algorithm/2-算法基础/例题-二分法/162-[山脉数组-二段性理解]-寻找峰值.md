[162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

```
示例 1：

输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。

示例 2：

输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

提示：

1 <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1
对于所有有效的 i 都有 nums[i] != nums[i + 1]



## 方法：二分

和往常的题目一样，我们应当从是否具有「二段性」来考虑是否可以进行「二分」。

不难发现，如果 在确保有解的情况下，我们可以根据当前的分割点 mid 与左右元素的大小关系来指导 left 或者 right 的移动。

**假设当前分割点 mid 满足关系 num[mid] > nums[mid + 1] 的话，一个很简单的想法是 num[mid] 可能为峰值，而 nums[mid + 1] 必然不为峰值，于是让 r = midr=mid，从左半部分继续找峰值**。

上述做法正确的前提有两个：

- 对于任意数组而言，一定存在峰值（一定有解）
- 二分不会错过峰值。

**证明 1 ：对于任意数组而言，一定存在峰值（一定有解）**

根据题意，我们有「数据长度至少为 1」、「越过数组两边看做负无穷」和「相邻元素不相等」的起始条件。

我们可以根据数组长度是否为 1 进行分情况讨论：

- 数组长度为 1，由于边界看做负无穷，此时峰值为该唯一元素的下标；

- 数组长度大于 1，从最左边的元素 nums[0] 开始出发考虑：

  - 如果 nums[0] > nums[1]，那么最左边元素 nums[0] 就是峰值（结合左边界为负无穷）

  - 如果 nums[0] < nums[1]，由于已经存在明确的 nums[0] 和 nums[1] 大小关系，我们将 nums[0] 看做边界，nums[1] 看做新的最左侧元素，继续往右进行分析：

    - 如果在到达数组最右侧前，出现 nums[i] > nums[i + 1]，说明存在峰值位置 i（当我们考虑到 nums[i]，必然满足 nums[i] 大于前一元素的前提条件，当然前一元素可能是原始左边界）；
    - 到达数组最右侧，还没出现 nums[i] > nums[i + 1]，说明数组严格递增。此时结合右边界可以看做负无穷，可判定 nums[n - 1] 为峰值。

综上，我们证明了无论何种情况，数组必然存在峰值。

**证明 2 ：二分不会错过峰值**

其实基于「证明 1」，我们很容易就可以推理出「证明 2」的正确性。

整理一下由「证明 1」得出的推理：**如果当前位置大于其左边界或者右边界，那么在当前位置的右边或左边必然存在峰值**

换句话说，对于一个满足 nums[x] > nums[x - 1] 的位置，x 的右边一定存在峰值；或对于一个满足 nums[x] > nums[x + 1] 的位置，x 的左边一定存在峰值。

因此这里的「二段性」其实是指：在以 mid 为分割点的数组上，根据 nums[mid] 与 nums[mid±1] 的大小关系，可以确定其中一段满足「必然有解」，另外一段不满足「必然有解」（可能有解，可能无解）。

至此，我们证明了始终选择大于边界一端进行二分，可以确保选择的区间一定存在峰值，并随着二分过程不断逼近峰值位置。

### 总结

通过本题，我们可以对「二分」有进一步的认识。

最早在 33. 搜索旋转排序数组 中，我们强调，二分的本质是「二段性」而非「单调性」，而经过本题，我们进一步发现「二段性」还能继续细分

**不仅仅只有满足 01 特性（满足/不满足）的「二段性」可以使用二分，满足 1? 特性（一定满足/不一定满足）也可以二分**

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {  // 峰点一定出现在左边 [left, mid]
                right = mid;
            } else {  // 峰点一定出现在右边 [mid+1, right]，等于时峰点在两侧都可能出现
                left = mid + 1;
            }
        }
        return left;
    }
};
```

