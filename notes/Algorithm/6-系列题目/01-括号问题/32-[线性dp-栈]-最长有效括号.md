题目：[32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

[题解参考](https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/)

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

```
示例 1：

输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"

示例 2：

输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"

示例 3：

输入：s = ""
输出：0
```

**提示：**

- `0 <= s.length <= 3 * 104`
- `s[i]` 为 `'('` 或 `')'`

## 方法一：线性dp

个人感觉，线性dp的方法比栈的方法好理解

**1. 定义状态**

`dp[i]` 表示以下标 i 字符结尾的最长有效括号的长度

**2. 状态转移方程**

有效的子串一定以 `)` 结尾，`(` 结尾的子串对应的 dp 值必定为 0 ，只需要求解 `)` 在 dp 数组中对应位置的值。

考虑当前为 `)` 时，状态怎样转移，有两大类情况 `....()` 和 `....))`

- 如果 `s[i-1] = '('`，显然 `dp[i] = dp[i-2] + 2`

- 如果 `s[i-1] = ')'`，先检查 `s[i-1]` 位置上的右括号能不能构成回文串，`dp[i-1] != 0`

  - 不能的话，`s[i]` 结尾的右括号也一定不能构成回文串

  - 可构成回文串，找到 `i-1` 位置对应的左括号的下标，`i-1-dp[i-1]+1 = i-dp[i-1]`，`i` 位置需要对应的括号的下标，显然是 `i-dp[i-1]-1`

    - 如果 i 位置对应位置的括号 `s[i-dp[i-1]-1] == '('` 能匹配上，至少是形如 `((..))`，`dp[i] = dp[i-1] + 2`

    - 能匹配上的前提下，前面还有任意括号，形如 `..((..))`，还得加上前面的可能 `dp[i] += dp[i - dp[i - 1] - 2]`

注意下标别越界

**3. 初始化**

dp 数组全部初始化为 0 

**4. 输出**

在遍历的记录最大的 `dp[i]`

**空间优化**

优化不了

**复杂度分析**

`O(n)`

`O(n)`

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();

        // dp[i] i为结尾，且构成最长子串的长度
        vector<int> dp(n, 0);
        int ans = 0;
        for (int i = 1; i < n; i++) {
            if (s[i] != ')') continue;  // 右括号，才有必要检查
            if (s[i - 1] == '(') {      // ....()
                if (i >= 2) {
                    dp[i] = dp[i - 2] + 2;
                } else if (i == 1) {
                    dp[i] = 2;
                }

            } else if (s[i - 1] == ')' && dp[i - 1] != 0) {  // .(..))
                // i-1-dp[i-1]+1 = i-dp[i-1]
                if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {  // ((..))
                    dp[i] = dp[i - 1] + 2;
                    if (i - dp[i - 1] - 2 >= 0) {  // ..((..))
                        dp[i] += dp[i - dp[i - 1] - 2];
                    }
                }
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```



## 方法二：栈

通过栈，可以在遍历给定字符串的过程中去判断到目前为止扫描的子串的有效性，同时能得到最长有效括号的长度

具体做法是我们始终保持**栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」**，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：

- 遇到左括号，入栈中
- 遇到右括号，先弹出栈顶元素表示匹配了当前右括号
  - 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
  - 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」

时间复杂度：`O(n)`

空间复杂度：`O(n)`

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int ans = 0;
        stack<int> st;
        st.push(-1);
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') {  // 左括号，入栈下标
                st.push(i);
            } else {               // 右括号
                st.pop();          // 弹出栈顶元素表示匹配了当前右括号
                if (st.empty()) {  // 如果空了，入栈
                    st.push(i);
                } else {  // 如果栈不空，此时的右括号下标-栈顶下标（匹配左下标的前一位）
                    ans = max(ans, i - st.top());
                }
            }
        }
        return ans;
    }
};
```

