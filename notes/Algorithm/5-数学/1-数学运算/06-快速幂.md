## 快速幂

快速幂解析：[面试题16. 数值的整数次方（快速幂，清晰图解） - 数值的整数次方 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/)

比如要求 `x^11`，正常的乘积需要循环乘 `11` 次，时间复杂度为 `O(n)`

快速幂的思想就是将指数 `11` 可以转成二进制数 `1011`，则原来的式子可以转化成
$$
x^{11} = x^{2^{3} + 2^{1} + 2^{0}} = x^{2^{3}} \times x^{2^{1}} \times x^{2^{0}}
$$
此时只运算了3次乘积，时间复杂度降至 `O(logn)`

下方代码中的 `x *= x` 是一个累乘的过程，得到四位二进制数，对应的四个权重

```
x
x *= x
x^2 *= x^2
x^4 *= x^4
```

`1011` 二进制数，从右至左分别为 `1 1 0 1` ，**只有在 `1` 的位置上，才有相应的权重**

这也就是为什么需要通过与运算：`(b & 1) == 1` 判断最后一位是否为 `1`。

```
<----------------------------------------
   1	       0		   1		   1
x^(2^3) 	x^(2^2) 	x^(2^1) 	x^(2^0)
  x^8 	 	  x^4         x^2          x
```

最终的结果就是将每一位的1 所对应的权重相乘即可：`x^8 + x^2 + x`

```c++
class Solution {
public:
    double myPow(double x, int n) {
        if (x == 0) return 0;
        long b = n;
        double res = 1.0;

        if (b < 0) {
            x = 1 / x;
            b = -b;
        }
        while (b > 0) {
            // 最后一位为1，需要乘上该位上的权重
            if ((b & 1) == 1) {
                res *= x;
            }
            x *= x;
            b >>= 1;
        }
        return res;
    }
};
```

> 为什么要把其中的n换成long类型？
>
> 因为32位int是补码形式，正数是和原码相同，范围是0到2的32次方-1，但是对于负数，需要反码+1，范围是2的32次方到0，负数要比正数多一个数字。如果传进来的int刚好是负2的32次方，取相反数之后就超过int32类型的取值范围了，所以需要用long来扩大取值范围。