# 数组

## 一、基本概念

要想把数据放入内存，必须先要分配内存空间。放入4个整数，就得分配4个`int`类型的内存空间：

```c
int a[4];
```

这样，就在内存中分配了4个`int`类型的内存空间，共 4×4=16 个字节，并为它们起了一个名字，叫`a`。

我们把这样的一组数据的集合称为**数组（Array）**，它所包含的每一个数据叫做数组元素（Element），所包含的数据的个数称为数组长度（Length），例如`int a[4];`就定义了一个长度为4的整型数组，名字是`a`。

数组中的每个元素都有一个序号，这个序号从0开始，而不是从我们熟悉的1开始，称为下标（Index）。使用数组元素时，指明下标即可，形式为：

```c
arrayName[index]
```

arrayName 为数组名称，index 为下标。例如，a[0] 表示第0个元素，a[3] 表示第3个元素。

接下来我们就把第一行的4个整数放入数组：

```c
a[0]=20;
a[1]=345;
a[2]=700;
a[3]=22;
```

这里的0、1、2、3就是数组下标，a[0]、a[1]、a[2]、a[3] 就是数组元素。

```c
#include <stdio.h>
int main() {
    int nums[10];
    int i;

    //将1~10放入数组中
    for (i = 0; i < 10; i++) {
        nums[i] = (i + 1);
    }

    //依次输出数组元素
    for (i = 0; i < 10; i++) {
        printf("%d ", nums[i]);
    }

    return 0;
}
// 1 2 3 4 5 6 7 8 9 10
```

让用户输入 10 个数字并放入数组中：

```c
#include <stdio.h>
int main(){
    int nums[10];
    int i;
   
    //从控制台读取用户输入
    for(i=0; i<10; i++){
        scanf("%d", &nums[i]);  //注意取地址符 &，不要遗忘哦
    }
   
    //依次输出数组元素
    for(i=0; i<10; i++){
        printf("%d ", nums[i]);
    }
   
    return 0;
}
```

### 1、定义

最后我们来总结一下数组的定义方式：

```
dataType  arrayName[length];
```

dataType 为数据类型，arrayName 为数组名称，length 为数组长度。例如：

```c
float m[12];  //定义一个长度为 12 的浮点型数组char ch[9];  //定义一个长度为 9 的字符型数组
```

需要注意的是：

- 数组中每个元素的数据类型必须相同，对于`int a[4];`，每个元素都必须为 int。
- 数组长度 length 最好是整数或者常量表达式，例如 `10、20*4` 等，这样在所有编译器下都能运行通过；如果 length 中包含了变量，例如 `n、4*m` 等，在某些编译器下就会报错
- 访问数组元素时，下标的取值范围为 0 ≤ index < length，过大或过小都会越界，导致数组溢出

### 2、数组内存是连续的

组是一个整体，它的内存是连续的；也就是说，数组元素之间是相互挨着的，彼此之间没有一点点缝隙。

**「数组内存是连续的」这一点很重要，所以我使用了一个大标题来强调。连续的内存为指针操作（通过指针来访问数组元素）和内存处理（整块内存的复制、写入等）提供了便利，这使得数组可以作为缓存（临时存储数据的一块内存）使用**。

### 3、数组的初始化

上面的代码是先定义数组再给数组赋值，我们也可以在定义数组的同时赋值，例如：

```c
int a[4] = {20, 345, 700, 22};
```

数组元素的值由`{ }`包围，各个值之间以`,`分隔。

**对于数组的初始化需要注意以下几点：**

- 可以只给部分元素赋值。当`{ }`中值的个数少于元素个数时，只给前面部分元素赋值。例如：

```c
int a[10]={12, 19, 22 , 993, 344};
```

表示只给 a[0]~a[4] 5个元素赋值，而后面 5 个元素自动初始化为 0。

当赋值的元素少于数组总体元素的时候，剩余的元素自动初始化为 0：

- 对于short、int、long，就是整数 0；
- 对于char，就是字符 '\0'；
- 对于float、double，就是小数 0.0。


我们可以通过下面的形式**将数组的所有元素初始化为 0**：

```c
int nums[10] = {0};
char str[10] = {0};
float scores[10] = {0.0};
```

由于剩余的元素会自动初始化为 0，所以只需要给第 0 个元素赋值为 0 即可。

- 只能给元素逐个赋值，不能给数组整体赋值。例如给 10 个元素全部赋值为 1，只能写作：

```c
int a[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
```

而不能写作：

```c
int a[10] = 1;
```

- 如给全部元素赋值，那么在定义数组时可以不给出数组长度。例如：

```c
int a[] = {1, 2, 3, 4, 5};
```

等价于

```c
int a[5] = {1, 2, 3, 4, 5};
```



借助数组来输出一个 4×4 的矩阵：

```c
#include <stdio.h>
int main() {
    int a[4] = {20, 345, 700, 22};
    int b[4] = {56720, 9999, 20098, 2};
    int c[4] = {233, 205, 1, 6666};
    int d[4] = {34, 0, 23, 23006783};
    printf("%-9d %-9d %-9d %-9d\n", a[0], a[1], a[2], a[3]);
    printf("%-9d %-9d %-9d %-9d\n", b[0], b[1], b[2], b[3]);
    printf("%-9d %-9d %-9d %-9d\n", c[0], c[1], c[2], c[3]);
    printf("%-9d %-9d %-9d %-9d\n", d[0], d[1], d[2], d[3]);
    return 0;
}
// 20        345       700       22
// 56720     9999      20098     2
// 233       205       1         6666
// 34        0         23        23006783
```

### 4、判断数组中是否包含某个元素

```c
#include <stdio.h>
int main() {
    int nums[10] = {1, 10, 6, 296, 177, 23, 0, 100, 34, 999};
    int i, num, thisindex = -1;

    printf("Input an integer: ");
    scanf("%d", &num);
    for (i = 0; i < 10; i++) {
        if (nums[i] == num) {
            thisindex = i;
            break;
        }
    }
    if (thisindex < 0) {
        printf("%d isn't  in the array.\n", num);
    } else {
        printf("%d is  in the array, it's index is %d.\n", num, thisindex);
    }
    return 0;
}
// Input an integer: 100
// 100 is  in the array, it's index is 7.
```

## 二、二维数组

### 1、二维数组的定义

```c
dataType arrayName[length1][length2];
int a[3][4];
```

二维数组在概念上是二维的，但在内存中是连续存放的；

在C语言中，二维数组是按行排列的。也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4)=48 个字节。

```c
#include <stdio.h>
int main() {
    int i, j;     //二维数组下标
    int sum = 0;  //当前科目的总成绩
    int average;  //总平均分
    int v[3];     //各科平均分
    int a[5][3];  //用来保存每个同学各科成绩的二维数组
    printf("Input score:\n");
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 5; j++) {
            scanf("%d", &a[j][i]);  //输入每个同学的各科成绩
            sum += a[j][i];         //计算当前科目的总成绩
        }
        v[i] = sum / 5;  // 当前科目的平均分
        sum = 0;
    }
    average = (v[0] + v[1] + v[2]) / 3;
    printf("Math: %d\nC Languag: %d\nEnglish: %d\n", v[0], v[1], v[2]);
    printf("Total: %d\n", average);
    return 0;
}
```

### 2、二维数组的初始化（赋值）

二维数组的初始化可以按行分段赋值，也可按行连续赋值。

例如，对于数组 a[5][3]，按行分段赋值应该写作：

```c
int a[5][3]={ {80,75,92}, {61,65,71}, {59,63,70}, {85,87,90}, {76,77,85} };
```

按行连续赋值应该写作：

```c
int a[5][3]={80, 75, 92, 61, 65, 71, 59, 63, 70, 85, 87, 90, 76, 77, 85};
```

这两种赋初值的结果是完全相同的。

```c
#include <stdio.h>
int main() {
    int i, j;     //二维数组下标
    int sum = 0;  //当前科目的总成绩
    int average;  //总平均分
    int v[3];     //各科平均分
    int a[5][3] = {{80, 75, 92}, {61, 65, 71}, {59, 63, 70}, {85, 87, 90}, {76, 77, 85}};
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 5; j++) {
            sum += a[j][i];  //计算当前科目的总成绩
        }
        v[i] = sum / 5;  // 当前科目的平均分
        sum = 0;
    }
    average = (v[0] + v[1] + v[2]) / 3;
    printf("Math: %d\nC Languag: %d\nEnglish: %d\n", v[0], v[1], v[2]);
    printf("Total: %d\n", average);
    return 0;
}
// Math: 72
// C Languag: 73
// English: 81
// Total: 75
```

#### 对于二维数组的初始化还要注意以下几点：

- 可以只对部分元素赋值，未赋值的元素自动取“零”值。例如：

```c
int a[3][3] = {{1}, {2}, {3}};
```

是对每一行的第一列元素赋值，未赋值的元素的值为 0。赋值后各元素的值为：
1  0  0
2  0  0
3  0  0

再如：

```c
int a[3][3] = {{0,1}, {0,0,2}, {3}};
```

赋值后各元素的值为：
0  1  0
0  0  2
3  0  0

- 如果对全部元素赋值，那么第一维的长度可以不给出。例如：

```c
int a[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
```

可以写为：

```c
int a[][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
```

- 二维数组可以看作是由一维数组嵌套而成的；如果一个数组的每个元素又是一个数组，那么它就是二维数组。当然，前提是各个元素的类型必须相同。根据这样的分析，一个二维数组也可以分解为多个一维数组，C语言允许这种分解。

例如，二维数组`a[3][4]`可分解为三个一维数组，它们的数组名分别为 a[0]、a[1]、a[2]。

这三个一维数组可以直接拿来使用。这三个一维数组都有 4 个元素，比如，一维数组 a[0] 的元素为 `a[0][0]、a[0][1]、a[0][2]、a[0][3]`

## 三、字符数组和字符串

### 1、基础使用

用来存放字符的数组称为**字符数组**，例如：

```c
char a[10];  //一维字符数组
char b[5][10];  //二维字符数组
char c[20]={'c', '  ', 'p', 'r', 'o', 'g', 'r', 'a','m'};  // 给部分数组元素赋值
char d[]={'c', ' ', 'p', 'r', 'o', 'g', 'r', 'a', 'm' };  //对全体元素赋值时可以省去长度
```

字符数组实际上是一系列字符的集合，也就是**字符串（String）**。在C语言中，没有专门的字符串变量，没有string类型，通常就用一个字符数组来存放一个字符串。

C语言规定，可以将字符串直接赋值给字符数组，例如：

```c
char str[30] = {"hello world"};
char str[30] = "hello world";  //这种形式更加简洁，实际开发中常用
```

数组第 0 个元素为`'c'`，第 1 个元素为`'.'`，第 2 个元素为`'b'`，后面的元素以此类推。

为了方便，你也可以不指定数组长度，从而写作：

```c
char str[] = {"hello world"};
char str[] = "hello world";  //这种形式更加简洁，实际开发中常用
```

给字符数组赋值时，我们通常使用这种写法，将字符串一次性地赋值（可以指明数组长度，也可以不指明），而不是一个字符一个字符地赋值，那样做太麻烦了。

这里需要留意一个坑，**字符数组只有在定义时才能将整个字符串一次性地赋值给它，一旦定义完了，就只能一个字符一个字符地赋值了**。请看下面的例子：

```c
char str[7];
str = "abc123";  // 错误
// 正确
str[0] = 'a'; str[1] = 'b'; str[2] = 'c';
str[3] = '1'; str[4] = '2'; str[5] = '3';
```

### 2、字符串结束标志（划重点）

在C语言中，字符串总是以`'\0'`作为结尾，所以`'\0'`也被称为字符串结束标志，或者字符串结束符。

> `'\0'`是 ASCII 码表中的第 0 个字符，英文称为 NUL，中文称为“空字符”。该字符既不能显示，也没有控制功能，输出该字符不会有任何效果，它在C语言中唯一的作用就是作为字符串结束标志。

C语言在处理字符串时，会从前往后逐个扫描字符，一旦遇到`'\0'`就认为到达了字符串的末尾，就结束处理。`'\0'`至关重要，没有`'\0'`就意味着永远也到达不了字符串的结尾。

由`" "`包围的字符串会自动在末尾添加`'\0'`。例如，`"abc123"`从表面看起来只包含了 6 个字符，其实不然，C语言会在最后隐式地添加一个`'\0'`，这个过程是在后台默默地进行的，所以我们感受不到。

需要注意的是，**逐个字符地给数组赋值并不会自动添加** `'\0'`，例如：

```c
char str[] = {'a', 'b', 'c'};
```

数组 str 的长度为 3，而不是 4，因为最后没有`'\0'`。

**当用字符数组存储字符串时，要特别注意`'\0'`，要为`'\0'`留个位置**；这意味着，字符数组的长度至少要比字符串的长度大 1。请看下面的例子：

```c
char str[7] = "abc123";
```

`"abc123"`看起来只包含了 6 个字符，我们却将 str 的长度定义为 7，就是为了能够容纳最后的`'\0'`。如果将 str 的长度定义为 6，它就无法容纳`'\0'`了。

> 当字符串长度大于数组长度时，有些较老或者不严格的编译器并不会报错，甚至连警告都没有，这就为以后的错误埋下了伏笔，读者自己要多多注意。

有些时候，程序的逻辑要求我们必须逐个字符地为数组赋值，这个时候就很容易遗忘字符串结束标志`'\0'`。下面的代码中，我们将 26 个大写英文字符存入字符数组，并以字符串的形式输出：

```c
#include <stdio.h>
int main() {
    char str[30];
    char c;
    int i;
    for (c = 65, i = 0; c <= 90; c++, i++) {
        str[i] = c;
    }
    printf("%s\n", str);
    return 0;
}
// ABCDEFGHIJKLMNOPQRSTUVWXYZx01
```

在函数内部定义的变量、数组、结构体、共用体等都称为局部数据。在很多编译器下，局部数据的初始值都是随机的、无意义的，而不是我们通常认为的“零”值。这一点非常重要，大家一定要谨记，否则后面会遇到很多奇葩的错误。

要想避免这些问题也很容易，在字符串的最后手动添加`'\0'`即可。修改上面的代码，在循环结束后添加`'\0'`：

```c
#include <stdio.h>
int main() {
    char str[30];
    char c;
    int i;
    for (c = 65, i = 0; c <= 90; c++, i++) {
        str[i] = c;
    }
    str[i] = 0;  //此处为添加的代码，也可以写作 str[i] = '\0';
    printf("%s\n", str);

    return 0;
}
// ABCDEFGHIJKLMNOPQRSTUVWXYZ
```

更加专业的做法是将数组的所有元素都初始化为“零”值，这样才能够从根本上避免问题。

```c
#include <stdio.h>
int main() {
    char str[30] = {0};  //将所有元素都初始化为 0，或者说 '\0'
    char c;
    int i;
    for (c = 65, i = 0; c <= 90; c++, i++) {
        str[i] = c;
    }
    printf("%s\n", str);

    return 0;
}
// ABCDEFGHIJKLMNOPQRSTUVWXYZ
```

### 3、字符串长度

字符串包含了多少个字符（不包括最后的结束符`'\0'`）。例如`"abc"`的长度是 3，而不是 4。

使用`string.h`头文件中的 strlen() 函数来求字符串的长度，它的用法为：

```c
#include <stdio.h>
#include <string.h>  //记得引入该头文件
int main() {
    char str[] = "hello world";
    long len = strlen(str);
    printf("The lenth of the string is %ld.\n", len);

    return 0;
}
// The lenth of the string is 11.
```

## 四、字符串的输入和输出

### 1、字符串的输出

在C语言中，有两个函数可以在控制台（显示器）上输出字符串，它们分别是：

- puts()：输出字符串并自动换行，该函数只能输出字符串。
- printf()：通过格式控制符`%s`输出字符串，不能自动换行。除了字符串，printf() 还能输出其他类型的数据。

```c
#include <stdio.h>
int main() {
    char str[] = "hello world";
    printf("%s\n", str);            //通过字符串名字输出
    printf("%s\n", "hello world");  //直接输出
    puts(str);                      //通过字符串名字输出
    puts("hello world");            //直接输出
    return 0;
}
// hello world
```

输出字符串时只需要给出名字，不能带后边的`[ ]`

### 2、字符串的输入

在C语言中，有两个函数可以让用户从键盘上输入字符串，它们分别是：

- scanf()：通过格式控制符`%s`输入字符串。除了字符串，scanf() 还能输入其他类型的数据。
- gets()：直接输入字符串，并且只能输入字符串。

但是，scanf() 和 gets() 是有区别的：

- scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。
- gets() 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。换句话说，gets() 用来读取一整行字符串。

```c
#include <stdio.h>
int main() {
    char str1[30] = {0};
    char str2[30] = {0};
    char str3[30] = {0};
    // gets() 用法
    printf("Input a string: ");
    gets(str1);
    // scanf() 用法
    printf("Input a string: ");
    scanf("%s", str2);
    scanf("%s", str3);

    printf("\nstr1: %s\n", str1);
    printf("str2: %s\n", str2);
    printf("str3: %s\n", str3);
    return 0;
}
// Input a string: hello world
// Input a string: do jo

// str1: hello world
// str2: do
// str3: jo
```

就目前学到的知识而言，int、char、float 等类型的变量用于 scanf() 时都要在前面添加`&`，

**而数组或者字符串用于 scanf() 时不用添加`&`，它们本身就会转换为地址**

## 五、字符串处理函数

`string.h`是一个专门用来处理字符串的头文件，它包含了很多字符串处理函数

### 1、字符串连接函数 strcat()

strcat 是 string catenate 的缩写，意思是把两个字符串拼接在一起，语法格式为：

```
strcat(arrayName1, arrayName2);
```

strcat() 将把 arrayName2 连接到 arrayName1 后面，并删除原来 arrayName1 最后的结束标志`'\0'`。

**这意味着，arrayName1 必须足够长，要能够同时容纳 arrayName1 和 arrayName2，否则会越界（超出范围）**

**strcat() 的返回值为 arrayName1 的地址**。

```c
#include <stdio.h>
#include <string.h>
int main() {
    char str1[100] = "My name is ";
    char str2[60] = "DoDo";
    strcat(str1, str2);
    printf(str1);
    return 0;
}
// My name is DoDo
```

### 2、字符串复制函数 strcpy()

strcpy 是 string copy 的缩写，意思是字符串复制，也即将字符串从一个地方复制到另外一个地方，语法格式为：

```
strcpy(arrayName1, arrayName2);
```

strcpy() 会把 arrayName2 中的字符串拷贝到 arrayName1 中，字符串结束标志`'\0'`也一同拷贝。请看下面的例子：

```c
#include <stdio.h>
#include <string.h>
int main() {
    char str1[50] = "hello";
    char str2[50] = "world";
    strcpy(str1, str2);
    printf("str1: %s\n", str1);
    return 0;
}
// str1: world
```

strcpy() 要求 arrayName1 要有足够的长度，否则不能全部装入所拷贝的字符串。

### 3、字符串比较函数 strcmp()

strcmp 是 string compare 的缩写，意思是字符串比较，语法格式为：

```
strcmp(arrayName1, arrayName2);
```

字符本身没有大小之分，strcmp() 以各个字符对应的 ASCII 码值进行比较。strcmp() 从两个字符串的第 0 个字符开始比较，如果它们相等，就继续比较下一个字符，直到遇见不同的字符，或者到字符串的末尾。

返回值：

- 若 arrayName1 和 arrayName2 相同，则返回0；
- 若 arrayName1 大于 arrayName2，则返回大于 0 的值；
- 若 arrayName1 小于 arrayName2，则返回小于0 的值。

```c
#include <stdio.h>
#include <string.h>
int main() {
    char a[] = "aBcDeF";
    char b[] = "AbCdEf";
    char c[] = "aacdef";
    char d[] = "aBcDeF";
    printf("a VS b: %d\n", strcmp(a, b));
    printf("a VS c: %d\n", strcmp(a, c));
    printf("a VS d: %d\n", strcmp(a, d));

    return 0;
}
// a VS b: 32
// a VS c: -31
// a VS d: 0
```

## 六、数组是静态的，不能插入或删除元素

**在C语言中，数组一旦被定义后，占用的内存空间就是固定的，容量就是不可改变的，既不能在任何位置插入元素，也不能在任何位置删除元素，只能读取和修改元素，我们将这样的数组称为静态数组**。

反过来说，如果数组在定义后可以改变容量，允许在任意位置插入或者删除元素，那么这样的数组称为动态数组。

如果由于项目要求，必须要在数组中插入或者删除元素，该怎么办呢？没办法，只能再造一个新数组！

```c
#include <stdio.h>
//自定义函数，用来输出数组元素
void display_array(int arr[], int len) {
    int i;
    for (i = 0; i < len; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}
int main() {
    int nums[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int nums_new1[9];
    int nums_new2[11];
    int i;

    //删除nums第6个元素
    for (i = 0; i < 10; i++) {
        // i等于6时直接跳过，不进行任何操作
        if (i < 6) {
            nums_new1[i] = nums[i];
        } else if (i > 6) {
            nums_new1[i - 1] = nums[i];
        }
    }
    display_array(nums_new1, 9);

    //在nums第6个元素后面插入一个整数 55
    for (i = 0; i < 10; i++) {
        if (i < 7) {
            nums_new2[i] = nums[i];
        } else if (i > 7) {
            nums_new2[i + 1] = nums[i];
        } else {  // i等于7
            nums_new2[i] = 55;
            nums_new2[i + 1] = nums[i];
        }
    }
    display_array(nums_new2, 11);

    return 0;
}
```

### C语言数组为什么是静态的

不能插入和删除数组元素有时候会非常麻烦，比如一个数组保存了某个班级的学生学号，现在有一名学生退学了，就得把 TA 从数组中剔除，但是C语言并不支持这么做，这就给编程带来了不小的麻烦。

数组元素都是紧挨着排布的，中间没有空隙，不管是插入元素还是删除元素，都得移动该元素后面的内存：

- 在第 i 个元素后面插入一个新元素时，第 i 个元素后面的所有元素都要往后移动一个元素的位置，从而给新元素腾出位置来。如果该数组后面紧跟的是其它有用数据，那么为了防止覆盖有用数据，还不敢直接往后移动元素，必须得重新开辟一块内存，把所有的元素都复制过去。
- 删除第 i 个元素就比较简单了，不管三七二十一，把第 i 个元素后面的所有元素都向前移动即可。

**插入和删除数组元素都要移动内存，甚至重新开辟一块内存，这是相当消耗资源的。如果一个程序中有大量的此类操作，那么程序的性能将堪忧，这有悖于「C语言非常高效」的初衷，所以C语言并不支持动态数组**。

另外，很多时候我们需要把数组的地址保存到一个变量里面（等大家学到[指针](http://c.biancheng.net/c/80/)时就会见到这种情况），如果数组重新开辟了内存，而变量里面的地址不跟着改变的话，后续再使用该变量就会导致错误。让C语言本身去维护这些变量的值，以保持同步更新，这又是不可能做到的，所以这个矛盾无法从根本上解决。

总之，为了保证程序执行效率，为了防止操作错误，C语言只支持静态数组，不支持动态数组。

## 七、数组的越界和溢出

### 1、数组越界

C语言数组是静态的，不能自动扩容，当下标小于零或大于等于数组长度时，就发生了越界（Out Of Bounds），访问到数组以外的内存。

- 如果下标小于零，就会发生下限越界（Off Normal Lower）；
- 如果下标大于等于数组长度，就会发生上限越界（Off Normal Upper）。

**C语言为了提高效率，保证操作的灵活性，并不会对越界行为进行检查，即使越界了，也能够正常编译，只有在运行期间才可能会发生问题**。请看下面的代码：

```c
#include <stdio.h>
int main() {
    int a[3] = {10, 20, 30}, i;
    for (i = -2; i <= 4; i++) {
        printf("a[%d]=%d\n", i, a[i]);
    }
    return 0;
}
// a[-2]=-2
// a[-1]=0
// a[0]=10
// a[1]=20
// a[2]=30
// a[3]=1171521663
// a[4]=1257677011
```

当发生数组越界时，如果我们对该内存有使用权限，那么程序将正常运行，但会出现不可控的结果（如上例所示）；如果我们对该内存没有使用权限，或者该内存压根就没有被分配，那么程序将会崩溃。

```c
#include <stdio.h>
int main() {
    int a[3];
    printf("%d", a[10000]);
    return 0;
}
// 出现异常。
// EXC_BAD_ACCESS (code=1, address=0x7ff7bff08cdc)
```

每个程序能使用的内存都是有限的，该程序要访问 4*10000 字节处的内存，显然太远了，超出了程序的访问范围。这个地方的内存可能没有被分配，可能是系统本身占用的内存，可能是其它数据的内存，如果放任这种行为，将带来非常危险的后果，操作系统只能让程序停止运行。

### 2、数组溢出

当赋予数组的元素个数超过数组长度时，就会发生溢出（Overflow）。如下所示：

```c
int a[3] = {1, 2, 3, 4, 5};
```

数组长度为3，初始化时却赋予5个元素，超出了数组容量，所以只能保存前3个元素，后面的元素被丢弃。

**GCC、LLVM/Clang、低版本的 VS（例如 VS2010）发现数组溢出只会给出警告，并不会报错**。但是高版本的 VS（例如 VS2015、VS2017）发现数组溢出时会报错，禁止编译通过

一般情况下数组溢出不会有什么问题，顶多是丢失多余的元素。但是当以字符串的形式输出字符数组时，就会产生不可控的情况，请看下面的代码：

```c
#include <stdio.h>
int main() {
    char str[10] = "abcdefghighlimn";
    printf(str);
    return 0;
}
// fatal error: initializer-string for char array is too long
//     char str[10] = "abcdefghighlimn";
//                    ^~~~~~~~~~~~~~~~~
// 1 error generated.
```

字符串的长度大于数组长度，数组只能容纳字符串的前面一部分，也就是`"http://c.b"`，即使编译器在最后添加了`'\0'`，它也保存不到数组里面，所以 printf() 扫描数组时不会遇到结束符`'\0'`，只能继续向后扫描。而后面内存中的数据我们不知道是什么，字符能否识别，何时遇到`'\0'`，这些都是不确定的。当字符无法识别时，就会出现乱码，显示奇怪的字符。

由此可见，在用字符串给字符数组赋值时，要保证数组长度大于字符串长度，以容纳结束符`'\0'`。

## 八、C语言变长数组：使用变量指明数组的长度

下面的代码使用常量表达式指明数组长度，在任何编译器下都能编译通过：

```c
int a[10];   //长度为10
int b[3*5];  //长度为15
int c[4+8];  //长度为12
```

下面的代码使用变量指明数组长度，在 GCC 和 Xcode 下能够编译通过，而在 VC 和 VS（包括 VC 6.0、VS2010、VS2013、VS2015、VS2017 等）下都会报错：

```c
int m = 10, n;
scanf("%d", &n);
int a[m], b[n];
```


在实际编程中，有时数组的长度不能提前确定，如果这个变化范围小，那么使用常量表达式定义一个足够大的数组就可以，如果这个变化范围很大，就可能会浪费内存，这时就可以使用变长数组。请看下面的代码：

```c
#include <stdio.h>
int main() {
    int n;
    printf("Input string length: ");
    scanf("%d", &n);
    scanf("%*[^\n]");
    scanf("%*c");  //清空输入缓冲区
    char str[n];
    printf("Input a string: ");
    gets(str);
    puts(str);
    return 0;
}

// Input string length: 100
// warning: this program uses gets(), which is unsafe.
// Input a string: hello world
// hello world
```

变量的值在编译期间并不能确定，只有等到程序运行后，根据计算结果才能知道它的值到底是什么，所以数组长度中一旦包含了变量，那么数组长度在编译期间就不能确定了，也就不能为数组分配内存了

只有等到程序运行后，得到了变量的值，确定了具体的长度，才能给数组分配内存，我们将这样的数组称为变长数组(VLA, Variable Length Array)。

**普通数组（固定长度的数组）是在编译期间分配内存的，而变长数组是在运行期间分配内存的**。

### 变长数组仍然是静态数组

注意，变长数组是说数组的长度在**定义之前**可以改变，一旦定义了，就不能再改变了，所以变长数组的容量也是不能扩大或缩小的，它仍然是静态数组。以上面的代码为例，第 8 行代码是数组定义，此时就确定了数组的长度，在此之前长度可以随意改变，在此之后长度就固定了。