题目：[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**1. 定义状态**

dp[i] 为在 [0, i] 范围内的偷窃最高金额

**2. 状态转移方程**

根据**当前位置 nums[i] 是否被偷盗**，分为两个子问题

1. 若当前位置 i 被偷，那么前一位置 i-1 肯定不会被偷，我们细想下这里的状态该怎样转移

是不是可以直接用 `dp[i] = dp[i-1] + nums[i]` 呢？**不行**

因为此时【位置 i 被偷】是一种假设，推导的【 i-1 不被偷】继承了假设，d[i-1] 来代表【 i-1 不被偷】是不准确的

但可以确定的是，若【 i-1 不被偷】，那么它的最高金额一定等于更前一个位置上的最高金额 dp[i-2]，**d[i-2] 来代表【 i-1 不被偷】才是准确的**，因此这种情况下 `dp[i] = dp[i-2] + nums[i]`

2. 若当前位置 i 没被偷，那么前一位置 i-1 可能会被偷，也可能没被偷

由于我们对状态的定义，dp[i-1] 天生包含了对 i-1 位置可能会被偷、也可能没被偷的统计结果，这个子问题已经被完美解决了，直接拿来用

因此，这种情况下 `dp[i] = dp[i-1]`

最后，这两个子问题再综合下，取最大值作为 [0, i] 范围内的偷窃最高金额
$$
dp[i] = max(dp[i-2]+nums[i], \ dp[i-1])
$$
**3. 初始化**

计算当前位置的时候，需要往前面看两位，因此需要初始化前面两位

dp[0] = nums[0]，有一个数的时候，只能偷这个

dp[0] = max(nums[0], nums[1])，有两个数的时候，偷最大的

**4. 输出**

dp[n-1] 为在 [0, n-1] 范围内的偷窃最高金额

**空间优化**

当前状态的计算仅与前面两位有关，可进行优化

**复杂度分析**

时间复杂度：`O(n)`

空间复杂度：`O(n)` 或`O(1)`

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];
        if (n == 2) return max(nums[0], nums[1]);

        vector<int> dp(n, 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);

        for (int i = 2; i < n; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[n - 1];
    }
};
```

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];
        if (n == 2) return max(nums[0], nums[1]);

        int prepre = nums[0];
        int pre = max(nums[0], nums[1]);
        int cur = pre;

        for (int i = 2; i < n; i++) {
            cur = max(prepre + nums[i], pre);
            prepre = pre;
            pre = cur;
        }
        return cur;
    }
};
```

### 