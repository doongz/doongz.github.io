题目：[剑指 Offer 60. n个骰子的点数](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/)

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

```
示例 1:

输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]

示例 2:

输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]

```

**限制：**

```
1 <= n <= 11
```

---

### 解题思路

题目需要我们求出所有点数出现的概率，根据概率的计算公式，点数 k 出现概率就算公式为：
$$
P_{(k)} = k \text{出现的次数} / \text{总次数}
$$
投掷 n 个骰子，所有点数出现的总次数是 6^n ，因为一共有 n 枚骰子，每枚骰子的点数都有 6 种可能出现的情况。

我们的目的就是 **计算出投掷完 n 枚骰子后每个点数出现的次数**。

### 使用递归造成的重复计算问题

单纯使用递归搜索解空间的时间复杂度为 6^n，会造成超时错误，因为存在重复子结构。解释如下：

我们使用递归函数 `getCount(n, k)` 来表示投掷 n 枚骰子，点数 k 出现的次数。

为了简化分析，我们以投掷 2 枚骰子为例。

我们来模拟计算点数 4 和 点数 6 ，这两种点数各自出现的次数。也就是计算 `getCount(2, 4)` 和 `getCount(2, 6)`

它们的计算公式为：

```
// 1,3 3,1 2,2 统计一个骰子出现 1 2 3 的次数
getCount(2, 4) = getCount(1, 1) + getCount(1, 2) + getCount(1, 3)

// 1,5 5,1 2,4 4,2 3,3 统计一个骰子出现 1 2 3 4 5 的次数
getCount(2, 6) = getCount(1, 1) + getCount(1, 2) + getCount(1, 3) + getCount(1, 4) + getCount(1, 5) 
```

我们发现递归统计这两种点数的出现次数时，重复计算了 `getCount(1, 1)`, `getCount(1, 2)`, `getCount(1, 3)`

这些子结构，计算其它点数的次数时同样存在大量的重复计算。

当然可以通过 **记忆化dfs** 解决

### 动态规划

**1. 定义状态**

通过题目我们知道一共投掷 n 枚骰子，那最后一个阶段很显然就是：**当投掷完 n 枚骰子后，各个点数出现的次数**。

> 注意，这里的点数指的是前 n 枚骰子的点数和，而不是第 n 枚骰子的点数，下文同理。

- 首先用数组的第一维来表示阶段，也就是投掷完了几枚骰子。
- 然后用第二维来表示投掷完这些骰子后，可能出现的点数。
- 数组的值就表示，该阶段各个点数出现的次数。

所以状态表示就是这样的：`dp[i][j] `，表示投掷完 i 枚骰子后，点数 j 的出现次数。

**2. 状态转移方程**

单单看第 n 枚骰子，它的点数可能为 1, 2, 3, ... , 6 因此投掷完 n 枚骰子后点数 j 出现的次数，可以由投掷完 n-1 枚骰子后，对应点数 j-1, j-2, j-3, ... , j-6 出现的次数之和转化过来。

```cpp
for (第n枚骰子的点数 i = 1; i <= 6; i++) {
    dp[n][j] += dp[n-1][j - i]
}
```

写成数学公式是这样的：
$$
dp[n][j] = \sum^6_{i=1}dp[n-1][j-i]
$$
n 表示阶段，j 表示投掷完 n 枚骰子后的点数和，i 表示第 n 枚骰子会出现的六个点数。

**3. 初始化**

我们可以直接知道的状态是啥，就是第一阶段的状态：投掷完 1 枚骰子后，它的可能点数分别为 1, 2, 3, ... , 6，并且每个点数出现的次数都是 1 .

```cpp
for (int j = 1; j <= 6; j++) {
    dp[1][j] = 1;
}
```

**4. 输出**

输出投掷第 n 次骰子时的各项点数

```cpp
for (int j = n; j <= n * 6; j++) {
    ans.push_back(dp[n][j]);
}
```

```cpp
class Solution {
public:
    vector<double> dicesProbability(int n) {
        int dp[12][67];
        memset(dp, 0, sizeof(dp));
        // 初始化
        for (int j = 1; j <= 6; j++) {
            dp[1][j] = 1;
        }
        // 状态转移
        for (int i = 2; i <= n; i++) {                // 第 i 次掷骰子
            for (int j = i; j <= 6 * i; j++) {        // j 为可能掷出的骰子的点数和
                for (int cur = 1; cur <= 6; cur++) {  // 本次掷出的骰子点数
                    if (j - cur > 0) {
                        dp[i][j] += dp[i - 1][j - cur];
                    }
                }
            }
        }
        int all = pow(6, n);
        vector<double> ans;
        for (int j = n; j <= 6 * n; j++) {
            ans.push_back((double)dp[n][j] / all);
        }
        return ans;
    }
};
```



