[375. 猜数字大小 II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/)

我们正在玩一个猜数游戏，游戏规则如下：

1. 我从 `1` 到 `n` 之间选择一个数字。
2. 你来猜我选了哪个数字。
3. 如果你猜到正确的数字，就会 **赢得游戏** 。
4. 如果你猜错了，那么我会告诉你，我选的数字比你的 **更大或者更小** ，并且你需要继续猜数。
5. 每当你猜了数字 `x` 并且猜错了的时候，你需要支付金额为 `x` 的现金。如果你花光了钱，就会 **输掉游戏** 。

给你一个特定的数字 `n` ，返回能够 **确保你获胜** 的最小现金数，**不管我选择那个数字** 。

**示例 1：**

![img](../../img/graph.png)

```
输入：n = 10
输出：16
解释：制胜策略如下：
- 数字范围是 [1,10] 。你先猜测数字为 7 。
    - 如果这是我选中的数字，你的总费用为 `$0` 。否则，你需要支付 `$7`。
    - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
        - 如果这是我选中的数字，你的总费用为 `$7` 。否则，你需要支付 `$9` 。
        - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
        - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
    - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
        - 如果这是我选中的数字，你的总费用为 `$7` 。否则，你需要支付 `$3` 。
        - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
            - 如果这是我选中的数字，你的总费用为 `$7 + $3 = $10` 。否则，你需要支付 `$5` 。
            - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
            - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
        - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
            - 如果这是我选中的数字，你的总费用为 `$7 + $3 = $10` 。否则，你需要支付 `$1` 。
            - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
在最糟糕的情况下，你需要支付 `$16` 。因此，你只需要 `$16` 就可以确保自己赢得游戏。
```



```
示例 2：

输入：n = 1
输出：0
解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。

示例 3：

输入：n = 2
输出：1
解释：有两个可能的数字 1 和 2 。
- 你可以先猜 1 。
    - 如果这是我选中的数字，你的总费用为 `$0` 。否则，你需要支付 `$1` 。
    - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
最糟糕的情况下，你需要支付 $1 。
```

 

**提示：**

- `1 <= n <= 200`



## 方法一：记忆化搜索

设计递归函数为 `int dfs(int left, int right)` 传入参数 left 和 right 代表在范围 [left, right] 内进行猜数，返回值为在 [left, right] 内猜中数字至少需要多少钱。

我们可决策的部分为「选择猜哪个数 x」，而不可决策的是「选择某个数 x 之后（假设没有猜中），真实值会落在哪边」。

**确保你获胜** 的最小现金数，**不管我选择那个数字**：

- 「确保+不管」，是要选择当前节点下左右分支的「最大值」，才能「确保+不管」那些小的值都能取到，因此分支比较用 max
- 「最小」，是要选择所有可能的结点值下，有一个结果即可，因此用 min

```cpp
class Solution {
public:
    int memo[201][201];
    int dfs(int left, int right) {
        if (left >= right) return 0;  // base case
        if (memo[left][right] != 0) return memo[left][right];

        int res = INT_MAX;
        for (int val = left; val <= right; val++) {
            int sub_left = dfs(left, val - 1);
            int sub_right = dfs(val + 1, right);
            int max_sub = max(sub_left, sub_right) + val;
            res = min(res, max_sub);
        }
        memo[left][right] = res;
        return res;
    }

    int getMoneyAmount(int n) {
        return dfs(1, n);
    }
};
```

## 方法二：区间DP

通过「记忆化搜索」的递归过程，我们发现，在求解 [i, j] 的最小成本时，需要依赖于 [i, k - 1] 和 [k + 1, j] 这样的比 [i, j] 更小的区间。

这引导我们使用「区间 DP」进行求解

**定义状态数组和状态**：`dp[i][j]` 为区间 [i, j] 内进行猜数的最小成本

**状态方程**：结合【确保你获胜的最小现金数】这个条件
$$
f(i,j) = \min\limits_{i<=k<=j}\{max(f(i,k-1),f(k+1,j)+k)\}
$$
最终的 `dp[i][j]` 为所有可选的数值 `k` 中的最小值

时间复杂度：`O(n^3)`

空间复杂度：`O(n^2)`

```cpp
class Solution {
public:
    int getMoneyAmount(int n) {
        // 初始化动态数组
        vector<vector<int>> dp(n + 2, vector<int>(n + 2));

        // 区间dp的常用遍历方法，可确保left<right
        for (int left = n - 1; left >= 1; left--) {
            for (int right = left + 1; right <= n; right++) {
                int tmp = INT_MAX;
                for (int k = left; k <= right; k++) {
                    tmp = min(tmp, max(dp[left][k - 1], dp[k + 1][right]) + k);
                }
                dp[left][right] = tmp;
            }
        }
        return dp[1][n];
    }
};
```

```
问：为什么在循环中 int left = n - 1、int right = left + 1？
答：注意，right不可与left重合，因为重合时left=right=k，dp[k][k]将会等于k，而dp[k][k]根据题意初始时为0，且之后状态不会刷新

问：动态数组的size为n+2？
答：首先+1是因为，我们使用数组的范围是[1,n]，因此申请n+1个位置
再+1是因为，在第三个循环会使 k=right，而且需要使用dp[k+1]，right所使用的范围是[1,n]，那么 k+1=right+1 所使用的范围是[1,n+1]
因此，需要动态数组的size为n+2
```

