题目：[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

输入：nums = [0,1,0,3,2,3]
输出：4

输入：nums = [7,7,7,7,7,7,7]
输出：1
```

> 「子序列」是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。「子串」一定是连续的。
>
> 例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列

### 1、暴力解法

使用「回溯搜索算法」或者「位运算」的技巧，可以得到输入数组的所有子序列，时间复杂度为 O(2^N)。再对这些子串再依次判定是否为「严格上升」，时间复杂度 为O(N)，所以总的时间复杂度为：O(N 2^N)

如果题目问所有解，应该使用回溯算法（暴力搜索）搜索所有具体解。若问最优解的长度，用动态规划

### 2、动态规划

基于「动态规划」的状态设计需要满足「无后效性」的设计思想，可以将状态定义为「以 `nums[i]` 结尾 的「上升子序列」的长度」。

> 「无后效性」的设计思想：让不确定的因素确定下来，以保证求解的过程形成一个逻辑上的有向无环图。这题不确定的因素是某个元素是否被选中，而我们设计状态的时候，让 nums[i] 必需被选中，这一点是「让不确定的因素确定下来」，也是我们这样设计状态的原因。

**1. 定义状态**：

`dp[i]` 表示：**以 `nums[i]` 结尾** 的「上升子序列」的长度。注意：这个定义中 **`nums[i]` 必须被选取，且必须是这个子序列的最后一个元素**；

**2. 状态转移方程**：

如果一个较大的数接在较小的数后面，就会形成一个更长的子序列。只要 nums[i] 严格大于在它位置之前的某个数，那么 nums[i] 就可以接在这个数后面形成一个更长的上升子序列。

$$
dp[i] = max(dp[i],\ dp[j]+1) \qquad j\in[0,i), \ nums[j] <nums[i]
$$
**3. 初始化**：

`dp[i] = 1`，11 个字符显然是长度为 11 的上升子序列。

**4. 输出**：

不能返回最后一个状态值，最后一个状态值只表示以 `nums[len - 1]` 结尾的「上升子序列」的长度，状态数组 `dp` 的最大值才是题目要求的结果。
$$
max(dp[i]) \qquad i\in[0,n-1]
$$
**5. 空间优化**：

遍历到一个新数的时候，之前所有的状态值都得保留，因此无法优化空间。

**复杂度分析**：

时间复杂度：`O(N^2)`

空间复杂度：`O(N)`

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();

        vector<int> dp(n, 1);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```

### 3、二分查找 + 贪心算法

**状态设计思想**：

依然着眼于某个上升子序列的「结尾的元素」，**如果已经得到的上升子序列的「结尾的数越小」，那么遍历的时候后面接上一个数，会有更大的可能构成一个长度更长的上升子序列**。既然结尾越小越好，我们可以记录 在长度固定的情况下，结尾最小的那个元素的数值，这样定义以后容易得到「状态转移方程」

为了与「方法二」的状态定义区分，将状态数组命名为 tail

**1 .定义新状态**：

`tail[i]` 表示：长度为 `i + 1` 的 **所有** 上升子序列的结尾的最小值

说明：

- 数组 tail 不是问题中的「最长上升子序列」（下文还会强调），不能命名为 LIS。数组 tail 只是用于求解 LIS 问题的状态数组；
- tail[0] 表示长度为 1 的所有上升子序列中，结尾最小的元素的数值。以题目中的示例为例 [10, 9, 2, 5, 3, 7, 101, 18] 中，容易发现长度为 2 的所有上升子序列中，结尾最小的是子序列 [2, 3] ，因此 tail[1] = 3；
- 下标和长度有数值为 1 的偏差；

状态定义其实也描述了状态转移方程

**2. 状态转移方程**：

从直觉上看，**数组 `tail` 是一个严格上升数组**。下面是证明

**证明**：即对于任意的下标 `0 <= i < j < len` ，都有 `tail[i] < tail[j]`

使用反证法：假设对于任意的下标 `i` < `j` ，存在某个 `tail[i] >= tail[j]`

对于此处的 tail[i] 而言，对应一个上升子序列 [a_0, a_1, ..., a_i]，依据定义 `tail[i] = a_i`

对于此处的 tail[j] 而言，对应一个上升子序列 [b_0, b_1, ..., b_i, ... , b_j]，依据定义 `tail[j] = b_j`

由于 `tail[i] >= tail[j]`，等价于 `a_i >= b_j`，而在上升子序列 [b_0, b_1, ..., b_i, ... , b_j] 中，`b_i` 严格小于 `b_j` ，故有 `a_i >= b_j > b_i`

则上升子序列 [b_0, b_1, ..., b_i] 是一个长度也为 `i + 1` 但是结尾更小的数组，与 `a_i` 的最小性矛盾

因此原命题成立（证闭）

---

**因此只需要维护状态数组 `tail` 的定义，它的长度就是最长上升子序列的长度**。下面说明在遍历中，如何维护状态数组 `tail` 的定义

1. 在遍历数组 nums 的过程中，看到一个新数 num，如果这个数「严格大于」有序数组 tail 的最后一个元素，就把 num 放在有序数组 tail 的后面，否则进入第 2 点；
2. 在有序数组 `tail` 中查找第 1 个等于大于 `num` 的那个数，试图让它变小；
   - 如果有序数组 `tail` 中存在 **等于** `num` 的元素，什么都不做，因为以 `num` 结尾的最短的「上升子序列」已经存在；
   - 如果有序数组 `tail` 中存在 **大于** `num` 的元素，找到第 1 个，让它变小，这样我们就找到了一个 **结尾更小**的**相同长度**的上升子序列。

说明：

- 我们再看一下数组 tail[i] 的定义：长度为 i + 1 的 **所有** 最长上升子序列的结尾的最小值。因此，在遍历的过程中，我们会不断的刷新 tail 数组，使其整体上变小，最后位置上的数也变小，**以便让新来的数扩充 tail 数组**
- 这一步可以认为是「贪心算法」，总是做出在当前看来最好的选择，当前「最好的选择」是：当前只让让第 1 个严格大于 nums[i] 的数变小，变成 nums[i]，这一步操作是「无后效性」的；
- 由于是在有序数组中的操作，因此可以使用「二分查找算法」。

**3. 初始化**：

遍历第 1 个数 `nums[0]`，直接放在有序数组 `tail` 的开头 `tail[0] = nums[0]`

**4. 输出**：

有序数组 `tail` 的长度，就是所求的「最长上升子序列」的长度

**5. 空间优化**：

无法优化空间

**复杂度分析**：

时间复杂度：`O(Nlog N)`

空间复杂度：`O(N)`

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> tail;
        tail.push_back(nums[0]);
        for (int i = 1; i < nums.size(); i++) {
            int end = *tail.rbegin();
            if (nums[i] > end) {
                tail.push_back(nums[i]);
            } else if (nums[i] == end) {
                continue;
            } else if (nums[i] < end) {
                auto it = lower_bound(tail.begin(), tail.end(), nums[i]);
                *it = nums[i];
            }
        }
        return tail.size();
    }
};
```

