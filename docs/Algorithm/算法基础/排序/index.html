<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Algorithm/算法基础/排序">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">排序算法 | Doongz&#x27;s Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doongz.github.io/docs/Algorithm/算法基础/排序"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="排序算法 | Doongz&#x27;s Site"><meta data-rh="true" name="description" content="参考：https://oi-wiki.org/basic/radix-sort/"><meta data-rh="true" property="og:description" content="参考：https://oi-wiki.org/basic/radix-sort/"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doongz.github.io/docs/Algorithm/算法基础/排序"><link data-rh="true" rel="alternate" href="https://doongz.github.io/docs/Algorithm/算法基础/排序" hreflang="en"><link data-rh="true" rel="alternate" href="https://doongz.github.io/docs/Algorithm/算法基础/排序" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Doongz&#39;s Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Doongz&#39;s Site Atom Feed"><link rel="stylesheet" href="/assets/css/styles.99c6e2a1.css">
<link rel="preload" href="/assets/js/runtime~main.f9aa80d1.js" as="script">
<link rel="preload" href="/assets/js/main.0ded408c.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Home page</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Notes</a><a class="navbar__item navbar__link" href="/community/support">Community</a><a class="navbar__item navbar__link" href="/blog">Blog</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Courses</a><ul class="dropdown__menu"><li><a href="https://github.com/doongz/mlc-ai" target="_blank" rel="noopener noreferrer" class="dropdown__link">Machine Learning Compilation<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/cs229" target="_blank" rel="noopener noreferrer" class="dropdown__link">Stanford CS229: Machine Learning<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/aics" target="_blank" rel="noopener noreferrer" class="dropdown__link">中国科学院 智能计算系统<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/cs50-ai" target="_blank" rel="noopener noreferrer" class="dropdown__link">Harvard CS50’s Introduction to AI with Python<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/mit-6.824" target="_blank" rel="noopener noreferrer" class="dropdown__link">MIT-6.824 Distributed Systems<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/os-workbench" target="_blank" rel="noopener noreferrer" class="dropdown__link">南京大学 操作系统：设计与实现<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/mit-6.s081" target="_blank" rel="noopener noreferrer" class="dropdown__link">MIT-6.S081 Operating Systems Engineering<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://github.com/doongz" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/Algorithm/前述/面试时做题技巧">Algorithm</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/前述/面试时做题技巧">前述</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/数据结构/基本概念">数据结构</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/Algorithm/算法基础/排序">算法基础</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Algorithm/算法基础/排序">排序算法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/算法基础/专题-二分答案">专题 二分答案</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/算法基础/二分法">二分法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/算法基础/双指针">双指针</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/算法基础/滑动窗口">滑动窗口</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/算法基础/前缀和">前缀和</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/算法基础/差分">差分</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/算法基础/贪心">贪心</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/算法基础/位运算">位运算</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/算法基础/分治">分治</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/算法基础/确定有限状态机">确定有限状态机</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-二分法/&lt;旋转数组问题&gt;-搜索旋转排序数组">例题-二分法</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-二分答案/爱吃香蕉的珂珂-最大值最小化问题">例题-二分答案</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-位运算/&lt;异或-位数统计&gt;-只出现一次的数字">例题-位运算</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-分治/&lt;模版题&gt;-为运算表达式设计优先级">例题-分治</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-前缀和/&lt;前后缀积&gt;-除自身以外数组的乘积">例题-前缀和</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-双指针/&lt;左右双指针+贪心&gt;-盛最多水的容器">例题-双指针</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-差分/&lt;差分数组&gt;-K 连续位的最小翻转次数">例题-差分</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-思维题/&lt;间隔跳跃&gt;-青蛙过河II">例题-思维题</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-排序/&lt;自定义排序三种写法&gt;-合并区间">例题-排序</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-模拟/Z字形变换">例题-模拟</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-滑动窗口/&lt;模版题&gt;-无重复字符的最长子串">例题-滑动窗口</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-确定有限状态机/&lt;DFA&gt;-字符串转换整数atoi">例题-确定有限状态机</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/例题-贪心/&lt;贪心&gt;-最长公共前缀">例题-贪心</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/基础">动态规划</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/图论/理论基础">图论</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/数学/数学运算/num和arr互转">数学</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/系列题目/括号问题/">系列题目</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Competition/比赛">Competition</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Course/CMU-15-213">Course</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Knowledge/IC/IC">Knowledge</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Math/微积分/极限">Math</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Skill/ASM/RISC-V/汇编语言格式及ABI">Skill</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Algorithm</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">算法基础</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">排序算法</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>排序算法</h1><p>参考：<a href="https://oi-wiki.org/basic/radix-sort/" target="_blank" rel="noopener noreferrer">https://oi-wiki.org/basic/radix-sort/</a></p><table><thead><tr><th>算法</th><th>稳定性</th><th>平均时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>选择排序</td><td>不稳定</td><td>O(n^2)</td><td>O(1)</td></tr><tr><td>冒泡排序</td><td>稳定</td><td>O(n^2)</td><td>O(1)</td></tr><tr><td>插入排序</td><td>稳定</td><td>O(n^2)</td><td>O(1)</td></tr><tr><td>计数排序</td><td>稳定</td><td>O(n)</td><td>O(n)</td></tr><tr><td>桶排序（重要）</td><td>取决桶内排序算法</td><td>O(n)</td><td>O(n)</td></tr><tr><td>快速排序（重要）</td><td>不稳定</td><td>O(nlogn)</td><td>O(logn)</td></tr><tr><td>归并排序（重要）</td><td>稳定</td><td>O(nlogn)</td><td>O(n)</td></tr><tr><td>基数排序</td><td>稳定</td><td>O(n)</td><td>O(n)</td></tr><tr><td>希尔排序</td><td>不稳定</td><td>O(n^(3/2))</td><td>O(n)</td></tr><tr><td>堆排序</td><td>不稳定</td><td>O(nlogn)</td><td>O(1)</td></tr><tr><td>锦标赛排序</td><td>不稳定</td><td>O(nlogn)</td><td>O(n)</td></tr></tbody></table><p><a href="https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html" target="_blank" rel="noopener noreferrer">稳定性</a>：保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前</p><p>需要注意的是，算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。如果待排序表中的关键字不允许重复，则排序结果是唯一的，那么选择排序算法时的稳定与否就无关紧要。</p><p>在排序过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：</p><ul><li>内部排序，是指在排序期间元素全部存放在内存中的排序</li><li>外部排序，是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。</li></ul><p>一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。当然，并非所有的内部排序算法都要基于比较操作，事实上，基数排序就不基于比较。</p><p><img loading="lazy" alt="8-1" src="/assets/images/8-1-a2823630ce08471965c9e17ef0f2817a.png" width="2322" height="1502" class="img_ev3q"></p><p><img loading="lazy" alt="8-2" src="/assets/images/8-2-9c0b8337b533beb1bfec6516740ffa55.png" width="2346" height="1288" class="img_ev3q"></p><p><img loading="lazy" alt="8-3" src="/assets/images/8-3-a841f4392345eade968edd7350ea14a6.png" width="2342" height="836" class="img_ev3q"></p><p><img loading="lazy" alt="8-4" src="/assets/images/8-4-29686405f964635f0f7f94f6321413ba.png" width="2384" height="1428" class="img_ev3q"></p><p><img loading="lazy" alt="8-5" src="/assets/images/8-5-42af17ecc4c65436db765bdd4d4072ea.png" width="2342" height="968" class="img_ev3q"></p><p><img loading="lazy" alt="8-6" src="/assets/images/8-6-1999918dd2453d3a3396b81097854d1a.png" width="2334" height="1260" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="应用">应用<a class="hash-link" href="#应用" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1排序常与贪心二分法等策略结合">1、排序常与「贪心」「二分法」等策略结合<a class="hash-link" href="#1排序常与贪心二分法等策略结合" title="Direct link to heading">​</a></h3><p>先排序进行数据预处理，再进行算法计算</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2对数组排序的最小次数">2、对数组排序的最小次数<a class="hash-link" href="#2对数组排序的最小次数" title="Direct link to heading">​</a></h3><p>数组变成有序的最小交换次数</p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;algorithm&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;iostream&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;vector&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using namespace std;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int getMinSwaps(vector&lt;int&gt;&amp; arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int n = arr.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;pair&lt;int, int&gt;&gt; vec(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; n; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vec[i].first = arr[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vec[i].second = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(vec.begin(), vec.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int cnt = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; n; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (vec[i].second == i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        swap(vec[i].first, vec[vec[i].second].first);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        swap(vec[i].second, vec[vec[i].second].second);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (i != vec[i].second) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            --i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ++cnt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return cnt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;int&gt; arr = {3, 1, 2, 4};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int r = getMinSwaps(arr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cout &lt;&lt; &quot;min swap cnt:&quot; &lt;&lt; r &lt;&lt; endl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // min swap cnt:2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="一内部排序">一、内部排序<a class="hash-link" href="#一内部排序" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1选择排序">1、选择排序<a class="hash-link" href="#1选择排序" title="Direct link to heading">​</a></h3><p>基本思想：第一次遍历n-1个数，找到最小的数值与第一个元素交换</p><p>第二次遍历n-2个数，找到最小的数值与第二个元素交换…………</p><p><strong>稳定性</strong>：由于 swap（交换两个元素）操作的存在，选择排序是一种不稳定的排序算法</p><p><strong>时间复杂度</strong>：选择排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为 <code>O(n^2)</code> </p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;int&gt; selection_sort(vector&lt;int&gt;&amp; nums){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; nums.size() - 1; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int minIndex = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = i + 1; j &lt; nums.size(); j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (nums[j] &lt; nums[i]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                minIndex = j;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        swap(nums[i], nums[minIndex]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return nums;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2冒泡排序">2、冒泡排序：<a class="hash-link" href="#2冒泡排序" title="Direct link to heading">​</a></h3><p>基本思想：两个数比较大小，较大的数下沉，较小的数冒起来。</p><p>冒泡排序是一种稳定的排序算法</p><p><strong>时间复杂度</strong>：</p><ul><li>最优情况 <code>O(n)</code>，在序列完全有序时，冒泡排序只需遍历一遍数组，不用执行任何交换操作</li><li>最坏情况 <code>O(n^2)</code>，冒泡排序要执行 <code>(n-1)n/2</code> 次交换操作</li><li>平均时间复杂度 <code>O(n^2)</code></li></ul><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">def</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">bubble_sort</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">nums</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> i </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> </span><span class="token builtin">range</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token builtin">len</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">nums</span><span class="token punctuation" style="color:#393A34">)</span><span class="token operator" style="color:#393A34">-</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> j </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> </span><span class="token builtin">range</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">i</span><span class="token operator" style="color:#393A34">+</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token builtin">len</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">nums</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">j</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">j</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">j</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> nums</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-C++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;iostream&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;vector&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using namespace std;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;int&gt; nums{1, 2, 5, 3, 7, 4, 5, 8};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; nums.size() - 1; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = i + 1; j &lt; nums.size(); j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (nums[i] &gt; nums[j]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                swap(nums[i], nums[j]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; nums.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  // 1 2 3 4 5 5 7 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3插入排序">3、插入排序<a class="hash-link" href="#3插入排序" title="Direct link to heading">​</a></h3><p>将待排列元素划分为“已排序”和“未排序”两部分，每次从“未排序的”元素中选择一个插入到“已排序的”元素中的正确位置</p><p>插入排序是一种稳定的排序算法</p><p><strong>时间复杂度</strong>：</p><ul><li>最优时间复杂度为 <code>O(n)</code></li><li>平均和最坏时间复杂度 <code>O(n^2)</code></li></ul><p><strong>算法实现</strong>：</p><ul><li>数组前面有序（出始0有序，从1往后），不断遍历后面，往前面插入</li><li>往前面插入时，从前面有序的最后一个（i-1）开始「从后往前比较」</li></ul><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;iostream&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;vector&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using namespace std;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;int&gt; nums{1, 2, 5, 3, 7, 4, 5, 8};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt; nums.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int val = nums[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int j = i - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (j &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (val &lt; nums[j]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nums[j + 1] = nums[j];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nums[j] = val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            j--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; nums.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  // 1 2 3 4 5 5 7 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4计数排序">4、计数排序<a class="hash-link" href="#4计数排序" title="Direct link to heading">​</a></h3><p><a href="https://www.cnblogs.com/xiaochuan94/p/11198610.html" target="_blank" rel="noopener noreferrer">参考</a></p><p>计数排序（英语：Counting sort）是一种线性时间的排序算法该算法于1954年由 Harold H. Seward提出，通过计数将时间复杂度降到了<code>O(N)</code></p><p>算法步骤：</p><ol><li>找出原数组中元素值最大的，记为<code>max</code>。</li><li>创建一个新数组<code>count</code>，其长度是<code>max</code>加1，其元素默认值都为0。</li><li>遍历原数组中的元素，以原数组中的「元素值」作为<code>count</code>数组的「索引」，以原数组中的元素「出现次数」作为<code>count</code>数组的「元素值」</li><li>创建结果数组<code>result</code>，起始索引<code>index</code>。</li><li>遍历<code>count</code>数组，找出其中元素值大于0的元素，将其对应的索引作为元素值填充到<code>result</code>数组中去，每处理一次，<code>count</code>中的该元素值减1，直到该元素值不大于0，依次处理<code>count</code>中剩下的元素。</li><li>返回结果数组<code>result</code>。</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">原数组  nums: [2 4 3 1 2 5 9]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">计数数组 cnt: [0 1 2 1 1 1 0 0 0 1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">排序完  nums: [1 2 2 3 4 5 9]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;iostream&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;vector&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using namespace std;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;int&gt; nums = {2, 4, 3, 1, 2, 5, 9};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxVal = INT_MIN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        maxVal = max(maxVal, num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;int&gt; cnt(maxVal + 1, 0); // 数组长度为最大值+1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cnt[num]++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int index = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; cnt.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (cnt[i] &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            nums[index] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            index++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cnt[i]--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1 2 2 3 4 5 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它有一个缺陷，那就是存在空间浪费的问题。比如一组数据<code>{101,109,108,102,110,107,103}</code>，其中最大值为110，需要创建一个长度为111的计数数组，前面的<code>[0,100]</code>的空间浪费了</p><p>优化：将数组长度定为<code>max-min+1</code>，即不仅要找出最大值，还要找出最小值，<strong>根据两者的差来确定计数数组的长度，元素要减去最小值再作为新索引，最后取结果时将减去的最小值补上</strong></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;iostream&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;vector&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using namespace std;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;int&gt; nums = {101, 109, 108, 102, 110, 107, 109};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxVal = INT_MIN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int minVal = INT_MAX;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        maxVal = max(maxVal, num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        minVal = min(minVal, num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;int&gt; cnt(maxVal - minVal + 1, 0);  // 长度为最大值减最小值加1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cnt[num - minVal]++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int index = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; cnt.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (cnt[i] &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            nums[index] = i + minVal;  // 取结果时将减去的最小值补上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            index++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cnt[i]--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 101 102 107 108 109 109 110</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5桶排序重要">5、桶排序（重要）<a class="hash-link" href="#5桶排序重要" title="Direct link to heading">​</a></h3><p><a href="https://blog.csdn.net/qq_27124771/article/details/87651495" target="_blank" rel="noopener noreferrer">参考1</a>，<a href="https://oi-wiki.org/basic/bucket-sort/" target="_blank" rel="noopener noreferrer">参考2</a></p><p>桶排序（英文：Bucket sort）是排序算法的一种，适用于待排序数据值域较大但分布比较均匀的情况，否则当所有数据集中在同一个桶中时，桶排序失效</p><p>「桶排序」是「计数排序」的扩展版本，计数排序可以看成每个桶只存储相同元素，而桶排序每个桶存储一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中</p><p>一句话总结：<strong>划分多个范围相同的区间，每个子区间自排序，最后合并</strong></p><p><img loading="lazy" src="/assets/images/桶排序-23499b6fc43d1b57c7dd0d5c8695fe9a.png" width="891" height="816" class="img_ev3q"></p><p><strong>每个桶的长度</strong>：我们期望将数组中的各个数等距离分配，也就是每个桶的长度相同，也就是对于所有桶来说，桶内最大值减去桶内最小值都是一样的。
$$
每个桶的长度 = max(1, \frac{max(nums)-min(nums)}{len(nums)-1})
$$
<strong>桶的数量</strong>：最后的加一保证了数组的最大值也能分到一个桶。
$$
桶的数量 = \frac{max(nums) - min(nums)}{每个桶的长度} + 1
$$
<strong>每个数对应桶的位置</strong>
$$
idx = \frac{nums<!-- -->[i]<!-- --> - min(nums)}{每个桶的长度}
$$</p><p><strong>算法步骤</strong></p><ol><li>计算最大值与最小值</li><li>计算桶的数量</li><li>将每个元素放入桶</li><li>对每个桶进行排序</li><li>将桶中的元素赋值到原序列</li></ol><p><strong>稳定性</strong></p><p>如果使用稳定的内层排序，并且将元素插入桶中时不改变元素间的相对顺序，那么桶排序就是一种稳定的排序算法。</p><p>由于每块元素不多，一般使用插入排序。此时桶排序是一种稳定的排序算法。</p><p><strong>时间复杂度</strong></p><p>桶排序的平均时间复杂度为 <code>O((n+n^2)/(k+k))</code> （将值域平均分成 n 块 + 排序 + 重新合并元素），当 k约等于n 时为 <code>O(n)</code></p><p>桶排序的最坏时间复杂度为<code>O(n^2)</code> </p><p><strong>应用</strong></p><p>桶间隙，可以 <code>O(n)</code>的时间复杂度，找到一个无序数组中元素间的<a href="https://leetcode-cn.com/problems/maximum-gap/" target="_blank" rel="noopener noreferrer">最大间距</a></p><p>元素之间的最大间距一定不会出现在某个桶的内部，而一定会出现在不同桶当中</p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;algorithm&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;iostream&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;vector&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using namespace std;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;int&gt; nums = {101, 109, 108, 102, 110, 107, 109};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int n = nums.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1 计算最大值与最小值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxVal = *max_element(nums.begin(), nums.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int minVal = *min_element(nums.begin(), nums.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2 计算桶的数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int bucketSize = max(1, (maxVal - minVal) / (n - 1));  // 1 = max(1, (110-101)/(7-1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int bucketNum = (maxVal - minVal) / bucketSize + 1;    // 10 = (110-101) / 1 + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; buckets(bucketNum, vector&lt;int&gt;{});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 3 将每个元素放入桶</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int location = (num - minVal) / bucketSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        buckets[location].push_back(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 4 对每个桶进行排序，注意是引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (auto &amp;b : buckets) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sort(b.begin(), b.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 5 将桶中的元素赋值到原序列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int index = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (auto bucket : buckets) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int num : bucket) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            nums[index] = num;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            index++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 101 102 107 108 109 109 110</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6快速排序重要">6、快速排序（重要）<a class="hash-link" href="#6快速排序重要" title="Direct link to heading">​</a></h3><p>参考一：<a href="https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ" target="_blank" rel="noopener noreferrer">快速排序的正确理解方式及运用</a></p><p>快速排序（英语：Quicksort），又称分区交换排序（英语：partition-exchange sort），简称快排，是一种被广泛运用的排序算法。</p><p>工作原理是通过「分治」的方式来将一个数组排序</p><ul><li><p>将数列划分为两部分（要求保证相对大小关系）；</p></li><li><p>递归到两个子序列中分别进行快速排序；</p><ul><li>从数列中取出一个数作为key值</li><li>将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边</li><li>递归重复</li></ul></li></ul><p>快速排序是一种不稳定的排序算法</p><p>快速排序的最优时间复杂度和平均时间复杂度为 <code>O(nlogn)</code>，最坏时间复杂度为 <code>O(n^2)</code></p><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">def</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">quick_sort</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">nums</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> left</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> right</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> left </span><span class="token operator" style="color:#393A34">&gt;=</span><span class="token plain"> right</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># 退出递归</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    low </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> left                  </span><span class="token comment" style="color:#999988;font-style:italic"># 提前记录递归的左边界</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    high </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> right                </span><span class="token comment" style="color:#999988;font-style:italic"># 提前记录递归的右边届</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    key </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">low</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">         </span><span class="token comment" style="color:#999988;font-style:italic"># 初始化key值，比key大的放右边，比key小的放左边</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">while</span><span class="token plain"> left </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> right</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># 筛选出本次key值，左边都小，右边都大的数组，跳出时left=right(不懂为啥)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">while</span><span class="token plain"> left </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> right </span><span class="token keyword" style="color:#00009f">and</span><span class="token plain"> nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">right</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> key</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># 找到右边比key值小的停下来,因为left位置的值传给key后没用了，先判断右边放到没用的left位置上</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            right </span><span class="token operator" style="color:#393A34">-=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">left</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">right</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># 把右边错位的值放在array[left]上，看上面left-&gt;low-&gt;key，所以left这个位置的值已经传给key了，array[left]没用了</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">while</span><span class="token plain"> left </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> right </span><span class="token keyword" style="color:#00009f">and</span><span class="token plain"> nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">left</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;=</span><span class="token plain"> key</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># 找到左边比key值大的停下来</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            left </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">right</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">left</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># 把左边错位的值放在array[right]上，因为right这个位置上的值已经放到左边了，所以array[right]没用了</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nums</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">right</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> key   </span><span class="token comment" style="color:#999988;font-style:italic"># 此时left=right，所以传到right或left位置都可以</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    quick_sort</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">nums</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> low</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> left </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">     </span><span class="token comment" style="color:#999988;font-style:italic"># left或right都可以</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    quick_sort</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">nums</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> left </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> high</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic"># left或right都可以</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nums </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">5</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">9</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">6</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">3</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">7</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">10</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">4</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">8</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">13</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">54</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">76</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">33</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">quick_sort</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">nums</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">,</span><span class="token builtin">len</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">nums</span><span class="token punctuation" style="color:#393A34">)</span><span class="token operator" style="color:#393A34">-</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">print</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">nums</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void quick_sort(vector&lt;int&gt;&amp; nums, int left, int right){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(left &gt;= right){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int low = left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int high = right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int key = nums[low];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (left &lt; right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (left &lt; right &amp;&amp; nums[right] &gt; key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            right--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nums[left] = nums[right];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (left &lt; right &amp;&amp; nums[left] &lt;= key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            left++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nums[right] = nums[left];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nums[right] = key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    quick_sort(nums, low, left-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    quick_sort(nums, left+1, high);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>那我就借楼补一个msvc对cpp的sort的实现，大体上就是双轴快排,如果递归过深会转为堆排，如果元素数量小于_ISORT_MAX=32个转插排。注意进入堆排序的判断if (_ISORT_MAX &lt; _Count)要结合前面while里的判断 while (_ISORT_MAX &lt; (_Count = _Last - _First) &amp;&amp; 0 &lt; _Ideal)来看。</p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//调用形式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">_Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //定义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    template &lt;class _RanIt,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              class _Pr&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inline void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t&lt;_RanIt&gt; _Ideal, _Pr _Pred) {  // order [_First, _Last), using _Pred</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    _Iter_diff_t&lt;_RanIt&gt; _Count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (_ISORT_MAX &lt; (_Count = _Last - _First) &amp;&amp; 0 &lt; _Ideal) {  // divide and conquer by quicksort</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // TRANSITION, VSO#433486</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _Ideal = (_Ideal &gt;&gt; 1) + (_Ideal &gt;&gt; 2);  // allow 1.5 log2(N) divisions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (_Mid.first - _First &lt; _Last - _Mid.second) {  // loop on second half</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _First = _Mid.second;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {  // loop on first half</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _Last = _Mid.first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (_ISORT_MAX &lt; _Count) {  // heap sort if too many divisions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _Make_heap_unchecked(_First, _Last, _Pred);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _Sort_heap_unchecked(_First, _Last, _Pred);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (2 &lt;= _Count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _Insertion_sort_unchecked(_First, _Last, _Pred);  // small</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="7归并排序重要">7、归并排序（重要）<a class="hash-link" href="#7归并排序重要" title="Direct link to heading">​</a></h3><p>参考1：<a href="https://mp.weixin.qq.com/s/7_jsikVCARPFrJ6Hj1EYsg" target="_blank" rel="noopener noreferrer">归并排序的正确理解方式及运用</a></p><p>参考2：<a href="https://oi-wiki.org/basic/merge-sort/" target="_blank" rel="noopener noreferrer">归并排序</a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1性质">1）性质<a class="hash-link" href="#1性质" title="Direct link to heading">​</a></h4><p>归并排序是一种稳定的排序算法</p><p>归并排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为 O(nlogn)</p><p>空间复杂度为 O(n)</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2算法思路">2）算法思路<a class="hash-link" href="#2算法思路" title="Direct link to heading">​</a></h4><p>所有「递归」的算法，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码</p><p>要写递归算法，本质上就是要告诉每个节点需要做什么</p><p><strong>归并排序分为三个步骤</strong></p><ul><li>将数列划分为两部分；</li><li>递归地分别对两个子序列进行归并排序</li><li>合并两个子序列</li></ul><blockquote><p>不难发现，归并排序的前两步都很好实现，关键是「如何合并两个子序列」</p><p>注意到两个子序列在第二步中已经保证了都是有序的了，第三步中实际上是想要把两个 <strong>有序</strong> 的序列合并起来</p></blockquote><p><strong>归并排序的代码框架</strong></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 定义：排序 nums[lo..hi]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void sort(int[] nums, int lo, int hi) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (lo == hi) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int mid = (lo + hi) / 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums, lo, mid); // 利用定义，排序 nums[lo..mid]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums, mid + 1, hi); // 利用定义，排序 nums[mid+1..hi]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /****** 后序位置 ******/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 此时两部分子数组已经被排好序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 合并两个有序数组，使 nums[lo..hi] 有序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    merge(nums, lo, mid, hi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*********************/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 将有序数组 nums[lo..mid] 和有序数组 nums[mid+1..hi]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 合并为有序数组 nums[lo..hi]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void merge(int[] nums, int lo, int mid, int hi);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述框架印证了并归排序的经典的总结：归并排序就是先把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并</p><p>观察下二叉树的后序遍历和求二叉树的最大深度的代码，会发现并归排序的框架就是后序遍历的框架</p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* 二叉树后序遍历*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void traverse(TreeNode root) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    traverse(root.left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    traverse(root.right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /****** 后序位置 ******/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print(root.val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*********************/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 定义：输入根节点，返回这棵二叉树的最大深度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int maxDepth(TreeNode root) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 利用定义，计算左右子树的最大深度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int leftMax = maxDepth(root.left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int rightMax = maxDepth(root.right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 整棵树的最大深度等于左右子树的最大深度取最大值，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 然后再加上根节点自己</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int res = Math.max(leftMax, rightMax) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>归并排序的过程可以在逻辑上抽象成一棵「二叉树」，树上的每个节点的值可以认为是 <code>nums[lo..hi]</code>，叶子节点的值就是数组中的单个元素</p><p><img loading="lazy" src="/assets/images/并归-1-942059825f84d61827924e50692f017f.png" width="1080" height="608" class="img_ev3q"></p><p>然后，在每个节点的后序位置（左右子节点已经被排好序）的时候执行<code>merge</code>函数，合并两个子节点上的子数组</p><p><img loading="lazy" src="/assets/images/并归-2-64acbf21434438a8d5bd62bc05b11ca5.png" width="1080" height="608" class="img_ev3q"></p><p>这个<code>merge</code>操作会在二叉树的每个节点上都执行一遍，执行顺序是二叉树后序遍历的顺序</p><p>我们把<code>nums[lo..hi]</code>理解成二叉树的节点，<code>srot</code>函数理解成二叉树的遍历函数，整个归并排序的执行过程就是以下 GIF 描述的这样：</p><p><img loading="lazy" src="/assets/images/并归-3-30894e0927b4aabe44c3fd4b09bc1cb4.gif" width="1079" height="607" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="4代码实现">4）代码实现<a class="hash-link" href="#4代码实现" title="Direct link to heading">​</a></h4><p>《算法 4》中给出的归并排序代码兼具了简洁和高效的特点，以此作为归并算法模板</p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;iostream&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;vector&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using namespace std;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class MergeSort {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;int&gt; tmp;  // 用于辅助合并有序数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void _sort(vector&lt;int&gt; &amp;nums, int lo, int hi) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (lo == hi) return;  // 单个元素不用排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int mid = lo + (hi - lo) / 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _sort(nums, lo, mid);      // 先对左半部分数组 [lo,mid] 排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _sort(nums, mid + 1, hi);  // 再对右半部分数组 [mid+1,hi] 排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        merge(nums, lo, mid, hi);  // 将两部分有序数组合并成一个有序数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void merge(vector&lt;int&gt; &amp;nums, int lo, int mid, int hi) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 先把 [lo, hi] 复制到辅助数组中，以便合并后的结果能够直接存入 nums</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = lo; i &lt;= hi; i++) tmp[i] = nums[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 双指针，分别指向左右两个有序数组，合并</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int ptr_l = lo, ptr_r = mid + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int idx = lo; idx &lt;= hi; idx++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ptr_l == mid + 1) {  // 左半边数组已全部被合并</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nums[idx] = tmp[ptr_r++];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (ptr_r == hi + 1) {  // 右半边数组已全部被合并</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nums[idx] = tmp[ptr_l++];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (tmp[ptr_l] &lt; tmp[ptr_r]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nums[idx] = tmp[ptr_l];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ptr_l++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (tmp[ptr_l] == tmp[ptr_r]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nums[idx] = tmp[ptr_l];  // 注意：两个指针相等时，在单纯排序时，哪个指针移动无所谓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ptr_l++;                 // 但是在求逆序对时，一定是左指针移动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (tmp[ptr_l] &gt; tmp[ptr_r]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // reverse_pairs += mid - ptr_l + 1; // 逆序对进行累加</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nums[idx] = tmp[ptr_r];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ptr_r++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void sort(vector&lt;int&gt; &amp;nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tmp.resize(n);          // 先给辅助数组开辟内存空间，不要放在递归里面</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _sort(nums, 0, n - 1);  // 排序整个数组（原地修改）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;int&gt; nums = {5, 4, 7, 6, 3, 2, 1};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MergeSort m;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m.sort(nums);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int a : nums) cout &lt;&lt; a &lt;&lt; &quot; &quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cout &lt;&lt; endl;  // 1 2 3 4 5 6 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>归并排序的时间复杂度：集中在<code>merge</code>函数中把 <!-- -->[lo, hi]<!-- --> 复制到辅助数组中这一步，但每次<code>merge</code>输入的<code>lo</code>和<code>hi</code>都不同，所以不容易直观地看出时间复杂度。</p><p>观察二叉树每一层的结点，在同一层的许多 merge 函数合计的次数为 n 次</p><p>同时，二叉树的高度为 logn</p><p>因此时间复杂度为 <code>O(nlogn)</code></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="5应用例题">5）应用（例题）<a class="hash-link" href="#5应用例题" title="Direct link to heading">​</a></h4><p>并归排序经典的应用是：排序链表和计算逆序对</p><p><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener noreferrer">148. 排序链表</a></p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 51. 数组中的逆序对</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="二外部排序">二、外部排序<a class="hash-link" href="#二外部排序" title="Direct link to heading">​</a></h2></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Algorithm/数据结构/设计数据结构/面试题-03-04-化栈为队"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">面试题-03-04-化栈为队</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Algorithm/算法基础/专题-二分答案"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">专题 二分答案</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#应用" class="table-of-contents__link toc-highlight">应用</a><ul><li><a href="#1排序常与贪心二分法等策略结合" class="table-of-contents__link toc-highlight">1、排序常与「贪心」「二分法」等策略结合</a></li><li><a href="#2对数组排序的最小次数" class="table-of-contents__link toc-highlight">2、对数组排序的最小次数</a></li></ul></li><li><a href="#一内部排序" class="table-of-contents__link toc-highlight">一、内部排序</a><ul><li><a href="#1选择排序" class="table-of-contents__link toc-highlight">1、选择排序</a></li><li><a href="#2冒泡排序" class="table-of-contents__link toc-highlight">2、冒泡排序：</a></li><li><a href="#3插入排序" class="table-of-contents__link toc-highlight">3、插入排序</a></li><li><a href="#4计数排序" class="table-of-contents__link toc-highlight">4、计数排序</a></li><li><a href="#5桶排序重要" class="table-of-contents__link toc-highlight">5、桶排序（重要）</a></li><li><a href="#6快速排序重要" class="table-of-contents__link toc-highlight">6、快速排序（重要）</a></li><li><a href="#7归并排序重要" class="table-of-contents__link toc-highlight">7、归并排序（重要）</a></li></ul></li><li><a href="#二外部排序" class="table-of-contents__link toc-highlight">二、外部排序</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Doongz Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.f9aa80d1.js"></script>
<script src="/assets/js/main.0ded408c.js"></script>
</body>
</html>