题目：[802. 找到最终的安全状态](https://leetcode.cn/problems/find-eventual-safe-states/)

有一个有 `n` 个节点的有向图，节点按 `0` 到 `n - 1` 编号。图由一个 **索引从 0 开始** 的 2D 整数数组 `graph`表示， `graph[i]`是与节点 `i` 相邻的节点的整数数组，这意味着从节点 `i` 到 `graph[i]`中的每个节点都有一条边。

如果一个节点没有连出的有向边，则它是 **终端节点** 。如果没有出边，则节点为终端节点。如果从该节点开始的所有可能路径都通向 **终端节点** ，则该节点为 **安全节点** 。

返回一个由图中所有 **安全节点** 组成的数组作为答案。答案数组中的元素应当按 **升序** 排列。

**示例 1：**

![Illustration of graph](../../img/picture1.png)

```
输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]
输出：[2,4,5,6]
解释：示意图如上。
节点 5 和节点 6 是终端节点，因为它们都没有出边。
从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6 。
```

**示例 2：**

```
输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
输出：[4]
解释:
只有节点 4 是终端节点，从节点 4 开始的所有路径都通向节点 4 。
```

提示：

n == graph.length
1 <= n <= 104
0 <= graph[i].length <= n
`0 <= graph[i][j] <= n - 1`
graph[i] 按严格递增顺序排列。
图中可能包含自环。
图中边的数目在范围 [1, 4 * 104] 内。

---

根据题目对「安全节点」的定义，我们知道如果一个节点无法进入「环」的话则是安全的，否则是不安全的。

另外我们发现，**如果想要判断某个节点数 x 是否安全，起始时将 x 进行入队，并跑一遍拓扑排序是不足够的。**

因为我们无法事先确保 x 满足入度为 的要求，所以当我们处理到与 x 相连的节点 y 时，可能会存在 y 节点入度无法减到 0 的情况，即我们无法输出真实拓扑序中，从 x 节点开始到结尾的完整部分。

其实，**我们应该找的是 出度为0 或 进行拓扑后出度可以变为0 的点**

但是根据我们「证明」部分的启发，我们可以将所有边进行反向，这时候「入度」和「出度」翻转了。

对于那些反向图中「入度」为 0 的点集 ，其实就是原图中「出度」为 0 的节点，它们「出度」为 0，根本没指向任何节点，必然无法进入环，是安全的；同时由它们在反向图中指向的节点（在原图中**「只指向」**它们的节点），必然也是无法进入环的，对应到反向图中，就是那些减去 x 对应的入度之后，入度为 0 的节点。

因此整个过程就是将图进行反向，再跑一遍拓扑排序，如果某个节点出现在拓扑序列，说明其进入过队列，说明其入度为 0，其是安全的，其余节点则是在环内非安全节点。

```cpp
class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<vector<int>> adj(n);
        vector<int> indegrees(n, 0);

        // 建反图的 邻接表和入度表，下面 s,e 为原图的起点和终点
        for (int s = 0; s < n; s++) {
            for (int e : graph[s]) {
                adj[e].push_back(s);
                indegrees[s]++;
            }
        }

        // 入度为0的起点
        queue<int> que;
        for (int i = 0; i < n; i++) {
            if (indegrees[i] == 0) que.push(i);
        }
        while (!que.empty()) {
            int cur = que.front();
            que.pop();
            for (int next : adj[cur]) {
                indegrees[next]--;
                if (indegrees[next] == 0) {
                    que.push(next);
                }
            }
        }

        // 找反图中入度为 0 的点
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            if (indegrees[i] == 0) ans.push_back(i);
        }
        return ans;
    }
};

```

