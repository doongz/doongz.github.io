题目：[909. 蛇梯棋](https://leetcode.cn/problems/snakes-and-ladders/)

给你一个大小为 `n x n` 的整数矩阵 `board` ，方格按从 `1` 到 `n2` 编号，编号遵循 [转行交替方式](https://baike.baidu.com/item/牛耕式转行书写法/17195786) ，**从左下角开始** 即，从 `board[n - 1][0]` 开始）每一行交替方向。

玩家从棋盘上的方格 `1` （总是在最后一行、第一列）开始出发。

每一回合，玩家需要从当前方格 `curr` 开始出发，按下述要求前进：

- 选定目标方格 `next` ，目标方格的编号符合范围 `[curr + 1, min(curr + 6, n2)]` 。
  - 该选择模拟了掷 **六面体骰子** 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。
- 传送玩家：如果目标方格 `next` 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 `next` 。 
- 当玩家到达编号 `n2` 的方格时，游戏结束。

`r` 行 `c` 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 `board[r][c] != -1`，那个蛇或梯子的目的地将会是 `board[r][c]`。编号为 `1` 和 `n2` 的方格上没有蛇或梯子。

注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 **不能** 继续移动。

- 举个例子，假设棋盘是 `[[-1,4],[-1,3]]` ，第一次移动，玩家的目标方格是 `2` 。那么这个玩家将会顺着梯子到达方格 `3` ，但 **不能** 顺着方格 `3` 上的梯子前往方格 `4` 。

返回达到编号为 `n2` 的方格所需的最少移动次数，如果不可能，则返回 `-1`。

**示例 1：**

![img](../../img/snakes.png)

```
输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
输出：4
解释：
首先，从方格 1 [第 5 行，第 0 列] 开始。 
先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。
然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。
接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 
最后决定移动到方格 36 , 游戏结束。 
可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 
```

**示例 2：**

```
输入：board = [[-1,-1],[-1,3]]
输出：1
```

提示：

n == board.length == board[i].length
2 <= n <= 20
`grid[i][j] 的值是 -1 或在范围 [1, n2] 内`
编号为 1 和 n2 的方格上没有蛇或梯子

## 方法：二维转一维+TP问题

人话，题目里的梯子，蛇都扯淡，就从 a 位置tp到b位置，且有方向，且不计入步数

```
一个N*N的棋盘,起点是左下角,一次可以走 1-6步
从左下角开始棋盘编号从下往上蛇形递增
                7 8 9
                6 5 4
                1 2 3
如上图(其实不是图)所示:
起点是 1,终点是 9(N*N)  (1-9为棋盘编号)
每格棋盘单元格内容一般是-1
如果棋盘单元格内容不是-1,而是一个数字,
则如果跳到这里,就要传送到指定数字编号的棋盘单元格中
                -1 -1 -1
                -1 -1 -1
                -1 -1  8
如图:走到第三个格的位置,就会自动被传送到8的位置
```

之所以「二维转一维」，是因为题目的这个要求：目标方格的编号符合范围 `[curr + 1, min(curr + 6, n2)]` 

用「临接表」表示接下来往哪里走，很麻烦，当然不是不行



```cpp
class Solution {
public:
    int snakesAndLadders(vector<vector<int>>& board) {
        int n = board.size();
        vector<int> graph(n * n + 1, 0);

        // 建一维图
        bool flag = true;  // 从左往右
        int node = 1;
        for (int r = n - 1; r >= 0; r--) {
            if (flag) {
                for (int c = 0; c < n; c++) {
                    graph[node] = board[r][c];
                    node++;
                }
            } else {
                for (int c = n - 1; c >= 0; c--) {
                    graph[node] = board[r][c];
                    node++;
                }
            }
            flag = !flag;
        }
        // for (auto a : graph) {
        //     cout << a << " ";
        // }

        int end = n * n;
        deque<pair<int, int>> queue = {{1, 0}};  // 站在 1 号位置上，步数为 0
        unordered_set<int> visited = {1};        // 不走重复的路
        while (!queue.empty()) {
            auto [cur, step] = queue.front();
            queue.pop_front();
            if (cur == end) return step;

            for (int d = 1; d <= 6; d++) {
                int next = cur + d;
                if (next > end) continue;  // 下个位置超过终点
                if (graph[next] != -1) {
                    // 可以TP，next更新为下个地址, 而且不增加步数
                    next = graph[next];
                }
                if (visited.count(next) == 1) continue;  // 不走重复路

                // cout << cur << " " << next << endl;
                queue.push_back({next, step + 1});
                visited.insert(next);
            }
        }
        return -1;
    }
};
```

