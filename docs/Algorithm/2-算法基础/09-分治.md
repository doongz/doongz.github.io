# 分治

参考 1：[递归 & 分治](https://oi-wiki.org/basic/divide-and-conquer/)

参考 2：[分治算法详解：表达式的不同优先级](https://mp.weixin.qq.com/s/fcCJFk89w953gXDjnlZFIA)

## 学习前，需要了解

回溯、分治和动态规划算法可以划为一类，因为它们都会涉及递归

回溯算法就一种简单粗暴的算法技巧，说白了就是一个暴力穷举算法，比如让你 用回溯算法求[子集、全排列、组合](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485007&idx=1&sn=ceb42ba2f341af34953d158358c61f7c&chksm=9bd7f847aca071517fe0889d2679ead78b40caf6978ebc1d3d8355d6693acc7ec3aca60823f0&scene=21#wechat_redirect)，你就穷举呗，就考你会不会漏掉或者多算某些情况。

动态规划是一类算法问题，肯定是让你求最值的。因为动态规划问题拥有 [最优子结构](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484832&idx=1&sn=44ad2505ac5c276bf36eea1c503b78c3&chksm=9bd7fba8aca072be32f66e6c39d76ef4e91bdbf4ef993014d4fee82896687ad61da4f4fc4eda&scene=21#wechat_redirect)，可以通过状态转移方程从小规模的子问题最优解推导出大规模问题的最优解。

分治算法呢，可以认为是一种算法思想，通过将原问题分解成小规模的子问题，然后根据子问题的结果构造出原问题的答案。这里有点类似动态规划，所以说运用分治算法也需要满足一些条件，你的原问题结果应该可以通过合并子问题结果来计算。

其实这几个算法之间界定并没有那么清晰，有时候回溯算法加个备忘录似乎就成动态规划了，而分治算法有时候也可以加备忘录进行剪枝。

## 分治概念

分治算法的核心思想是「分而治之」

**流程分为三步**：分解 -> 解决 -> 合并

- 分解原问题为结构相同的子问题
- 分解到某个容易求解的边界之后，进行递归求解
- 将子问题的解合并成原问题的解

**分治法能解决的问题一般有如下特征：**

- 该问题的规模缩小到一定的程度就可以容易地解决
- 该问题可以分解为若干个规模较小的相同问题，即该问题具有「最优子结构」性质
- 利用该问题分解出的子问题的解可以「合并」为该问题的解
- 该问题所分解出的各个子问题是「相互独立」的，即子问题之间不包含公共的子问题

>注意：如果各子问题是不独立的，则分治法要重复地解公共的子问题，也就做了许多不必要的工作。此时虽然也可用分治法，但一般用 「动态规划」较好

最典型的「分治算法」就是归并排序了，核心逻辑如下：

```cpp
void sort(int[] nums, int lo, int hi) {
    int mid = (lo + hi) / 2;
    /****** 分 ******/
    // 对数组的两部分分别排序
    sort(nums, lo, mid);
    sort(nums, mid + 1, hi);
    /****** 治 ******/
    // 合并两个排好序的子数组
    merge(nums, lo, mid, hi);
}
```

