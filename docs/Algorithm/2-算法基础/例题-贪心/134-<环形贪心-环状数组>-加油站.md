[134. 加油站](https://leetcode-cn.com/problems/gas-station/)

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

```
示例 1:

输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。

示例 2:

输入: gas = [2,3,4], cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。

```

**提示:**

- `gas.length == n`
- `cost.length == n`
- `1 <= n <= 105`
- `0 <= gas[i], cost[i] <= 104`

## 方法一：环状数组的模拟（超时）

暴力的方法很明显就是O(n^2)的，遍历每一个加油站为起点的情况，模拟一圈。

如果跑了一圈，中途没有断油，而且最后油量大于等于0，说明这个起点是ok的。

使用 `i = (i + 1) % n;` 模拟跑一圈的过程

时间复杂度：`O(n^2)`

空间复杂度：`O(1)`

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        for (int start = 0; start < n; start++) {
            int residual = 0;  // 到达 i 点时剩余的汽油（还没在 i 点加油）
            int i = start;
            int cnt = 0;  // 遇见起点的次数
            while (true) {
                if (i == start) cnt++;
                if (cnt == 2) break;      // 第二次遇见时跳出循环
                residual += gas[i];       // 在 i 点加油
                residual -= cost[i];      // 从 i 点开到 i+1 点剩下的油
                if (residual < 0) break;  // 开到下个位置后，检查下剩余油量
                i = (i + 1) % n;          // i 更新为下一个位置
            }
            // 跳出循环时，可能中途跳出，也可能第一个位置就不满足，所以还要判别下 cnt == 2
            if (i == start && cnt == 2) return start;
        }
        return -1;
    }
};
```

## 方法二：环形贪心

### 思路 1

车能开完全程需要满足两个条件

- 车从`i`站能开到`i+1`
- 所有站里的油总量要`>=`车子的总耗油量

那么，假设从编号为0站开始，一直到`k`站都正常，在开往`k+1`站时车子没油了。这时，应该将起点设置为`k+1`站。

问题1: 为什么应该将起始站点设为`k+1`？

因为`k->k+1`站耗油太大，`0->k`站剩余油量都是不为负的，每减少一站，就少了一些剩余油量。**所以如果从`k`前面的站点作为起始站，剩余油量不可能冲过`k+1`站**

```
+10  +20
 A -> B -> C -> D
   -1  -30
```

问题2: 为什么如果`k+1->end`全部可以正常通行，且`rest>=0`就可以说明车子从`k+1`站点出发可以开完全程？

因为，起始点将当前路径分为「前后两部分」。其中，必然有**前半部分剩余油量<0，后半部分剩余油量>0**

所以，无论多少个站，都可以抽象为两个站点（A、B）。从B站加满油出发，开往A站，车加油，再开回B站的过程

整个过程的耗油为：B->A + A->B，也相当于 A->B + B->A（符合正常的遍历顺序）

所以需要满足，**B剩余的油>=A缺少的总油**

```
   start
A -> B -> A -> B
```

**结论**：

- 如果从起点 start 累加 gas[i]-cost[i] 到 k 点后，小于 0。那么从起点 start 到 k 点都不会为真正的起点
- 如果总加油量 sum(gas) >= 总耗油量 sum(cost) ，问题一定有解

**算法实现**：

时间复杂度：`O(n)`

空间复杂度：`O(1)`

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int start = 0;
        int residual = 0;  // 整体
        int run_cost = 0;  // 从 start 开始记
        for (int i = 0; i < gas.size(); i++) {
            residual += gas[i] - cost[i];
            run_cost += gas[i] - cost[i];
            if (run_cost < 0) {
                start = i + 1;
                run_cost = 0;
            }
        }
        if (residual >= 0) {
            return start;
        }
        return -1;
    }
};
```

### 思路 2

有一个环形路上有n个站点； 每个站点都有一个好人或一个坏人； 好人会给你钱，坏人会收你一定的过路费，如果你带的钱不够付过路费，坏人会跳起来把你砍死； 问：从哪个站点出发，能绕一圈活着回到出发点?

首先考虑一种情况：如果全部好人给你 的钱加起来 小于 坏人收的过路费之和，那么总有一次你的钱不够付过路费，你的结局注定会被砍死。

假如你随机选一点 start 出发，那么你肯定会选一个有好人的站点开始，因为开始的时候你没有钱，遇到坏人只能被砍死；

现在你在start出发，走到了某个站点end，被end站点的坏人砍死了，说明你在 [start, end] 存的钱不够付 end点坏人的过路费，因为start站点是个好人，所以在 [start, end] 里任何一点出发，你存的钱会比现在还少，还是会被end站点的坏人砍死；

于是你重新读档，聪明的选择从 end+1点出发，继续你悲壮的征程； 终于有一天，你发现自己走到了尽头（下标是n-1)的站点而没有被砍死； 此时你犹豫了一下，那我继续往前走，身上的钱够不够你继续走到出发点Start?

当然可以，因为开始已经判断过，好人给你的钱数是大于等于坏人要的过路费的，你现在攒的钱完全可以应付 [0, start] 这一段坏人向你收的过路费。 这时候你的嘴角微微上扬，眼眶微微湿润，因为你已经知道这个世界的终极奥秘：Start就是这个问题的答案。

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        int residual = 0;  // 整体
        for (int i = 0; i < n; i++) {
            residual += gas[i] - cost[i];
        }
        if (residual < 0) {
            return -1;
        }

        int start = 0;
        int run_cost = 0;  // 从 start 开始记
        for (int i = 0; i < gas.size(); i++) {
            run_cost += gas[i] - cost[i];
            if (run_cost < 0) {
                start = i + 1;
                run_cost = 0;
            }
        }
        return start;
    }
};
```

