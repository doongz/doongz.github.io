[1996. 游戏中弱角色的数量](https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/)

你正在参加一个多角色游戏，每个角色都有两个主要属性：**攻击** 和 **防御** 。给你一个二维整数数组 `properties` ，其中 `properties[i] = [attacki, defensei]` 表示游戏中第 `i` 个角色的属性。

如果存在一个其他角色的攻击和防御等级 **都严格高于** 该角色的攻击和防御等级，则认为该角色为 **弱角色** 。更正式地，如果认为角色 `i` **弱于** 存在的另一个角色 `j` ，那么 `attackj > attacki` 且 `defensej > defensei` 。

返回 **弱角色** 的数量。

```
示例 1：

输入：properties = [[5,5],[6,3],[3,6]]
输出：0
解释：不存在攻击和防御都严格高于其他角色的角色。

示例 2：

输入：properties = [[2,2],[3,3]]
输出：1
解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。

示例 3：

输入：properties = [[1,5],[10,4],[4,3]]
输出：1
解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。

```

提示：

2 <= properties.length <= 105
properties[i].length == 2
1 <= attacki, defensei <= 105



## 方法：排序预处理+贪心

**攻击力由大到小排序 大 --> 小**

```
[攻击力大的一群]  当前元素  [攻击小的一群]
```

- 当前元素左边的一群，攻击力都大于当前元素
- 如果左边的一群元素中的最大的防御力 大于 当前元素，那么当前元素必然为弱者（攻击力和防御力都小于左边的某个元素）

**但是攻击力可能相等**，如果攻击力相等的情况下，防御力随机排序，如

```
[[5,5], [4,6]]  [[3,1], [3,7], [3,5]]  [[1,1]]
```

当遍历到 [3,5] 时，会把 [3,7] 当成比他大的人

如何避免呢，**把防御力由小到大排个序，考虑可能会出现三种情况**

- 防御力大的那个元素，出现在 [攻击力大的一群]

- 防御力大的那个元素，出现在 [攻击力相等的那一群]
- 攻击力和防御力都相等

```
[[5,2], [4,10]]  [[3,1], [3,5], [3,7]]  [[1,1]]
[[5,2], [4,3]]  [[3,1], [3,5], [3,7]]  [[1,1]]
[[5,2], [4,3]]  [[3,1], [3,5], [3,5]]  [[1,1]]
```

- 第一种，遍历到 [3,7] 时，max_def = 10，可以正确统计
- 第二种，遍历到 [3,7] 时，max_def = 5，更正 max_def = 7，不进行统计
- 第二种，遍历到第二个 [3,5] 时，直接 pass

可见，通过防御力（相较于攻击力）的「逆向排序」，避免了「攻击力相等」造成的错误统计

**注：第一个元素正向排序，根据第二个元素反向排序，这种情况的排序预处理很常见**

时间复杂度：`O(nlogn)`

空间复杂度：`O(logn)`

```c++
class Solution {
public:
    int numberOfWeakCharacters(vector<vector<int>> &properties) {
        auto cmp = [&](const auto &a, const auto &b) {
            if (a[0] != b[0]) return a[0] > b[0];
            return a[1] < b[1];
        };
        sort(properties.begin(), properties.end(), cmp);
        int max_def = 0;
        int ans = 0;
        for (auto &cur : properties) {
            if (cur[1] > max_def) {
                max_def = cur[1];
            } else if (cur[1] == max_def) {
            } else if (cur[1] < max_def) {
                ans++;
            }
        }
        return ans;
    }
};

```

