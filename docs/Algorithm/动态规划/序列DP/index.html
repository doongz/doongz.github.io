<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Algorithm/动态规划/序列DP">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">序列 DP | Doongz&#x27;s Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doongz.github.io/docs/Algorithm/动态规划/序列DP"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="序列 DP | Doongz&#x27;s Site"><meta data-rh="true" name="description" content="参考 1：leetcode 300 题解（LIS）"><meta data-rh="true" property="og:description" content="参考 1：leetcode 300 题解（LIS）"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doongz.github.io/docs/Algorithm/动态规划/序列DP"><link data-rh="true" rel="alternate" href="https://doongz.github.io/docs/Algorithm/动态规划/序列DP" hreflang="en"><link data-rh="true" rel="alternate" href="https://doongz.github.io/docs/Algorithm/动态规划/序列DP" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Doongz&#39;s Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Doongz&#39;s Site Atom Feed"><link rel="stylesheet" href="/assets/css/styles.99c6e2a1.css">
<link rel="preload" href="/assets/js/runtime~main.f9aa80d1.js" as="script">
<link rel="preload" href="/assets/js/main.0ded408c.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Home page</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Notes</a><a class="navbar__item navbar__link" href="/community/support">Community</a><a class="navbar__item navbar__link" href="/blog">Blog</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Courses</a><ul class="dropdown__menu"><li><a href="https://github.com/doongz/mlc-ai" target="_blank" rel="noopener noreferrer" class="dropdown__link">Machine Learning Compilation<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/cs229" target="_blank" rel="noopener noreferrer" class="dropdown__link">Stanford CS229: Machine Learning<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/aics" target="_blank" rel="noopener noreferrer" class="dropdown__link">中国科学院 智能计算系统<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/cs50-ai" target="_blank" rel="noopener noreferrer" class="dropdown__link">Harvard CS50’s Introduction to AI with Python<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/mit-6.824" target="_blank" rel="noopener noreferrer" class="dropdown__link">MIT-6.824 Distributed Systems<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/os-workbench" target="_blank" rel="noopener noreferrer" class="dropdown__link">南京大学 操作系统：设计与实现<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/mit-6.s081" target="_blank" rel="noopener noreferrer" class="dropdown__link">MIT-6.S081 Operating Systems Engineering<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://github.com/doongz" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/Algorithm/前述/面试时做题技巧">Algorithm</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/前述/面试时做题技巧">前述</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/数据结构/基本概念">数据结构</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/排序">算法基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/Algorithm/动态规划/基础">动态规划</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/基础">动态规划基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/记忆化搜索">记忆化搜索</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/线性DP">线性 DP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/背包DP">背包问题概述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Algorithm/动态规划/序列DP">序列 DP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/区间DP">区间DP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/树形DP">树形 DP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/状态压缩DP">状态压缩 DP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/数位DP">数位 DP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/股票问题">股票问题</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-区间DP/&lt;回文问题&gt;-最长回文子串">例题-区间DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-序列DP/&lt;匹配问题&gt;-正则表达式匹配">例题-序列DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-数位DP/&lt;数学思路&gt;-统计各位数字都不同的数字个数">例题-数位DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-树形DP/&lt;多源bfs-树形DP-换根dp&gt;-最小高度树">例题-树形DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-状态压缩DP/&lt;dfs-状态压缩&gt;-优美的排列">例题-状态压缩DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-线性DP/&lt;找上一个位置&gt;-最长有效括号">例题-线性DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-股票问题/买卖股票的最佳时机">例题-股票问题</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-背包DP/&lt;完全背包-经典题&gt;-完全平方数">例题-背包DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-记忆化搜索/&lt;a转化b&gt;-编辑距离">例题-记忆化搜索</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-路径问题/不同路径">例题-路径问题</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/空间压缩的方式">空间压缩的方式</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/图论/理论基础">图论</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/数学/数学运算/num和arr互转">数学</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/系列题目/括号问题/">系列题目</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Competition/比赛">Competition</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Course/CMU-15-213">Course</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Knowledge/IC/IC">Knowledge</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Math/微积分/极限">Math</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Skill/ASM/RISC-V/汇编语言格式及ABI">Skill</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Algorithm</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">动态规划</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">序列 DP</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>序列 DP</h1><p>参考 1：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/" target="_blank" rel="noopener noreferrer">leetcode 300 题解（LIS）</a></p><p>参考 2：<a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/fu-xue-ming-zhu-er-wei-dong-tai-gui-hua-r5ez6/" target="_blank" rel="noopener noreferrer">leetcode 1143 题解（LCS）</a></p><p>参考 3：<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/" target="_blank" rel="noopener noreferrer">leetcode 53 题解（最大子数组和）</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="无后效性">无后效性<a class="hash-link" href="#无后效性" title="Direct link to heading">​</a></h2><p><strong>「无后效性」是「动态规划」中非常重要的概念，在我看来，理解这个概念无比重要</strong>。很遗憾，《算法导论》上没有讲到「无后效性」。我找了一本在「豆瓣」目前豆瓣上评分为 9.2 的书 《算法竞赛进阶指南》，这本书和《算法导论》《算法 4》和 liuyubobobo 老师的算法课程一样，在我学习算法与数据结构的道路上，都发挥了巨大的作用。</p><p>李煜东著《算法竞赛进阶指南》，摘录如下：：</p><p><strong>为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响</strong>。这个条件也被叫做「无后效性」。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的「状态」，图中的边则对应状态之间的「转移」，转移的选取就是动态规划中的「决策」。</p><p>解释：</p><ul><li>「有向无环图」「拓扑序」表示了每一个子问题只求解一次，以后求解问题的过程不会修改以前求解的子问题的结果；</li><li>换句话说：如果之前的阶段求解的子问题的结果包含了一些不确定的信息，导致了后面的阶段求解的子问题无法得到，或者很难得到，这叫「有后效性」，我们在当前这个问题第 1 次拆分的子问题就是「有后效性」的（大家可以再翻到上面再看看）；</li><li>解决「有后效性」的办法是固定住需要分类讨论的地方，记录下更多的结果。在代码层面上表现为：<ul><li>状态数组增加维度，例如：「力扣」的股票系列问题；</li><li>把状态定义得更细致、准确，例如：前天推送的第 124 题：状态定义只解决路径来自左右子树的其中一个子树。</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="思考顺序">思考顺序<a class="hash-link" href="#思考顺序" title="Direct link to heading">​</a></h2><p><strong>1. 定义状态</strong></p><p><strong>2. 状态转移方程</strong></p><p><strong>3. 初始化</strong></p><p><strong>4. 输出</strong></p><p><strong>空间优化</strong></p><p><strong>复杂度分析</strong></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="一最长上升子序列lis">一、最长上升子序列（LIS）<a class="hash-link" href="#一最长上升子序列lis" title="Direct link to heading">​</a></h2><p>最长递增子序列（Longest Increasing Subsequence，简写 LIS）是非常经典的一个算法问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何找状态转移方程，如何写出动态规划解法。比较难想到的是利用二分查找，时间复杂度是 O(NlogN)</p><p>题目：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener noreferrer">300. 最长递增子序列</a></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">输入：nums = [10,9,2,5,3,7,101,18]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入：nums = [0,1,0,3,2,3]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入：nums = [7,7,7,7,7,7,7]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>「子序列」是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。「子串」一定是连续的。</p><p>例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列</p></blockquote><ul><li>如果题目问所有解，应该使用「回溯算法」（暴力搜索）搜索所有具体解</li><li>若问最优解的长度，用「动态规划」</li><li>若问其中一个最优解，或者最优解的结尾最小的方案，用「二分查找 + 贪心算法」</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1暴力解法">1、暴力解法<a class="hash-link" href="#1暴力解法" title="Direct link to heading">​</a></h3><p>使用「回溯搜索算法」或者「位运算」的技巧，可以得到输入数组的所有子序列，时间复杂度为 O(2^N)。再对这些子串再依次判定是否为「严格上升」，时间复杂度 为O(N)，所以总的时间复杂度为：O(N 2^N)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2动态规划">2、动态规划<a class="hash-link" href="#2动态规划" title="Direct link to heading">​</a></h3><p>基于「动态规划」的状态设计需要满足「无后效性」的设计思想，可以将状态定义为「以 <code>nums[i]</code> 结尾 的「上升子序列」的长度」。</p><blockquote><p>「无后效性」的设计思想：让不确定的因素确定下来，以保证求解的过程形成一个逻辑上的有向无环图。这题不确定的因素是某个元素是否被选中，而我们设计状态的时候，让 nums<!-- -->[i]<!-- --> 必需被选中，这一点是「让不确定的因素确定下来」，也是我们这样设计状态的原因。</p></blockquote><p><strong>1. 定义状态</strong>：</p><p><code>dp[i]</code> 表示：<strong>以 <code>nums[i]</code> 结尾</strong> 的「上升子序列」的长度。注意：这个定义中 <strong><code>nums[i]</code> 必须被选取，且必须是这个子序列的最后一个元素</strong>；</p><p><strong>2. 状态转移方程</strong>：</p><p>如果一个较大的数接在较小的数后面，就会形成一个更长的子序列。只要 nums<!-- -->[i]<!-- --> 严格大于在它位置之前的某个数，那么 nums<!-- -->[i]<!-- --> 就可以接在这个数后面形成一个更长的上升子序列。</p><p>$$
dp<!-- -->[i]<!-- --> = \max(dp<!-- -->[i]<!-- -->,\ dp<!-- -->[j]<!-- -->+1) \qquad j\in[0,i), \ nums<!-- -->[j]<!-- --> &lt;nums<!-- -->[i]<!-- -->
$$
<strong>3. 初始化</strong>：</p><p><code>dp[0] = 1</code>，1 个字符显然是长度为 1 的上升子序列。</p><p><strong>4. 输出</strong>：</p><p>不能返回最后一个状态值，最后一个状态值只表示以 <code>nums[len - 1]</code> 结尾的「上升子序列」的长度，状态数组 <code>dp</code> 的最大值才是题目要求的结果。
$$
max(dp<!-- -->[i]<!-- -->) \qquad i\in<!-- -->[0,n-1]<!-- -->
$$
<strong>5. 空间优化</strong>：</p><p>遍历到一个新数的时候，之前所有的状态值都得保留，因此无法优化空间。</p><p><strong>复杂度分析</strong>：</p><p>时间复杂度：<code>O(N^2)</code></p><p>空间复杂度：<code>O(N)</code></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;int&gt; dp(n, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 1; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int j = 0; j &lt; i; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (nums[i] &gt; nums[j]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dp[i] = max(dp[i], dp[j] + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return *max_element(dp.begin(), dp.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3二分查找--贪心算法">3、二分查找 + 贪心算法<a class="hash-link" href="#3二分查找--贪心算法" title="Direct link to heading">​</a></h3><p><strong>状态设计思想</strong>：</p><p>依然着眼于某个上升子序列的「结尾的元素」，<strong>如果已经得到的上升子序列的「结尾的数越小」，那么遍历的时候后面接上一个数，会有更大的可能构成一个长度更长的上升子序列</strong>。既然结尾越小越好，我们可以记录 在长度固定的情况下，结尾最小的那个元素的数值，这样定义以后容易得到「状态转移方程」</p><p>为了与「方法二」的状态定义区分，将状态数组命名为 tail</p><p><strong>1 .定义状态</strong>：</p><p><code>tail[i]</code> 表示：长度为 <code>i + 1</code> 的 <strong>所有</strong> 上升子序列的结尾的最小值</p><p>说明：</p><ul><li>数组 tail 不是问题中的「最长上升子序列」（下文还会强调），不能命名为 LIS。数组 tail 只是用于求解 LIS 问题的状态数组；</li><li>tail<!-- -->[0]<!-- --> 表示长度为 1 的所有上升子序列中，结尾最小的元素的数值。以题目中的示例为例 <!-- -->[10, 9, 2, 5, 3, 7, 101, 18]<!-- --> 中，容易发现长度为 2 的所有上升子序列中，结尾最小的是子序列 <!-- -->[2, 3]<!-- --> ，因此 tail<!-- -->[1]<!-- --> = 3；</li><li>下标和长度有数值为 1 的偏差；</li></ul><p>状态定义其实也描述了状态转移方程</p><p><strong>2. 状态转移方程</strong>：</p><p>从直觉上看，<strong>数组 <code>tail</code> 是一个严格上升数组</strong>。下面是证明</p><p><strong>证明</strong>：即对于任意的下标 <code>0 &lt;= i &lt; j &lt; len</code> ，都有 <code>tail[i] &lt; tail[j]</code></p><p>使用反证法：假设对于任意的下标 <code>i &lt; j</code> ，存在某个 <code>tail[i] &gt;= tail[j]</code></p><p>对于此处的 <code>tail[i]</code> 而言，对应一个上升子序列 <code>[a0, a1, ..., ai]</code>，依据定义 <code>tail[i] = ai</code></p><p>对于此处的 <code>tail[j]</code> 而言，对应一个上升子序列 <code>[b0, b1, ..., bi, ... , bj]</code>，依据定义 <code>tail[j] = bj</code></p><p>由于 <code>tail[i] &gt;= tail[j]</code>，等价于 <code>ai &gt;= bj</code>，而在上升子序列 <code>[b0, b1, ..., bi, ... , bj]</code> 中，<code>bi</code> 严格小于 <code>bj</code> ，故有 <code>ai &gt;= bj &gt; bi</code></p><p>则上升子序列 <code>[b0, b1, ..., bi]</code> 是一个长度也为 <code>i + 1</code> 但是结尾更小的数组，与 <code>ai</code> 的最小性矛盾</p><p>因此原命题成立（证闭）</p><hr><p><strong>因此只需要维护状态数组 <code>tail</code> 的定义，它的长度就是最长上升子序列的长度</strong>。下面说明在遍历中，如何维护状态数组 <code>tail</code> 的定义</p><ol><li>在遍历数组 <code>nums</code> 的过程中，看到一个新数 <code>num</code>，如果这个数「严格大于」有序数组 <code>tail</code> 的最后一个元素，就把 <code>num</code> 放在有序数组 <code>tail</code> 的后面，否则进入第 2 点；</li><li>在有序数组 <code>tail</code> 中查找第 1 个等于大于 <code>num</code> 的那个数，试图让它变小；<ul><li>如果有序数组 <code>tail</code> 中存在 <strong>等于</strong> <code>num</code> 的元素，什么都不做，因为以 <code>num</code> 结尾的最短的「上升子序列」已经存在；</li><li>如果有序数组 <code>tail</code> 中存在 <strong>大于</strong> <code>num</code> 的元素，找到第 1 个，让它变小为 <code>num</code>，这样我们就找到了一个 <strong>结尾更小</strong>的<strong>相同长度</strong>的上升子序列。</li></ul></li></ol><p>说明：</p><ul><li>我们再看一下数组 <code>tail[i]</code> 的定义：长度为 <code>i + 1</code> 的 <strong>所有</strong> 最长上升子序列的结尾的最小值。因此，在遍历的过程中，我们会不断的刷新 <code>tail</code> 数组，使其整体上变小，最后位置上的数也变小，<strong>以便让新来的数扩充 <code>tail</code> 数组</strong></li><li>这一步可以认为是「<strong>贪心算法</strong>」，总是做出在当前看来最好的选择，当前「最好的选择」是：当前只让让第 1 个严格大于 <code>nums[i]</code> 的数变小，变成 <code>nums[i]</code>，这一步操作是「<strong>无后效性</strong>」的；</li><li>由于是在有序数组中的操作，因此可以使用「<strong>二分查找算法</strong>」。</li></ul><p><strong>3. 初始化</strong>：</p><p>遍历第 1 个数 <code>nums[0]</code>，直接放在有序数组 <code>tail</code> 的开头 <code>tail[0] = nums[0]</code></p><p><strong>4. 输出</strong>：</p><p>有序数组 <code>tail</code> 的长度，就是所求的<strong>「最长上升子序列」的长度</strong></p><p><strong>5. 空间优化</strong>：</p><p>无法优化空间</p><p><strong>复杂度分析</strong>：</p><p>时间复杂度：<code>O(Nlog N)</code></p><p>空间复杂度：<code>O(N)</code></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;int&gt; tail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tail.push_back(nums[0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 1; i &lt; nums.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int end = *tail.rbegin();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (nums[i] &gt; end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                tail.push_back(nums[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (nums[i] == end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (nums[i] &lt; end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                auto it = lower_bound(tail.begin(), tail.end(), nums[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                *it = nums[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return tail.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="二最长公共子序列lcs">二、最长公共子序列（LCS）<a class="hash-link" href="#二最长公共子序列lcs" title="Direct link to heading">​</a></h2><p>计算最长公共子序列（Longest Common Subsequence，简称 LCS）是一道经典的动态规划题目</p><p>题目：<a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener noreferrer">1143. 最长公共子序列</a></p><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：3  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：两个字符串没有公共子序列，返回 0 。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="动态规划">动态规划<a class="hash-link" href="#动态规划" title="Direct link to heading">​</a></h3><p>动态规划是有套路的：</p><ul><li>单个数组或者字符串要用动态规划时，可以把动态规划 <code>dp[i]</code> 定义为 <code>nums[0:i]</code> 中想要求的结果；</li><li>当两个数组或者字符串要用动态规划时，可以把动态规划定义成两维的 <code>dp[i][j]</code> ，其含义是在 <code>A[0:i]</code> 与 <code>B[0:j]</code> 之间匹配得到的想要的结果。</li></ul><p><strong>1. 状态定义</strong></p><p>对于本题，定义 <code>dp[i][j]</code> 表示 <code>text1[0:i-1]</code> 前 i 个和 <code>text2[0:j-1]</code> 前 j 个的最长公共子序列的长度（不一定以 <code>i-1</code> 或 <code>j-1</code> 结尾）</p><blockquote><p>注：<code>text1[0:i-1]</code> 表示的是 text1 的 第 0 个元素到第 i - 1 个元素，两端都包含</p></blockquote><p>之所以 <code>dp[i][j]</code> 的定义不是 <code>text1[0:i]</code> 和 <code>text2[0:j]</code> ，是为了方便当 i = 0 或者 j = 0 的时候，<code>dp[i][j]</code> 表示的为空字符串和另外一个字符串的匹配，这样 <code>dp[i][j]</code> 可以初始化为 0</p><p><strong>2. 状态转移方程</strong></p><ul><li><p>当 <code>text1[i - 1] == text2[j - 1]</code> 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>；举个例子，比如对于 ac 和 bc 而言，他们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度 0 + 1 = 1</p></li><li><p>当 <code>text1[i - 1] != text2[j - 1]</code> 时，说明两个子字符串的最后一位不相等，那么此时的状态 <code>dp[i][j]</code> 应该是 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> 的最大值。举个例子，比如对于 ace 和 bc 而言，他们的最长公共子序列的长度等于 ① ace 和 b 的最长公共子序列长度0 与 ② ac 和 bc 的最长公共子序列长度1 的最大值，即 1</p></li></ul><blockquote><p>选择 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> 中最大值的合理性在于：我们需要在 <code>d[i][j]</code>  这个位置上选择一个字母（来自于 <code>text1[i-1]</code>、<code>text2[j-1]</code>）作为结尾，必然希望这个字母代表的子字符串最长，那么后面的计算才能基于最优的子问题</p></blockquote><p>$$
dp<!-- -->[i][j]<!-- --> =
\begin{cases}
dp<!-- -->[i-1][j-1]<!-- -->+1 &amp; text1<!-- -->[i-1]<!-- -->=text2<!-- -->[j-1]<!-- --> <!-- -->\<!-- --> <!-- -->\<!-- -->
max(dp<!-- -->[i-1][j]<!-- -->, \ dp<!-- -->[i][j-1]<!-- -->) &amp; text1<!-- -->[i-1]<!-- -->\neq text2<!-- -->[j-1]<!-- -->
\end{cases}
$$</p><p><strong>3. 状态的初始化</strong></p><p>初始化就是要看当 i = 0 与 j = 0 时，<code>dp[i][j]</code> 应该取值为多少。</p><p>当 i = 0 时，<code>dp[0][j]</code> 表示的是 text1 中取空字符串 跟 text2 的最长公共子序列，结果肯定为 0.</p><p>当 j = 0 时，<code>dp[i][0]</code> 表示的是 text2 中取空字符串 跟 text1 的最长公共子序列，结果肯定为 0.</p><p>综上，当 i = 0 或者 j = 0 时，<code>dp[i][j]</code> 初始化为 0.</p><p><strong>4. 遍历方向与范围</strong></p><p>由于 <code>dp[i][j]</code> 依赖与 <code>dp[i - 1][j - 1]</code> , <code>dp[i - 1][j]</code>, <code>dp[i][j - 1]</code>，所以 i 和 j 的遍历顺序肯定是从小到大的。</p><p>另外，由于当 i 或 j 取值为 0 的时候，<code>dp[i][j] = 0</code>，而 dp 数组本身初始化就是为 0，所以，直接让 i 和 j 从 1 开始遍历。遍历的结束应该是字符串的长度为 len(text1) 和 len(text2)</p><p><strong>5. 最终返回结果</strong></p><p>由于 <code>dp[i][j]</code> 的含义是 <code>text1[0:i-1]</code> 和 <code>text2[0:j-1]</code> 的最长公共子序列。我们最终希望求的是 text1 和 text2 的最长公共子序列。所以需要返回的结果是 i = len(text1) 并且 j = len(text2) 时的 <code>dp[len(text1)][len(text2)]</code></p><p><strong>复杂度分析</strong>：</p><p>时间复杂度：<code>O(MN)</code></p><p>空间复杂度：<code>O(MN</code></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int longestCommonSubsequence(string text1, string text2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = text1.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int m = text2.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 1; i &lt; n + 1; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int j = 1; j &lt; m + 1; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (text1[i - 1] == text2[j - 1]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dp[n][m];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="三lcs-问题转化为-lis-问题时间复杂度优化">三、LCS 问题转化为 LIS 问题（时间复杂度优化）<a class="hash-link" href="#三lcs-问题转化为-lis-问题时间复杂度优化" title="Direct link to heading">​</a></h2><p>题目：<a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/" target="_blank" rel="noopener noreferrer">1713. 得到子序列的最少操作次数</a></p><p>给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。</p><p>每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = <!-- -->[1,4,1,2]<!-- --> ，那么你可以在中间添加 3 得到 <!-- -->[1,4,3,1,2]<!-- --> 。你可以在数组最开始或最后面添加整数。</p><p>请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。</p><ul><li>1 &lt;= target.length, arr.length &lt;= 10^5</li><li>1 &lt;= target<!-- -->[i]<!-- -->, arr<!-- -->[i]<!-- --> &lt;= 10^9</li><li>target 不包含任何重复元素。</li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">输入：target = [5,1,3], arr = [9,4,2,3,4]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：3</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="思路历程">思路历程<a class="hash-link" href="#思路历程" title="Direct link to heading">​</a></h3><p>看完题目，答案显然是，先求出两个数组的最大公共子序列的长度 len，最后 target.size() - len</p><p>但是两个数组的最长都为 10^5，上述方法的时间复杂度为 O(nm)，显然会超时</p><p>那么，看到另一个条件： <code>target</code> 包含若干 <strong>互不相同</strong> 的整数</p><p>引导我们要将 <strong>LCS 问题转化为 LIS 问题</strong>，把时间复杂度 O(nm) 降至 O(nlogn)</p><p>声明：<strong>LCS 转化为 LIS 问题的先决条件是，其中一个数组内的元素「不重复」</strong>，例如 target 数组</p><p>还有个事实要明确：<strong>「下标上升」意味着「顺序排布」，「顺序排布」意味着「下标上升」</strong>，这是可以进行转化的理论基础</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何转化">如何转化<a class="hash-link" href="#如何转化" title="Direct link to heading">​</a></h3><p><strong>1. 预处理</strong>：找出 arr 中且「同时存在」于 target 中的元素，将这些「同时存在」元素在「target 中的下标」，按照「arr 的顺序」缓存下来</p><p>例如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">target = [6,4,8,1,3,2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">arr = [4,7,6,2,3,8,6,1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">index_list = [1,0,5,4,2,0,3]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unordered_map&lt;int, int&gt; valIdx_map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (int i = 0; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    valIdx_map[target[i]] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;int&gt; index_list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (int num : arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (valIdx_map.count(num)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // cout &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; &quot;idx in target:&quot; &lt;&lt; valIdx_map[num] &lt;&lt; endl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        index_list.push_back(valIdx_map[num]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>2. 将 LCS 转化为 LIS 问题</strong></p><p>首先看下 index_list 内的这些元素具备什么性质：</p><ul><li>里面存储的元素是 target 的下标</li><li>是按照在 arr 中的顺序构成的</li><li>根据 target 的下标，检索出的数，是属于 target 和 arr 公共的</li></ul><p>在这样一个 index_list 中求出「最长上升子序列」，这个 LIS 具备什么性质：</p><ul><li>「同时」满足了在 target 和 arr 中按照「顺序」排布，<strong>「下标上升」意味着「顺序排布」，「顺序排布」意味着「下标上升」</strong></li><li>其中的元素，「同时」存在于 target 和 arr 中，也就是公共的</li></ul><p>这样的一个序列，对于 index_list 是「最长上升子序列」，对于 target 和 arr 就是「最长公共子序列」</p><p>求解的过程，就是将 LCS 问题转化为 LIS 问题</p><blockquote><p>问：为什么其中一个数组内的元素「不重复」，这样的转换方式才能生效呢？</p><ul><li><p>如果 target 数组中某个元素重复出现，应该选择其中的哪个下标来构成最终的那个最长上升子序列」，那么就又得一个个判断这些重复值O(n)，整体的时间复杂度退化为 O(nm)，这样的转换方式又有什么意义</p></li><li><p>如果 target 数组中所有元素都是「不重复」，直接就可选中在target唯一的公共元素 O(1)，嵌入到LCS的O(nlogn)的求解过程中，整体的时间复杂度优化为O(nlogn)</p></li></ul></blockquote><p>时间复杂度：<code>O(nlogn)</code></p><p>空间复杂度：<code>O(n)</code></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int minOperations(vector&lt;int&gt;&amp; target, vector&lt;int&gt;&amp; arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = target.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int m = arr.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unordered_map&lt;int, int&gt; valIdx_map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            valIdx_map[target[i]] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;int&gt; index_list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int num : arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (valIdx_map.count(num)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                index_list.push_back(valIdx_map[num]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (index_list.empty()) {  // 没有公共子序列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;int&gt; tail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tail.push_back(index_list[0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 1; i &lt; index_list.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int cur = index_list[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int end = *tail.rbegin();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (cur &gt; end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                tail.push_back(cur);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                auto it = lower_bound(tail.begin(), tail.end(), cur);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                *it = cur;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return n - tail.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="四最长上升子数组">四、最长上升子数组<a class="hash-link" href="#四最长上升子数组" title="Direct link to heading">​</a></h2><p>题目：<a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener noreferrer">674. 最长连续递增序列</a></p><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">输入：nums = [1,3,5,4,7]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：最长连续递增序列是 [1,3,5], 长度为3。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入：nums = [2,2,2,2,2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：最长连续递增序列是 [2], 长度为1。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="动态规划-1">动态规划<a class="hash-link" href="#动态规划-1" title="Direct link to heading">​</a></h3><p><strong>1. 定义状态</strong></p><p>dp<!-- -->[i]<!-- --> 为以 nums<!-- -->[i]<!-- --> 结尾的最长递增子数组的长度</p><p><strong>2. 状态转移方程</strong>
$$
dp<!-- -->[i]<!-- --> =
\begin{cases}
dp<!-- -->[i-1]<!-- --> + 1 &amp; nums<!-- -->[i]<!-- --> &gt; nums<!-- -->[i-1]<!-- --> <!-- -->\<!-- --> <!-- -->\<!-- -->
1 &amp; nums<!-- -->[i]<!-- --> \leq nums<!-- -->[i-1]<!-- -->
\end{cases}
$$
<strong>3. 初始化</strong></p><p> dp 默认都为 1，自身</p><p><strong>4. 输出</strong></p><p>dp 中的最大值</p><p><strong>5. 空间优化</strong></p><p>状态转移过程中，仅需知道前一个的最长递增子数组的长度 dp<!-- -->[i-1]<!-- -->，可以用一个变量 pre 记录</p><p><strong>复杂度分析</strong>：</p><p>时间复杂度：<code>O(n)</code></p><p>空间复杂度：<code>O(n)</code>，<code>O(1)</code></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // dp[i] 为以 nums[i] 结尾的最长递增子数组的长度，默认为 1，自身</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;int&gt; dp(n, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int ans = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 1; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (nums[i] &gt; nums[i - 1]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dp[i] = dp[i - 1] + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (nums[i] &lt;= nums[i - 1]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dp[i] = 1;  // 也可以不做处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ans = max(ans, dp[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ans;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int pre = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int ans = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 1; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (nums[i] &gt; nums[i - 1]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pre++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (nums[i] &lt;= nums[i - 1]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pre = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ans = max(ans, pre);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ans;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="五最长公共子数组">五、最长公共子数组<a class="hash-link" href="#五最长公共子数组" title="Direct link to heading">​</a></h2><p>题目：<a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener noreferrer">718. 最长重复子数组</a></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：长度最长的公共子数组是 [3,2,1] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：5</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="动态规划-2">动态规划<a class="hash-link" href="#动态规划-2" title="Direct link to heading">​</a></h3><p><strong>1. 定义状态</strong></p><p><code>dp[i][j]</code> 代表以 <code>nums1[i-1]</code> 结尾和 <code>nums2[j-1]</code> 结尾构成的最长公共子数组的「长度」</p><blockquote><p>与定义 LCS 相同的是都需要将 dp 多申请一位，<code>dp[0][j]</code> 和 <code>dp[i][0]</code> 中的 0 代表不使用这个数组的数</p><p>不同的是，需要记录的是「结尾」构成公共数组的长度，LCS 需要的是 nums1<!-- -->[0,i-1]<!-- --> 和 nums2<!-- -->[0,j-1]<!-- --> 「区间内」公共数组的长度</p></blockquote><p><strong>2. 状态转移方程</strong></p><p>能够连续推导是否为「公共子数组」的两个条件是：当前两个元素是否相同；这两个元素前的子数组，是否是公共的</p><p>因此，可以写出状态转移的过程</p><ul><li>当前两元素「相等」，<code>nums1[i-1] == nums2[j-1]</code><ul><li>前面是公共子数组，<code>dp[i][j]</code> = 前面子数组的长度 + 当前两个相同的元素</li><li>前面不是公共子数组，当前位置的 <code>dp[i][j]</code> 只有当前两个相同元素构成公共子数组，也就是 1</li></ul></li><li>当前两元素「不相等」，以这两个元素结尾构不成公共子数组，<code>dp[i][j]</code> 直接置为0</li></ul><p><strong>3. 初始化</strong></p><p><code>dp[i][0]</code>  <code>dp[0][j]</code> 任意一个数组为空时，最长公共子数组长度为0</p><p><strong>4. 输出</strong></p><p>遍历的过程中，统计 <code>dp[i][j]</code> 的最大值</p><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(n^2)</code></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums1.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int m = nums2.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int maxLen = 0;  // 最长长度默认为 0，即不存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 1; i &lt; n + 1; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int j = 1; j &lt; m + 1; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (nums1[i - 1] == nums2[j - 1]) {  // 当前元素相等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (dp[i - 1][j - 1] != 0) {     // 且前面也是公共子数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        dp[i][j] = dp[i - 1][j - 1] + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else {  // 前面不是公共子数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        dp[i][j] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dp[i][j] = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                maxLen = max(maxLen, dp[i][j]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return maxLen;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="六最大子数组和">六、最大子数组和<a class="hash-link" href="#六最大子数组和" title="Direct link to heading">​</a></h2><p>题目：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener noreferrer">53. 最大子数组和</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入：nums = [1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入：nums = [5,4,-1,7,8]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：23</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。</p><p>题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1动态规划">1、动态规划<a class="hash-link" href="#1动态规划" title="Direct link to heading">​</a></h3><p>掌握动态规划问题设计状态的技巧「<strong>无后效性</strong>」</p><p><strong>1. 定义状态</strong></p><p>设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。</p><p><code>dp[i]</code>：表示以 <code>nums[i]</code> <strong>结尾</strong> 的 <strong>连续</strong> 子数组的最大和</p><p><strong>说明</strong>：「结尾」和「连续」是关键字</p><p><strong>2. 状态转移方程</strong></p><p>根据状态的定义，由于 nums<!-- -->[i]<!-- --> 一定会被选取，并且以 nums<!-- -->[i]<!-- --> 结尾的连续子数组与以 nums<!-- -->[i - 1]<!-- --> 结尾的连续子数组只相差一个元素 nums<!-- -->[i]<!-- --> 。</p><p>假设数组 <code>nums</code> 的值全都严格大于 0，那么一定有 <code>dp[i] = dp[i - 1] + nums[i]</code>。</p><p>可是 <code>dp[i - 1]</code> 有可能是负数，于是分类讨论：</p><ul><li>如果 dp<!-- -->[i - 1]<!-- --> &gt; 0，那么可以把 nums<!-- -->[i]<!-- --> 直接接在 dp<!-- -->[i - 1]<!-- --> 表示的那个数组的后面，得到和更大的连续子数组；</li><li>如果 dp<!-- -->[i - 1]<!-- --> &lt;= 0，那么 nums<!-- -->[i]<!-- --> 加上前面的数 dp<!-- -->[i - 1]<!-- --> 以后值不会变大。于是 dp<!-- -->[i]<!-- --> 「另起炉灶」，此时单独的一个 nums<!-- -->[i]<!-- --> 的值，就是 dp<!-- -->[i]<!-- -->。</li></ul><p>$$
dp<!-- -->[i]<!-- --> =
\begin{cases}
dp<!-- -->[i-1]<!-- -->+nums<!-- -->[i]<!-- --> &amp; dp<!-- -->[i-1]<!-- --> &gt; 0 <!-- -->\<!-- --> <!-- -->\<!-- -->
nums<!-- -->[i]<!-- --> &amp; dp<!-- -->[i-1]<!-- --> \leq 0
\end{cases}
$$</p><p><strong>3. 初始化</strong></p><p><code>dp[0]</code> 根据定义，只有 1 个数，一定以 <code>nums[0]</code> 结尾，因此 <code>dp[0] = nums[0]</code></p><p><strong>4. 输出</strong></p><p>这里状态的定义不是题目中的问题的定义，<strong>不能直接将最后一个状态返回回去</strong>；</p><p>这个问题的输出是把所有的 <code>dp[0]</code>、<code>dp[1]</code>、……、<code>dp[n - 1]</code> 都看一遍，取最大值</p><p><strong>5. 优化空间</strong></p><p>根据「状态转移方程」，<code>dp[i]</code> 的值只和 <code>dp[i - 1]</code> 有关，因此可以使用「滚动变量」的方式将代码进行优化。</p><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(n)</code></p><p>空间复杂度：<code>O(n)</code> 或 <code>O(1)</code></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxSubArray(vector&lt;int&gt;&amp; nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;int&gt; dp(n, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp[0] = nums[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 1; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (dp[i - 1] &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dp[i] = dp[i - 1] + nums[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (dp[i - 1] &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dp[i] = nums[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return *max_element(dp.begin(), dp.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxSubArray(vector&lt;int&gt;&amp; nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int pre = nums[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int ans = nums[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 1; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (pre &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pre = pre + nums[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (pre &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pre = nums[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ans = max(ans, pre);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ans;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2分治">2、分治<a class="hash-link" href="#2分治" title="Direct link to heading">​</a></h3><p>分治法的思路是这样的，其实也是分类讨论。</p><p>连续子序列的最大和主要由这三部分子区间里元素的最大和得到：</p><ul><li>第 1 部分：子区间 <!-- -->[left, mid]<!-- -->；</li><li>第 2 部分：子区间 <!-- -->[mid + 1, right]<!-- -->；</li><li>第 3 部分：包含子区间 <!-- -->[mid , mid + 1]<!-- --> 的子区间，即 nums<!-- -->[mid]<!-- --> 与 nums<!-- -->[mid + 1]<!-- --> 一定会被选取。</li></ul><p><img loading="lazy" src="/assets/images/53-8c558c3ef6c0395e64fbb88332ec1802.png" width="1170" height="604" class="img_ev3q"></p><p>考虑第 3 部分跨越两个区间的连续子数组的时候，由于 nums<!-- -->[mid]<!-- --> 与 nums<!-- -->[mid + 1]<!-- --> 一定会被选取，可以从中间向两边扩散，扩散到底 选出最大值</p><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(nlogn)</code>，这里递归的深度是对数级别的，每一层需要遍历一遍数组（或者数组的一半、四分之一）</p><p>空间复杂度：<code>O(logn)</code></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int getCross(int left, int right, int mid, vector&lt;int&gt;&amp; nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 一定会包含 nums[mid]，因为mid是向下取整得到的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int leftMax = INT_MIN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int sum = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int l = mid; l &gt;= left; l--) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sum += nums[l];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (sum &gt; leftMax) leftMax = sum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int rightMax = INT_MIN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sum = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int r = mid + 1; r &lt;= right; r++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sum += nums[r];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (sum &gt; rightMax) rightMax = sum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return leftMax + rightMax;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int dfs(int left, int right, vector&lt;int&gt;&amp; nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (left == right) return nums[left];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int mid = left + (right - left) / 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int leftSub = dfs(left, mid, nums);               // [left, mid]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int rightSub = dfs(mid + 1, right, nums);         // [mid+1, right]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int crossSub = getCross(left, right, mid, nums);  // [left, right] 两端不确定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return max(leftSub, max(rightSub, crossSub));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxSubArray(vector&lt;int&gt;&amp; nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dfs(0, nums.size() - 1, nums);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>剩余未做题目：</p><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/" target="_blank" rel="noopener noreferrer">446. 等差数列划分 II - 子序列</a></td><td><a href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/solution/gong-shui-san-xie-xiang-jie-ru-he-fen-xi-ykvk/" target="_blank" rel="noopener noreferrer">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/concatenated-words/" target="_blank" rel="noopener noreferrer">472. 连接词</a></td><td><a href="https://leetcode-cn.com/problems/concatenated-words/solution/gong-shui-san-xie-xu-lie-dpzi-fu-chuan-h-p7no/" target="_blank" rel="noopener noreferrer">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/" target="_blank" rel="noopener noreferrer">629. K个逆序对数组</a></td><td><a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/solution/gong-shui-san-xie-yi-dao-xu-lie-dp-zhuan-tm01/" target="_blank" rel="noopener noreferrer">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/" target="_blank" rel="noopener noreferrer">689. 三个无重叠子数组的最大和</a></td><td><a href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/solution/gong-shui-san-xie-jie-he-qian-zhui-he-de-ancx/" target="_blank" rel="noopener noreferrer">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/paint-house-iii/" target="_blank" rel="noopener noreferrer">1473. 粉刷房子 III</a></td><td><a href="https://leetcode-cn.com/problems/paint-house-iii/solution/gong-shui-san-xie-san-wei-dong-tai-gui-h-ud7m/" target="_blank" rel="noopener noreferrer">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr></tbody></table></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Algorithm/动态规划/背包DP"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">背包问题概述</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Algorithm/动态规划/区间DP"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">区间DP</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#无后效性" class="table-of-contents__link toc-highlight">无后效性</a></li><li><a href="#思考顺序" class="table-of-contents__link toc-highlight">思考顺序</a></li><li><a href="#一最长上升子序列lis" class="table-of-contents__link toc-highlight">一、最长上升子序列（LIS）</a><ul><li><a href="#1暴力解法" class="table-of-contents__link toc-highlight">1、暴力解法</a></li><li><a href="#2动态规划" class="table-of-contents__link toc-highlight">2、动态规划</a></li><li><a href="#3二分查找--贪心算法" class="table-of-contents__link toc-highlight">3、二分查找 + 贪心算法</a></li></ul></li><li><a href="#二最长公共子序列lcs" class="table-of-contents__link toc-highlight">二、最长公共子序列（LCS）</a><ul><li><a href="#动态规划" class="table-of-contents__link toc-highlight">动态规划</a></li></ul></li><li><a href="#三lcs-问题转化为-lis-问题时间复杂度优化" class="table-of-contents__link toc-highlight">三、LCS 问题转化为 LIS 问题（时间复杂度优化）</a><ul><li><a href="#思路历程" class="table-of-contents__link toc-highlight">思路历程</a></li><li><a href="#如何转化" class="table-of-contents__link toc-highlight">如何转化</a></li></ul></li><li><a href="#四最长上升子数组" class="table-of-contents__link toc-highlight">四、最长上升子数组</a><ul><li><a href="#动态规划-1" class="table-of-contents__link toc-highlight">动态规划</a></li></ul></li><li><a href="#五最长公共子数组" class="table-of-contents__link toc-highlight">五、最长公共子数组</a><ul><li><a href="#动态规划-2" class="table-of-contents__link toc-highlight">动态规划</a></li></ul></li><li><a href="#六最大子数组和" class="table-of-contents__link toc-highlight">六、最大子数组和</a><ul><li><a href="#1动态规划" class="table-of-contents__link toc-highlight">1、动态规划</a></li><li><a href="#2分治" class="table-of-contents__link toc-highlight">2、分治</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Doongz Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.f9aa80d1.js"></script>
<script src="/assets/js/main.0ded408c.js"></script>
</body>
</html>