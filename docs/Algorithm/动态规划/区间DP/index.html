<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Algorithm/动态规划/区间DP">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">区间DP | Doongz&#x27;s Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doongz.github.io/docs/Algorithm/动态规划/区间DP"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="区间DP | Doongz&#x27;s Site"><meta data-rh="true" name="description" content="参考 1：oi-wiki 区间 DP"><meta data-rh="true" property="og:description" content="参考 1：oi-wiki 区间 DP"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doongz.github.io/docs/Algorithm/动态规划/区间DP"><link data-rh="true" rel="alternate" href="https://doongz.github.io/docs/Algorithm/动态规划/区间DP" hreflang="en"><link data-rh="true" rel="alternate" href="https://doongz.github.io/docs/Algorithm/动态规划/区间DP" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Doongz&#39;s Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Doongz&#39;s Site Atom Feed"><link rel="stylesheet" href="/assets/css/styles.99c6e2a1.css">
<link rel="preload" href="/assets/js/runtime~main.f9aa80d1.js" as="script">
<link rel="preload" href="/assets/js/main.0ded408c.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Home page</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Notes</a><a class="navbar__item navbar__link" href="/community/support">Community</a><a class="navbar__item navbar__link" href="/blog">Blog</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Courses</a><ul class="dropdown__menu"><li><a href="https://github.com/doongz/mlc-ai" target="_blank" rel="noopener noreferrer" class="dropdown__link">Machine Learning Compilation<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/cs229" target="_blank" rel="noopener noreferrer" class="dropdown__link">Stanford CS229: Machine Learning<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/aics" target="_blank" rel="noopener noreferrer" class="dropdown__link">中国科学院 智能计算系统<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/cs50-ai" target="_blank" rel="noopener noreferrer" class="dropdown__link">Harvard CS50’s Introduction to AI with Python<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/mit-6.824" target="_blank" rel="noopener noreferrer" class="dropdown__link">MIT-6.824 Distributed Systems<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/os-workbench" target="_blank" rel="noopener noreferrer" class="dropdown__link">南京大学 操作系统：设计与实现<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/doongz/mit-6.s081" target="_blank" rel="noopener noreferrer" class="dropdown__link">MIT-6.S081 Operating Systems Engineering<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://github.com/doongz" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/Algorithm/前述/面试时做题技巧">Algorithm</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/前述/面试时做题技巧">前述</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/数据结构/基本概念">数据结构</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/算法基础/排序">算法基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/Algorithm/动态规划/基础">动态规划</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/基础">动态规划基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/记忆化搜索">记忆化搜索</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/线性DP">线性 DP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/背包DP">背包问题概述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/序列DP">序列 DP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Algorithm/动态规划/区间DP">区间DP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/树形DP">树形 DP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/状态压缩DP">状态压缩 DP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/数位DP">数位 DP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/股票问题">股票问题</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-区间DP/&lt;回文问题&gt;-最长回文子串">例题-区间DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-序列DP/&lt;匹配问题&gt;-正则表达式匹配">例题-序列DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-数位DP/&lt;数学思路&gt;-统计各位数字都不同的数字个数">例题-数位DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-树形DP/&lt;多源bfs-树形DP-换根dp&gt;-最小高度树">例题-树形DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-状态压缩DP/&lt;dfs-状态压缩&gt;-优美的排列">例题-状态压缩DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-线性DP/&lt;找上一个位置&gt;-最长有效括号">例题-线性DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-股票问题/买卖股票的最佳时机">例题-股票问题</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-背包DP/&lt;完全背包-经典题&gt;-完全平方数">例题-背包DP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-记忆化搜索/&lt;a转化b&gt;-编辑距离">例题-记忆化搜索</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/动态规划/例题-路径问题/不同路径">例题-路径问题</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Algorithm/动态规划/空间压缩的方式">空间压缩的方式</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/图论/理论基础">图论</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/数学/数学运算/num和arr互转">数学</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/Algorithm/系列题目/括号问题/">系列题目</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Competition/比赛">Competition</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Course/CMU-15-213">Course</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Knowledge/IC/IC">Knowledge</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Math/微积分/极限">Math</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Skill/ASM/RISC-V/汇编语言格式及ABI">Skill</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Algorithm</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">动态规划</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">区间DP</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>区间DP</h1><p>参考 1：<a href="https://oi-wiki.org/dp/interval/" target="_blank" rel="noopener noreferrer">oi-wiki 区间 DP</a></p><p>参考 2：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247489400&amp;idx=1&amp;sn=0b629d3669329a6bf4f6ec71c2571ce7&amp;chksm=fd9cbc67caeb357132fe0a1ca6240e2183748d94039100f539193d3eeb1dc223e0ddd4aa9584&amp;token=2094656911&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">既是经典区间 DP，也是经典博弈论</a></p><p>参考 3：<a href="https://leetcode-cn.com/problems/stone-game/solution/shi-zi-you-xi-dong-tai-gui-hua-qu-jian-d-5ra8/" target="_blank" rel="noopener noreferrer">石子游戏：对于先手玩家，有两种拿法</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="概念">概念<a class="hash-link" href="#概念" title="Direct link to heading">​</a></h2><p>区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。</p><p>令状态 f(left, right) 表示将下标位置 left 到 right 的所有元素合并能获得的价值的最大值，cost 为将这两组元素合并起来的代价，那么
$$
f(left, right) = max(f(left, k),f(k+1,right)) + cost \ \ \ \ \ \ k\in<!-- -->[left,right]<!-- -->
$$
区间 DP 的特点：</p><p><strong>合并</strong>：即将两个或多个部分进行整合，当然也可以反过来；</p><p><strong>特征</strong>：能将问题分解为能两两合并的形式；</p><p><strong>求解</strong>：对整个问题设最优值，<strong>枚举合并点，将问题分解为左右两个部分</strong>，最后合并两个部分的最优值得到原问题的最优值。</p><p><strong>返回</strong>：通常返回整个区间的解 <code>dp[0][n-1]</code></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1经典遍历方法">1、经典遍历方法<a class="hash-link" href="#1经典遍历方法" title="Direct link to heading">​</a></h3><p><strong>如何遍历「一定要会」</strong>：对于区间 <code>dp[left][right]</code> 来说，将 <code>left</code> 从 <code>n - 1</code> 往前遍历到 <code>0</code>，而 <code>right</code> 从 <code>left</code> 位置往后遍历到 <code>n-1</code>，这样能够方便 <code>left &lt; right</code>，将大区间划分成小区间。从小区间开始判断，不断的扩大我们的判断范围看会不会赢</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2经典初始化方法">2、经典初始化方法<a class="hash-link" href="#2经典初始化方法" title="Direct link to heading">​</a></h3><p><code>dp[left][right]</code> ，left 等于 right 时每个值默认为 1，为自身</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3经典返回方法">3、经典返回方法<a class="hash-link" href="#3经典返回方法" title="Direct link to heading">​</a></h3><p><code>dp[0][n - 1]</code> 描述了整个区间的结果，将其返回</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="一猜数字大小">一、猜数字大小<a class="hash-link" href="#一猜数字大小" title="Direct link to heading">​</a></h2><p>题目：<a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/" target="_blank" rel="noopener noreferrer">375. 猜数字大小 II</a></p><p>通过「记忆化搜索」的递归过程，我们发现，在求解 <!-- -->[i, j]<!-- --> 的最小成本时，需要依赖于 <!-- -->[i, k - 1]<!-- --> 和 <!-- -->[k + 1, j]<!-- --> 这样的比 <!-- -->[i, j]<!-- --> 更小的区间。</p><p>这引导我们使用「区间 DP」进行求解</p><p><strong>定义状态数组和状态</strong>：<code>dp[i][j]</code> 为区间 <!-- -->[i, j]<!-- --> 内进行猜数的最小成本</p><p><strong>状态方程</strong>：结合【确保你获胜的最小现金数】这个条件
$$
f(i,j) = \min\limits_{i&lt;=k&lt;=j}<!-- -->{<!-- -->max(f(i,k-1),f(k+1,j)+k)<!-- -->}<!-- -->
$$
最终的 <code>dp[i][j]</code> 为所有可选的数值 <code>k</code> 中的最小值</p><p>时间复杂度：<code>O(n^3)</code></p><p>空间复杂度：<code>O(n^2)</code></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int getMoneyAmount(int n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 初始化动态数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt;(n + 2));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 区间dp的常用遍历方法，可确保left&lt;right</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int left = n - 1; left &gt;= 1; left--) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int right = left + 1; right &lt;= n; right++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int tmp = INT_MAX;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (int k = left; k &lt;= right; k++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    tmp = min(tmp, max(dp[left][k - 1], dp[k + 1][right]) + k);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dp[left][right] = tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dp[1][n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">问：为什么在循环中 int left = n - 1、int right = left + 1？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">答：注意，right不可与left重合，因为重合时left=right=k，dp[k][k]将会等于k，而dp[k][k]根据题意初始时为0，且之后状态不会刷新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">问：动态数组的size为n+2？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">答：首先+1是因为，我们使用数组的范围是[1,n]，因此申请n+1个位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">再+1是因为，在第三个循环会使 k=right，而且需要使用dp[k+1]，right所使用的范围是[1,n]，那么 k+1=right+1 所使用的范围是[1,n+1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">因此，需要动态数组的size为n+2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="二石子游戏">二、石子游戏<a class="hash-link" href="#二石子游戏" title="Direct link to heading">​</a></h2><p>题目：<a href="https://leetcode-cn.com/problems/stone-game/" target="_blank" rel="noopener noreferrer">877. 石子游戏</a></p><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles<!-- -->[i]<!-- --> 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p><p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p><p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">输入：piles = [5,3,4,5]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Alice 先开始，只能拿前 5 颗或后 5 颗石子 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>提示：</p><ul><li>2 &lt;= piles.length &lt;= 500</li><li>piles.length 是偶数。</li><li>1 &lt;= piles<!-- -->[i]<!-- --> &lt;= 500</li><li>sum(piles) 是奇数。</li></ul><p><strong>解题步骤</strong>:</p><p><strong>定义 <code>dp[left][right]</code> 为考虑区间 <!-- -->[left, right]<!-- --> ，在双方都做最好选择的情况下，先手与后手的最大得分差值为多少。</strong></p><p>那么 <code>dp[0][n-1]</code> 为考虑所有石子，先手与后手的得分差值：</p><ul><li><code>dp[0][n-1]</code> &gt; 0，则先手必胜，返回 <code>True</code></li><li><code>dp[0][n-1]</code> &lt; 0，则先手必败，返回 <code>False</code></li></ul><p>不失一般性的考虑 <code>dp[left][right]</code> 如何转移。根据题意，只能从两端取石子，共两种情况：</p><ul><li>从左端取石子，价值为 <code>piles[left]</code>；先手取完石子后，<strong>会导致下次变为后手</strong>，由先后变成后手损失的值就是「先手与后手的最大得分差值」<code>dp[left+1][right]</code>。<strong>因此本次先手从左端点取石子的话，双方差值为</strong>：</li></ul><p>$$
a = piles<!-- -->[left]<!-- --> - dp<!-- -->[left+1][right]<!-- -->
$$</p><ul><li>从右端取石子，价值为 <code>piles[right]</code>；同理由先后变成后手损失的值为 <code>dp[left][right-1]</code>。<strong>因此本次先手从右端点取石子的话，双方差值为</strong>：</li></ul><p>$$
b = piles<!-- -->[right]<!-- --> - dp<!-- -->[left][right-1]<!-- -->
$$</p><p>双方都想赢，都会做最优决策（即使自己与对方分差最大）。因此 <code>dp[left][right]</code> 为<strong>上述两种情况中的最大值</strong>
$$
dp<!-- -->[left][right]<!-- --> = max(a,b)
$$
根据状态转移方程，我们发现大区间的状态值依赖于小区间的状态值，典型的区间 DP 问题。</p><p><strong>初始化</strong>：当只有一个数时 <code>dp[i][i]</code>，此时先手的必赢，所以 <code>dp[i][i] = piles[i]</code></p><p><strong>如何遍历「经典写法，一定要会」</strong>：对于区间 <code>dp[left][right]</code> 来说，将 <code>left</code> 从 <code>n - 1</code> 往前遍历到 <code>0</code>，而 <code>right</code> 从 <code>left</code> 位置往后遍历到 <code>n-1</code>，这样能够方便 <code>left &lt; right</code>，将大区间划分成小区间。从小区间开始判断，不断的扩大我们的判断范围看会不会赢</p><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(n^2)</code></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bool stoneGame(vector&lt;int&gt;&amp; piles) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = piles.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 初始化 dp 数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp[i][i] = piles[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 状态更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int left = n - 1; left &gt;= 0; left--) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int right = left + 1; right &lt; n; right++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int a = piles[left] - dp[left + 1][right];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int b = piles[right] - dp[left][right - 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dp[left][right] = max(a, b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dp[0][n - 1] &gt; 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此题还有「博弈论」的解法：先手的人必然获胜</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="三最长回文子序列">三、最长回文子序列<a class="hash-link" href="#三最长回文子序列" title="Direct link to heading">​</a></h2><p>题目：<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener noreferrer">516. 最长回文子序列</a></p><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">输入：s = &quot;bbbab&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入：s = &quot;cbbd&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：一个可能的最长回文子序列为 &quot;bb&quot; 。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>1. 状态定义</strong></p><p><code>dp[i][j]</code> 表示 <code>s</code> 的第 <code>i</code> 个字符到第 <code>j</code> 个字符组成的子串中，最长回文序列的长度</p><blockquote><p>不可将状态定义：dp<!-- -->[i]<!-- --> 为 nums<!-- -->[i]<!-- --> 结尾的最长回文子序列，时间复杂度为 O(n^3)</p></blockquote><p><strong>2. 状态转移方程</strong></p><p>如果求 <code>dp[i][j]</code>，假设知道了子问题 <code>dp[i+1][j-1]</code> 的结果（s<!-- -->[i+1..j-1]<!-- --> 中最长回文子序列的长度），是否能想办法算出 <code>dp[i][j]</code> 的值（s<!-- -->[i..j]<!-- --> 中，最长回文子序列的长度）呢？</p><p><img loading="lazy" src="/assets/images/516-1-079de883bb5a72be5f8a1c461290a619.png" width="1280" height="720" class="img_ev3q"></p><p>可以！这取决于区间首尾 <code>s[i]</code> 和 <code>s[j]</code> 的字符</p><ul><li><strong>如果区间首尾相等，首尾「必然参与」构成当前的最长回文子序列</strong>，那么它俩加上 <code>s[i+1..j-1]</code> 中的最长回文子序列就是 <code>s[i..j]</code> 的最长回文子序列：</li></ul><p><img loading="lazy" src="/assets/images/516-2-8895f1197679546be231c08670f0cf15.png" width="1280" height="720" class="img_ev3q"></p><ul><li><strong>如果区间首尾不相等，首尾「必然不同时参与」构成当前的最长回文子序列</strong>，说明它俩不可能同时出现在 s<!-- -->[i..j]<!-- --> 的最长回文子序列中，那么把它俩分别加入 s<!-- -->[i+1..j-1]<!-- --> 中，看看哪个子串产生的回文子序列更长即可：</li></ul><p><img loading="lazy" src="/assets/images/516-3-58239ea53b7a16f0b064f9083d5ea82c.png" width="1280" height="720" class="img_ev3q"></p><p>因此，写出状态转移方程：
$$
dp<!-- -->[i][j]<!-- --> =
\begin{cases}
dp<!-- -->[i+1][j-1]<!-- --> + 2 &amp; s<!-- -->[i]<!-- --> = s<!-- -->[j]<!-- --> <!-- -->\<!-- --> <!-- -->\<!-- -->
max(dp<!-- -->[i+1][j]<!-- -->, dp<!-- -->[i][j-1]<!-- -->) &amp; s<!-- -->[i]<!-- --> \neq s<!-- -->[j]<!-- -->
\end{cases}
$$
对于区间 <code>dp[left][right]</code> 来说，将 <code>left</code> 从 <code>n - 1</code> 往前遍历到 <code>0</code>，而 <code>right</code> 从 <code>left</code> 位置往后遍历到 <code>n-1</code>，这样能够方便 <code>left &lt; right</code>，将大区间划分成小区间。</p><p><strong>3. 初始化</strong></p><p><code>dp[left][right]</code> ，left 等于 right 时每个值默认为 1，s 中单个元素可构成回文子序列</p><p><strong>4. 返回</strong></p><p><code>dp[0][n - 1]</code> 整个 s 的最长回文子串长度</p><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(n^2)</code></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int longestPalindromeSubseq(string s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = s.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp[i][i] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int left = n - 1; left &gt;= 0; left--) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int right = left + 1; right &lt; n; right++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (s[left] == s[right]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dp[left][right] = dp[left + 1][right - 1] + 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (s[left] != s[right]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dp[left][right] = max(dp[left + 1][right], dp[left][right - 1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dp[0][n - 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="四最长回文子串">四、最长回文子串<a class="hash-link" href="#四最长回文子串" title="Direct link to heading">​</a></h2><p>题目：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener noreferrer">5. 最长回文子串</a></p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><p>注意：子串是连续的</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">输入：s = &quot;babad&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：&quot;bab&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入：s = &quot;cbbd&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：&quot;bb&quot;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>1. 状态定义</strong></p><p><code>dp[i][j]</code> 表示 <code>s</code> 的第 <code>i</code> 个字符到第 <code>j</code> 个字符组成的子串，是否可构成回文子串</p><blockquote><p>其实也可以将子串的长度保存到 <code>dp[i][j]</code> 里面</p></blockquote><ul><li>true 代表区间 <!-- -->[i,j]<!-- --> 为回文串</li><li>false 代表区间 <!-- -->[i,j]<!-- --> 不为回文串</li></ul><p><strong>2. 状态转移方程</strong></p><p>状态转移的分析过程与上题类似，但是要注意的是<strong>子串是连续的</strong>，所以 <code>d[i][j]</code> 能否构成回文子串，取决于两个因素</p><ul><li>当前首位元素相同，<code>s[i] == s[j]</code></li><li>前面的子串是回文的，<code>dp[i+1][j-1] == true</code></li></ul><p>可写出下面的转移过程：</p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if (s[left] == s[right] &amp;&amp; dp[left + 1][right - 1] == true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp[left][right] = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp[left][right] = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>直到遇到上面第二个用例，s = &quot;cbbd&quot;，当 left = 1，right = 2 时，做的判断是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">s[1] == s[2] -&gt; true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[2][1] -&gt; false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">从而导致 d[1][2] 错误的置为 false</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>错误的根源是，当「首尾元素紧挨着」的时候 left + 1 和 right - 1 引起的问题</p><p>因此，根据「<strong>首尾元素是否紧挨着</strong>」重新整理下状态转移方程</p><ul><li>当首尾元素紧挨着，<code>right - left == 1</code><ul><li>如果首尾元素相同，可构成回文串</li><li>如果首尾元素不同，不构成回文串</li></ul></li><li>当首尾元素中间有隔着的，<code>right - left &gt; 1</code><ul><li>当前首位元素相同 <code>s[i] == s[j]</code>，且前面的子串是回文的 <code>dp[i+1][j-1] == true</code>，可构成回文串</li><li>当前首位元素不相同 或 前面的子串不回文，不构成回文串</li></ul></li></ul><p><strong>3. 初始化</strong></p><p><code>dp[left][right]</code> ，left 等于 right 时每个值默认为 1，s 中单个元素可构成回文子串</p><p><strong>4. 返回</strong></p><p>在遍历的过程中，记录最长的子串出现的开始位置和长度</p><p>最后将这个最长的子串返回</p><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(n^2)</code></p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    string longestPalindrome(string s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = s.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 初始化，单个元素为回文串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp[i][i] = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int begin = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int maxLen = 1;  // 初始相当于 1 个元素的长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int left = n - 1; left &gt;= 0; left--) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int right = left + 1; right &lt; n; right++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (right - left == 1) {  // 首尾紧挨着</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (s[left] == s[right]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        dp[left][right] = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        dp[left][right] = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {  // 首尾中间有隔着的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (s[left] == s[right] &amp;&amp; dp[left + 1][right - 1] == true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        dp[left][right] = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        dp[left][right] = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 记录答案</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dp[left][right] &amp;&amp; right - left + 1 &gt; maxLen) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    begin = left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    maxLen = right - left + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return s.substr(begin, maxLen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Algorithm/动态规划/序列DP"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">序列 DP</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Algorithm/动态规划/树形DP"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">树形 DP</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#概念" class="table-of-contents__link toc-highlight">概念</a><ul><li><a href="#1经典遍历方法" class="table-of-contents__link toc-highlight">1、经典遍历方法</a></li><li><a href="#2经典初始化方法" class="table-of-contents__link toc-highlight">2、经典初始化方法</a></li><li><a href="#3经典返回方法" class="table-of-contents__link toc-highlight">3、经典返回方法</a></li></ul></li><li><a href="#一猜数字大小" class="table-of-contents__link toc-highlight">一、猜数字大小</a></li><li><a href="#二石子游戏" class="table-of-contents__link toc-highlight">二、石子游戏</a></li><li><a href="#三最长回文子序列" class="table-of-contents__link toc-highlight">三、最长回文子序列</a></li><li><a href="#四最长回文子串" class="table-of-contents__link toc-highlight">四、最长回文子串</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Doongz Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.f9aa80d1.js"></script>
<script src="/assets/js/main.0ded408c.js"></script>
</body>
</html>