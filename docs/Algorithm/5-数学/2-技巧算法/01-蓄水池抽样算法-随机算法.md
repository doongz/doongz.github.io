# 蓄水池抽样算法-随机算法

来源：https://mp.weixin.qq.com/s/T6Q98ooerkM45866HSN5ZQ

对于数据流中的每个样本，决策其是否成为答案样本，无须提前知晓总样本数量，且等概率，同时无须使用额外空间

**最重要的是省空间，空间复杂度 `O(1)`**

应用：当内存无法加载全部数据时，如何从包含未知大小的数据流中随机选取k个数据，并且要保证每个数据被抽取到的概率相等

#### 算法

从前往后处理每个样本，每个样本成为答案的概率为 `1/i `，其中 `i` 为样本编号（编号从 1 开始），最终可以确保每个样本成为答案的概率均为 `1/n` （其中 n 为样本总数）。

容易证明该做法的正确性，假设最终成为答案的样本编号为 `k`，那么 `k` 成为答案的充要条件为「在遍历到 k 时被选中」并且「遍历大于 k 的所有元素时，均没有被选择（没有覆盖 k）」

对应事件概率为：
$$
P = \frac{1}{k} * (1-\frac{1}{k+1}) * (1-\frac{1}{k+2}) * ... * (1-\frac{1}{n})
$$
首项 `1/k` 为选中 k 的概率，后面每项分别为编号为 [k + 1, n] 的样本 **不被选中** 的概率

化简得：
$$
P = \frac{1}{k} * \frac{k}{k+1} * \frac{k+1}{k+2} * ... * \frac{n-1}{n}
$$

$$
P = \frac{1}{n}
$$

因此，在每一次 `getRandom` 时，从前往后处理每个节点，同时记录当前节点的编号，当处理到节点 k 时，在 [0, k) 范围内进行随机，若随机到结果为 0（发生概率为 1/k），则将节点 k 的值存入答案，最后一次覆盖答案的节点即为本次抽样结果。

```c++
class Solution {
public:
    ListNode* root;
    Solution(ListNode* head) {
        root = head;
    }
    
    int getRandom() {
        int res = 0, idx = 0;
        auto ptr = root;
        while (ptr != NULL) {
            idx++;
            if (rand() % idx == 0) res = ptr->val;
            ptr = ptr->next;
        }
        return res;
    }
};
```

idx 代表数据流流到该元素时，此时数据流的长度，相当于 `p=1/n` 中的 n

当数据流在遍历到 idx 长度时中断，也就是 `ptr == NULL`，这个时候要结合上面的推导过程想想

- 最终结果 res 的值在 k 的时候被更新的（0<=k<idx），通过判断在[0, k-1]间能否取到0，其概率相当于 `1/k`
- 在 k 之后，res 就没再更新，相当于 `(1-1/(k+1) ... 1-1/n)`

因此 res 的值，被计算出的概率为 `1/idx`