# 运算符

## 一、算术运算符

假设变量 A 的值为 8，变量 B 的值为 5

| 运算符 | 描述                                                         | 实例            |
| :----- | :----------------------------------------------------------- | :-------------- |
| +      | 把两个操作数相加                                             | A + B 将得到 13 |
| -      | 从第一个操作数中减去第二个操作数                             | A - B 将得到 5  |
| *      | 把两个操作数相乘                                             | A * B 将得到 40 |
| /      | 分子除以分母，取整                                           | B / A 将得到 1  |
| %      | 取模运算符，整除后的余数                                     | B % A 将得到 3  |
| ++     | [自增运算符](https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html)，整数值增加 1 | A++ 将得到 9    |
| --     | [自减运算符](https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html)，整数值减少 1 | A-- 将得到 8    |

## 二、关系运算符

假设变量 A 的值为 10，变量 B 的值为 20

| 运算符 | 描述                                                         | 实例              |
| :----- | :----------------------------------------------------------- | :---------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 不为真。 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。   |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 不为真。  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。    |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。   |

## 三、逻辑运算符

假设变量 A 的值为 1，变量 B 的值为 0

| 运算符 | 描述                                                         | 实例                 |
| :----- | :----------------------------------------------------------- | :------------------- |
| &&     | 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。     | (A && B) 为 false。  |
| \|\|   | 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 | (A \|\| B) 为 true。 |
| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 | !(A && B) 为 true。  |

## 四、位运算符

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与操作，按二进制位进行"与"运算。运算规则：`0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |
| \|     | 按位或运算符，按二进制位进行"或"运算。运算规则：`0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \| B) 将得到 61，即为 0011 1101                           |
| ^      | 异或运算符，按二进制位进行"异或"运算。运算规则：`0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |
| ~      | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=-2;    ~0=-1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| <<     | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |
| >>     | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 | A >> 2 将得到 15，即为 0000 1111                             |

注意：在 c++ 中位运算符的优先级比加减乘除低

```
2 + (3 - 2) >> 1 为 1
2 + ((3-2) >> 1) 为 2
```

## 五、赋值运算符

| 运算符 | 描述                                                         | 实例                            |
| :----- | :----------------------------------------------------------- | :------------------------------ |
| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |
| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |
| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |
| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |
| \|=    | 按位或且赋值运算符                                           | C \|= 2 等同于 C = C \| 2       |

## 六、杂项运算符

| 运算符               | 描述                                                         |
| :------------------- | :----------------------------------------------------------- |
| sizeof               | [sizeof 运算符](https://www.runoob.com/cplusplus/cpp-sizeof-operator.html)返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 |
| Condition ? X : Y    | [条件运算符](https://www.runoob.com/cplusplus/cpp-conditional-operator.html)。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 |
| ,                    | [逗号运算符](https://www.runoob.com/cplusplus/cpp-comma-operator.html)会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 |
| .（点）和 ->（箭头） | [成员运算符](https://www.runoob.com/cplusplus/cpp-member-operators.html)用于引用类、结构和共用体的成员。 |
| Cast                 | [强制转换运算符](https://www.runoob.com/cplusplus/cpp-casting-operators.html)把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 |
| &                    | [指针运算符 &](https://www.runoob.com/cplusplus/cpp-pointer-operators.html) 返回变量的地址。例如 &a; 将给出变量的实际地址。 |
| *                    | [指针运算符 *](https://www.runoob.com/cplusplus/cpp-pointer-operators.html) 指向一个变量。例如，*var; 将指向变量 var。 |

`*` 作为取值符，`*ptr` 取指针 `ptr` 指向的值

`*` 作为一种数据结构，`int *ptr;` 声明了一个指针变量 `ptr`

`&` 作为取地址符，`&var` 取变量 `var` 的地址

`&` 作为一种数据结构，`int &r` 声明了一个引用变量 `r`

## 七、new 和 delete

**在 C 语言中**，动态分配内存用 malloc() 函数，释放内存用 free() 函数

```c
int *p = (int*) malloc( sizeof(int) * 10 );  //分配10个int型的内存空间
free(p);  //释放内存
```

**在 C++ 中**，new 用来动态分配内存，delete 用来释放内存。这两个函数仍然可以使用

- new 操作符会根据后面的数据类型来推断所需空间的大小
- 分配一组连续的数据，使用 new[]
- 用 new[] 分配的内存需要用 delete[] 释放，它们是一一对应的

```c++
int *p = new int;  //分配1个int型的内存空间
delete p;  //释放内存
```

```c++
int *p = new int[10];  //分配10个int型的内存空间
delete[] p;
```

和 malloc() 一样，**new 也是在堆区分配内存，必须手动释放**，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，通常 new 和 delete、new[] 和 delete[] 操作符应该成对出现，并且不要和C语言中 malloc()、free() 一起混用。

**new 在堆区创建的需要用「指针」来接收，否则以后就找不到了**

在C++中，建议使用 new 和 delete 来管理内存，它们可以使用C++的一些新特性，最明显的是可以自动调用构造函数和析构函数。

## 八、typeid运算符

**typeid 运算符用来获取一个表达式的类型信息**。类型信息对于编程语言非常重要，它描述了数据的各种属性：

- 对于基本类型（int、float 等内置类型）的数据，类型信息所包含的内容比较简单，主要是指数据的类型。
- 对于类类型的数据（也就是对象），类型信息是指对象所属的类、所包含的成员、所在的继承关系等。

类型信息是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定。

typeid 的操作对象既可以是表达式，也可以是数据类型，下面是它的两种使用方法：

```c++
typeid(dataType)
typeid(expression)
```

dataType 是数据类型，expression 是表达式，这和 sizeof 运算符非常类似，只不过 sizeof 有时候可以省略括号`( )`，而 typeid 必须带上括号

ypeid 会把获取到的类型信息保存到一个 type_info 类型的对象里面，并返回该对象的常引用；当需要具体的类型信息时，可以通过成员函数来提取。typeid 的使用非常灵活，请看下面的例子（只能在 VC/VS 下运行）：

```c++
#include <iostream>
#include <typeinfo>
using namespace std;

class Base {};
struct STU {};

int main() {
    int n = 100;  //获取一个普通变量的类型信息
    const type_info &nInfo = typeid(n);
    cout << nInfo.name() << " | " << nInfo.hash_code() << endl;
    const type_info &dInfo = typeid(25.65);  // 获取一个字面量的类型信息
    cout << dInfo.name() << " | " << dInfo.hash_code() << endl;

    Base obj;  //获取一个对象的类型信息
    const type_info &objInfo = typeid(obj);
    cout << objInfo.name() << " | " << objInfo.hash_code() << endl;

    const type_info &baseInfo = typeid(Base);  //获取一个类的类型信息
    cout << baseInfo.name() << " | " << baseInfo.hash_code() << endl;

    const type_info &stuInfo = typeid(struct STU);  // 获取一个结构体的类型信息
    cout << stuInfo.name() << " | " << stuInfo.hash_code() << endl;

    const type_info &charInfo = typeid(char);  // 获取一个普通类型的类型信息
    cout << charInfo.name() << " | " << charInfo.hash_code() << endl;

    const type_info &expInfo = typeid(20 * 45 / 4.5);  //获取一个表达式的类型信息
    cout << expInfo.name() << " | " << expInfo.hash_code() << endl;

    return 0;
}
// i | 140703644541980
// d | 140703644542073
// 4Base | 4294983508
// 4Base | 4294983508
// 3STU | 4294983514
// c | 140703644541935
// d | 140703644542073
```

C++ 能获取到的类型信息非常有限，也没有统一的标准，如同“鸡肋”一般，

**大部分情况下我们只是使用重载过的 == 运算符来判断两个类型是否相同**

### 判断类型是否相等

typeid 运算符经常被用来判断两个类型是否相等

**内置类型的比较**

```c++
char *str;
int a = 2;
int b = 10;
float f;
```

![](../doc/class-9.png)

typeid 返回 type_info 对象的引用，而表达式`typeid(a) == typeid(b)`的结果为 true，可以说明，一个类型不管使用了多少次，编译器都只为它创建一个对象，所有 typeid 都返回这个对象的引用。

**类的比较**

```c++
class Base{};
class Derived: public Base{};
Base obj1;
Base *p1;
Derived obj2;
Derived *p2 = new Derived;
p1 = p2;
```

![](../doc/class-10.png)

表达式`typeid(*p1) == typeid(Base)`和`typeid(p1) == typeid(Base*)`的结果为 true 可以说明：即使将派生类[指针](http://c.biancheng.net/c/80/) p2 赋值给基类指针 p1，p1 的类型仍然为 Base*。
