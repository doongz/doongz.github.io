# 指针

将内存中字节的编号称为地址（Address）或指针（Pointer）

如何输出一个地址：

```c
#include <stdio.h>
int main(){
    int a = 100;
    char str[20] = "hello world";
    printf("%#X, %#X\n", &a, str);
    return 0;
}

// 0X6C9B448C, 0X6C9B4490
```

`%#X`表示以十六进制形式输出，并附带前缀`0X`。a 是一个变量，用来存放整数，需要在前面加`&`来获得它的地址；str 本身就表示字符串的首地址，不需要加`&`。

> C语言中有一个控制符`%p`，专门用来以十六进制形式输出地址，不过 %p 的输出格式并不统一，有的编译器带`0x`前缀，有的不带，所以此处我们并没有采用。

## 零、攻克C语言指针

常见指针变量的定义

| 定  义       | 含  义                                                       |
| ------------ | ------------------------------------------------------------ |
| int *p;      | p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。 |
| int **p;     | p 为二级指针，指向 int * 类型的数据。                        |
| int *p[n];   | p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 int *(p[n]); |
| int (*p)[n]; | p 为二维数组指针。                                           |
| int *p();    | p 是一个函数，它的返回值类型为 int *。                       |
| int (*p)();  | p 是一个函数指针，指向原型为 int func() 的函数。             |

- 指针变量可以进行加减运算，例如`p++`、`p+i`、`p-=i`。指针变量的加减运算并不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关。

- 给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数，例如`int *p = 1000;`是没有意义的，使用过程中一般会导致程序崩溃。

- 使用指针变量之前一定要初始化，否则就不能确定指针指向哪里，如果它指向的内存没有使用权限，程序就崩溃了。对于暂时没有指向的指针，建议赋值`NULL`。

- 两个指针变量可以相减。如果两个指针变量指向同一个数组中的某个元素，那么相减的结果就是两个指针之间相差的元素个数。

- 数组也是有类型的，数组名的本意是表示一组类型相同的数据。在定义数组时，或者和 sizeof、& 运算符一起使用时数组名才表示整个数组，表达式中的数组名会被转换为一个指向数组的指针。

指针数组、二维数组指针、函数指针等几种较为复杂的指针，它们的定义形式分别是：

```c
int *p1[6];           // 指针数组
int *(p2[6]);         // 指针数组，和上面的形式等价
int (*p3)[6];         // 二维数组指针
int (*p4)(int, int);  // 函数指针
```

**C语言标准规定，对于一个符号的定义，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析。对，从名字开始，不是从开头也不是从末尾，这是理解复杂指针的关键**！

对于初学者，有几种运算符的优先级非常容易混淆，它们的优先级从高到低依次是：

- 定义中被括号`( )`括起来的那部分。
- 后缀操作符：括号`( )`表示这是一个函数，方括号`[ ]`表示这是一个数组。
- 前缀操作符：星号`*`表示“指向xxx的指针”。

### 1、`int *p1[6];`

从 p1 开始理解，它的左边是 *，右边是 [ ]，[ ] 的优先级高于 *，所以编译器先解析`p1[6]`，p1 首先是一个拥有 6 个元素的数组，然后再解析`int *`，它用来说明数组元素的类型。从整体上讲，p1 是一个拥有 6 个 int * 元素的数组，也即指针数组。

### 2、`int (*p3)[6];`

从 p3 开始理解，( ) 的优先级最高，编译器先解析`(*p3)`，p3 首先是一个指针，剩下的`int [6]`是 p3 指向的数据的类型，它是一个拥有 6 个元素的一维数组。从整体上讲，p3 是一个指向拥有 6 个 int 元素数组的指针，也即二维数组指针。

> 为了能够通过指针来遍历数组元素，在定义数组指针时需要进行降维处理，例如三维数组指针实际指向的数据类型是二维数组，二维数组指针实际指向的数据类型是一维数组，一维数组指针实际指向的是一个基本类型；在表达式中，数组名也会进行同样的转换（下降一维）。

### 3、`int (*p4)(int, int);`

从 p4 开始理解，( ) 的优先级最高，编译器先解析`(*p4)`，p4 首先是一个指针，它后边的 ( ) 说明 p4 指向的是一个函数，括号中的`int, int`是参数列表，开头的`int`用来说明函数的返回值类型。整体来看，p4 是一个指向原型为`int func(int, int);`的函数的指针。

### 4、`char *(* c[10])(int **p);`

这个定义有两个名字，分别是 c 和 p，乍看起来 p 是指针变量的名字，不过很遗憾这是错误的。如果 p 是指针变量名，`c[10]`这种写法就又定义了一个新的名字，这让人匪夷所思。

以 c 作为变量的名字，先来看括号内部（绿色粗体）：

```c
char * (* c[10]) (int **p);
```

[ ] 的优先级高于 *，编译器先解析`c[10]`，c 首先是一个数组，它前面的`*`表明每个数组元素都是一个指针，只是还不知道指向什么类型的数据。整体上来看，`(* c[10])`说明 c 是一个指针数组，只是指针指向的数据类型尚未确定。

跳出括号，根据优先级规则（() 的优先级高于 *）应该先看右边（红色粗体）：

```c
char * (* c[10]) (int **p);
```

`( )`说明是一个函数，`int **p`是函数参数。

再看左边（橘黄色粗体）：

```c
char * (* c[10]) (int **p);
```

`char *`是函数的返回值类型。

从整体上看，我们可以将定义分成两部分：

```c
char * (* c[10]) (int **p);
```

绿色粗体表明 c 是一个指针数组，红色粗体表明指针指向的数据类型，合起来就是：c 是一个拥有 10 个元素的指针数组，每个指针指向一个原型为`char *func(int **p);`的函数。

## 一、指针变量的定义和使用

数据在内存中的地址也称为指针，如果一个变量存储了一份数据的指针，我们就称它为**指针变量**。

在C语言中，允许用一个变量来存放指针，这种变量称为指针变量。指针变量的值就是某份数据的地址，这样的一份数据可以是数组、字符串、函数，也可以是另外的一个普通变量或指针变量。

### 1、定义指针变量

定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号`*`，格式为：

```c
datatype *name;
datatype *name = value;
```

`*`表示这是一个指针变量，`datatype`表示该指针变量所指向的数据的类型 。例如：

```c
int *p1;
int a = 100;
int *p_a = &a;
```

和普通变量一样，指针变量也可以被多次写入，只要你想，随时都能够改变指针变量的值，请看下面的代码：

```c
//定义普通变量
float a = 99.5, b = 10.6;
char c = '@', d = '#';
//定义指针变量
float *p1 = &a;
char *p2 = &c;
//修改指针变量的值
p1 = &b;
p2 = &d;
```

`*`是一个特殊符号，表明一个变量是指针变量，定义 p1、p2 时必须带`*`。而给 p1、p2 赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上`*`，后边可以像使用普通变量一样来使用指针变量。也就是说，**定义指针变量时必须带`*`，给指针变量赋值时不能带`*`**。

指针变量也可以连续定义，例如：

```c
int *a, *b, *c;  //a、b、c 的类型都是 int*
```

### 2、通过指针变量取得数据

指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为：

```
*pointer;
```

这里的`*`称为指针运算符，用来取得某个地址上的数据，

```c
#include <stdio.h>
int main(){
    int a = 15;
    int *p = &a;
    printf("%d, %d\n", a, *p);  //两种方式都可以输出a的值
    return 0;
}
```

### 3、修改内存上的数据

```c
#include <stdio.h>
int main(){
    int a = 15, b = 99, c = 222;
    int *p = &a;  //定义指针变量
    *p = b;  //通过指针变量修改内存上的数据
    c = *p;  //通过指针变量获取内存上的数据
    printf("%d, %d, %d, %d\n", a, b, c, *p);
    return 0;
}
// 99, 99, 99, 99
```

【示例】通过指针交换两个变量的值。

```c
#include <stdio.h>

int main(){
    int a = 100, b = 999, temp;
    int *pa = &a, *pb = &b;
    printf("a=%d, b=%d\n", a, b);
    
    /*****开始交换*****/
    temp = *pa;  //将a的值先保存起来
    *pa = *pb;  //将b的值交给a
    *pb = temp;  //再将保存起来的a的值交给b
    /*****结束交换*****/
    
    printf("a=%d, b=%d\n", a, b);
    return 0;
}
```

### 4、关于 * 和 & 的谜题

假设有一个 int 类型的变量 a，pa 是指向它的指针，那么`*&a`和`&*pa`分别是什么意思呢？

`*&a`可以理解为`*(&a)`，`&a`表示取变量 a 的地址（等价于 pa），`*(&a)`表示取这个地址上的数据（等价于 *pa），绕来绕去，又回到了原点，`*&a`仍然等价于 a。

`&*pa`可以理解为`&(*pa)`，`*pa`表示取得 pa 指向的数据（等价于 a），`&(*pa)`表示数据的地址（等价于 &a），所以`&*pa`等价于 pa。

### 5、对星号`*`的总结

在我们目前所学到的语法中，星号`*`主要有三种用途：

- 表示乘法，例如`int a = 3, b = 5, c;  c = a * b;`，这是最容易理解的。
- 表示定义一个指针变量，以和普通变量区分开，例如`int a = 100;  int *p = &a;`。
- 表示获取指针指向的数据，是一种间接操作，例如`int a, b, *p = &a;  *p = 100;  b = *p;`。

## 二、指针变量的运算

指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如加法、减法、比较等，

```c
#include <stdio.h>
int main() {
    int a = 10, *pa = &a, *paa = &a;
    double b = 99.9, *pb = &b;
    char c = '@', *pc = &c;

    //最初的值
    printf("&a=%#X, &b=%#X, &c=%#X\n", &a, &b, &c);
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);

    //加法运算
    pa++;
    pb++;
    pc++;
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);

    //减法运算
    pa -= 2;
    pb -= 2;
    pc -= 2;
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);
    
    //比较运算
    if (pa == paa) {
        printf("%d\n", *paa);
    } else {
        printf("%d\n", *pa);
    }
    return 0;
}

// &a=0X15E79EFC, &b=0X15E79F00, &c=0X15E79EFB
// pa=0X15E79EFC, pb=0X15E79F00, pc=0X15E79EFB
// pa=0X15E79F00, pb=0X15E79F08, pc=0X15E79EFC
// pa=0X15E79EF8, pb=0X15E79EF8, pc=0X15E79EFA
// 1087416381
```

从运算结果可以看出：pa、pb、pc 每次加 1，它们的地址分别增加 4、8、1，正好是 int、double、char 类型的长度；减 2 时，地址分别减少 8、16、2，正好是 int、double、char 类型长度的 2 倍

**指针变量加减运算的结果跟数据类型的长度有关，而不是简单地加 1 或减 1**

下面的例子是一个反面教材，警告读者不要尝试通过指针获取下一个变量的地址：

```c
#include <stdio.h>
int main(){
    int a = 1, b = 2, c = 3;
    int *p = &c;
    int i;
    for(i=0; i<8; i++){
        printf("%d, ", *(p+i) );
    }
    return 0;
}
// 3, 1, 1, 2, 1596383328, 32767, -8460800, -1106343347,
```

变量 a、b、c 并不挨着

不能对指针变量进行乘法、除法、取余等其他运算，除了会发生语法错误，也没有实际的含义。

## 三、数组指针（指向数组的指针）

数组（Array）是一系列具有相同类型的数据的集合，每一份数据叫做一个数组元素（Element）。数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存。以`int arr[] = { 99, 15, 100, 888, 252 };`为例，该数组在内存中的分布如下图所示：

![img](http://c.biancheng.net/uploads/allimg/190114/1J35014B-0.jpg)

**定义数组时，要给出数组名和数组长度，数组名可以认为是一个指针，它指向数组的第 0 个元素**。在C语言中，我们将第 0 个元素的地址称为数组的首地址。以上面的数组为例，下图是 arr 的指向：

![img](http://c.biancheng.net/uploads/allimg/190114/1J3506331-1.jpg)

> 数组名的本意是表示整个数组，也就是表示多份数据的集合，但在使用过程中经常会转换为指向数组第 0 个元素的指针，所以上面使用了“认为”一词，表示数组名和数组首地址并不总是等价。

例子演示了如何以指针的方式遍历数组元素：

```c
#include <stdio.h>
int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int len = sizeof(arr) / sizeof(int);  //求数组长度
    int i;
    for(i=0; i<len; i++){
        printf("%d  ", *(arr+i) );  //*(arr+i)等价于arr[i]
    }
    printf("\n");
    return 0;
}
```

> arr 是`int*`类型的指针，每次加 1 时它自身的值会增加 sizeof(int)，加 i 时自身的值会增加 sizeof(int) * i

可以定义一个指向数组的指针，例如：

```c
int arr[] = { 99, 15, 100, 888, 252 };
int *p = arr;
```

arr 本身就是一个指针，可以直接赋值给指针变量 p。arr 是数组第 0 个元素的地址，所以`int *p = arr;`也可以写作`int *p = &arr[0];`。也就是说，arr、p、&arr[0] 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头。

如果一个指针指向了数组，我们就称它为**数组指针**（Array Pointer）。

更改上面的代码，使用数组指针来遍历数组元素：

```c
#include <stdio.h>

int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int i, *p = arr, len = sizeof(arr) / sizeof(int);
    for(i=0; i<len; i++){
        printf("%d  ", *(p+i) );
    }
    printf("\n");
    return 0;
}
```

数组在内存中只是数组元素的简单排列，没有开始和结束标志，在求数组的长度时不能使用`sizeof(p) / sizeof(int)`，因为 p 只是一个指向 int 类型的指针，编译器并不知道它指向的到底是一个整数还是一系列整数（数组），所以 sizeof(p) 求得的是 p 这个指针变量本身所占用的字节数，而不是整个数组占用的字节数。

让 p 指向数组中的第二个元素：

```c
#include <stdio.h>

int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int *p = &arr[2];  //也可以写作 int *p = arr + 2;
    printf("%d, %d, %d, %d, %d\n", *(p-2), *(p-1), *p, *(p+1), *(p+2) );
    return 0;
}
// 99, 15, 100, 888, 252
```

### 1、访问数组元素

引入数组指针后，我们就有两种方案来访问数组元素了，一种是使用下标，另外一种是使用指针。

#### 1) 使用下标

也就是采用 arr[i] 的形式访问数组元素。如果 p 是指向数组 arr 的指针，那么也可以使用 p[i] 来访问数组元素，它等价于 arr[i]。

#### 2) 使用指针

也就是使用 *(p+i) 的形式访问数组元素。另外数组名本身也是指针，也可以使用 *(arr+i) 来访问数组元素，它等价于 *(p+i)。

不管是数组名还是数组指针，都可以使用上面的两种方式来访问数组元素。不同的是，数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变。也就是说，数组名只能指向数组的开头，而数组指针可以先指向数组开头，再指向其他元素。

借助自增运算符来遍历数组元素：

```c
#include <stdio.h>
int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int i, *p = arr, len = sizeof(arr) / sizeof(int);
    for(i=0; i<len; i++){
        printf("%d  ", *p++ );
    }
    printf("\n");
    return 0;
}
```

### 2、字符串指针

C语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "hello world";
    int len = strlen(str), i;
    //直接输出字符串
    printf("%s\n", str);
    //每次输出一个字符
    for (i = 0; i < len; i++) {
        printf("%c", str[i]);
    }
    printf("\n");
    return 0;
}
```

字符数组归根结底还是一个数组，使用指针的方式来输出字符串

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "hello world";
    char *pstr = str;
    int len = strlen(str), i;
    //使用*(pstr+i)
    for (i = 0; i < len; i++) {
        printf("%c", *(pstr + i));
    }
    printf("\n");
    //使用pstr[i]
    for (i = 0; i < len; i++) {
        printf("%c", pstr[i]);
    }
    printf("\n");
    //使用*(str+i)
    for (i = 0; i < len; i++) {
        printf("%c", *(str + i));
    }
    printf("\n");
    return 0;
}
```

除了字符数组，C语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串，例如：

```c
char *str = "hello world";

char *str;
str = "hello world";
```

输出这种字符串：

```c
#include <stdio.h>
#include <string.h>
int main(){
    char *str = "hello world";
    int len = strlen(str), i;
   
    //直接输出字符串
    printf("%s\n", str);
    //使用*(str+i)
    for(i=0; i<len; i++){
        printf("%c", *(str+i));
    }
    printf("\n");
    //使用str[i]
    for(i=0; i<len; i++){
        printf("%c", str[i]);
    }
    printf("\n");
    return 0;
}
```

这一切看起来和字符数组是多么地相似，它们都可以使用`%s`输出整个字符串，都可以使用`*`或`[ ]`获取单个字符，这两种表示字符串的方式是不是就没有区别了呢？

**有！它们最根本的区别是在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限**。

到底使用字符数组还是字符串常量？

- 在编程过程中如果只涉及到对字符串的读取，那么字符数组和字符串常量都能够满足要求；
- 如果有写入（修改）操作，那么只能使用字符数组，不能使用字符串常量。

### 3、数组灵活多变的访问形式

C语言中的指针使得代码的编写非常灵活，如果指针能够和数组结合，那将会有更多的“花招”

```c
#include <stdio.h>
int main() {
    char str[20] = "hello world";

    char *s1 = str;
    char *s2 = str + 2;

    char c1 = str[4];
    char c2 = *str;
    char c3 = *(str + 4);
    char c4 = *str + 2;
    char c5 = (str + 1)[5];

    int num1 = *str + 2;
    long num2 = (long)str;
    long num3 = (long)(str + 2);
    printf("  s1 = %s\n", s1);
    printf("  s2 = %s\n", s2);
    printf("  c1 = %c\n", c1);
    printf("  c2 = %c\n", c2);
    printf("  c3 = %c\n", c3);
    printf("  c4 = %c\n", c4);
    printf("  c5 = %c\n", c5);

    printf("num1 = %d\n", num1);
    printf("num2 = %ld\n", num2);
    printf("num3 = %ld\n", num3);
    return 0;
}
//   s1 = hello world
//   s2 = llo world
//   c1 = o
//   c2 = h
//   c3 = o
//   c4 = j
//   c5 = w
// num1 = 106
// num2 = 140702053822608
// num3 = 140702053822610
```

\1) str 既是数组名称，也是一个指向字符串的指针；指针可以参加运算，加 1 相当于数组下标加 1。

printf() 输出字符串时，要求给出一个起始地址，并从这个地址开始输出，直到遇见字符串结束标志`\0`。s1 为字符串 str 第 0 个字符的地址，s2 为第 2 个字符的地址，所以 printf() 的结果分别为 c.biancheng.net 和 biancheng.net。

\2) 指针可以参加运算，str+4 表示第 4 个字符的地址，c3 = *(str+4) 表示第4个字符，即 'a'。

\3) 其实，数组元素的访问形式可以看做 address[offset]，address 为起始地址，offset 为偏移量：`c1 = str[4]`表示以地址 str 为起点，向后偏移4个字符，为 'a'；`c5 = (str+1)[5]`表示以地址 str+1 为起点，向后偏移5个字符，等价于str[6]，为 'c'。

\4) 字符与整数运算时，先转换为整数（字符对应的ASCII码）。num1 与 c4 右边的表达式相同，对于 num1，*str+2 == 'c'+2 == 99+2 == 101，即 num1 的值为 101，对于 c4，101 对应的字符为 ‘e’，所以 c4 的输出值为 'e'。

\5) num2 和 num3 分别为字符串 str 的首地址和第 2 个元素的地址

```c
#include <stdio.h>
#include <stdlib.h>
int main() {
    char str[20] = {0};
    int i;
    for (i = 0; i < 10; i++) {
        *(str + i) = 97 + i;  // 97为字符a的ASCII码值
    }

    printf("%s\n", str);
    printf("%s\n", str + 2);
    printf("%c\n", str[2]);
    printf("%c\n", (str + 2)[2]);

    return 0;
}
// abcdefghij
// cdefghij
// c
// e
```

## 四、指针变量作为函数参数

### 1、指针变量作参数

```c
#include <stdio.h>
void swap(int *p1, int *p2) {
    int temp;  //临时变量
    temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}
int main() {
    int a = 66, b = 99;
    swap(&a, &b);
    printf("a = %d, b = %d\n", a, b);
    return 0;
}
```

### 2、用数组作函数参数

参数 intArr 仅仅是一个数组指针，在函数内部无法通过这个指针获得数组长度，必须将数组长度作为函数参数传递到函数内部。

```c
#include <stdio.h>

int max(int *intArr, int len) {
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for (i = 1; i < len; i++) {
        if (maxValue < intArr[i]) {
            maxValue = intArr[i];
        }
    }
    return maxValue;
}

int main() {
    int nums[6], i;
    int len = sizeof(nums) / sizeof(int);
    //读取用户输入的数据并赋值给数组元素
    for (i = 0; i < len; i++) {
        scanf("%d", nums + i);
    }
    printf("Max value is %d!\n", max(nums, len));
    return 0;
}
```

用数组做函数参数时，参数也能够以“真正”的数组形式给出。

```c
int max(int intArr[6], int len){
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for(i=1; i<len; i++){
        if(maxValue < intArr[i]){
            maxValue = intArr[i];
        }
    }
    return maxValue;
}
```

简写

```c
int max(int intArr[], int len){
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for(i=1; i<len; i++){
        if(maxValue < intArr[i]){
            maxValue = intArr[i];
        }
    }
    return maxValue;
}
```

实际上这两种形式的数组定义都是假象，不管是`int intArr[6]`还是`int intArr[]`都不会创建一个数组出来，编译器也不会为它们分配内存，实际的数组是不存在的，它们最终还是会转换为`int *intArr`这样的指针。这就意味着，两种形式都不能将数组的所有元素“一股脑”传递进来，大家还得规规矩矩使用数组指针。

`int intArr[6]`这种形式只能说明函数期望用户传递的数组有 6 个元素，并不意味着数组只能有 6 个元素，真正传递的数组可以有少于或多于 6 个的元素。

需要强调的是，不管使用哪种方式传递数组，都不能在函数内部求得数组长度，因为 intArr 仅仅是一个指针，而不是真正的数组，所以必须要额外增加一个参数来传递数组长度。

C语言为什么不允许直接传递数组的所有元素，而必须传递数组指针呢？

**参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上**。

对于像 int、float、char 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行内存拷贝有可能是一个漫长的过程，会严重拖慢程序的效率，为了防止技艺不佳的程序员写出低效的代码，C语言没有从语法上支持数据集合的直接赋值。

## 五、指针作为函数返回值

C语言允许函数的返回值是一个指针（地址），我们将这样的函数称为**指针函数**。

```c
#include <stdio.h>
#include <string.h>

char *strlong(char *str1, char *str2) {
    if (strlen(str1) >= strlen(str2)) {
        return str1;
    } else {
        return str2;
    }
}

int main() {
    char str1[30] = "hello";
    char str2[30] = "hello world";
    char *str;
    printf(str1);
    printf("\n");
    printf(str2);
    printf("\n");
    str = strlong(str1, str2);
    printf("Longer string: %s\n", str);
    return 0;
}

// hello
// hello world
// Longer string: hello world
```

用指针作为函数返回值时需要注意的一点是:

**函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误**。

```c
#include <stdio.h>

int *func() {
    int n = 100;
    return &n;
}

int main() {
    int *p = func(), n;
    n = *p;
    printf("value = %d\n", n);
    return 0;
}

// a.c: In function ‘func’:
// a.c:5:12: warning: function returns address of local variable [-Wreturn-local-addr]
//      return &n;
```

## 六、二级指针（指向指针的指针）

指针可以指向一份普通类型的数据，例如 int、double、char 等，也可以指向一份指针类型的数据，例如 int *、double *、char * 等。

**如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针**。

假设有一个 int 类型的变量 a，p1是指向 a 的指针变量，p2 又是指向 p1 的指针变量，它们的关系如下图所示：
![C语言二级指针（指向指针的指针）演示图](http://c.biancheng.net/uploads/allimg/190117/1544314910-0.jpg)

将这种关系转换为C语言代码：

```c
int a = 100;
int *p1 = &a;
int **p2 = &p1;
```

指针变量也是一种变量，也会占用存储空间，也可以使用`&`获取它的地址。C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号`*`。p1 是一级指针，指向普通类型的数据，定义时有一个`*`；p2 是二级指针，指向一级指针 p1，定义时有两个`*`。

如果我们希望再定义一个三级指针 p3，让它指向 p2，那么可以这样写：

```c
int ***p3 = &p2
```

四级指针也是类似的道理：

```c
int ****p4 = &p3;
```

实际开发中会经常使用一级指针和二级指针，几乎用不到高级指针。

想要获取指针指向的数据时，一级指针加一个`*`，二级指针加两个`*`，三级指针加三个`*`，以此类推，请看代码：

```c
#include <stdio.h>

int main() {
    int a = 100;
    int *p1 = &a;
    int **p2 = &p1;
    int ***p3 = &p2;
    printf("%d, %d, %d, %d\n", a, *p1, **p2, ***p3);
    printf("&p2 = %#X, p3 = %#X\n", &p2, p3);
    printf("&p1 = %#X, p2 = %#X, *p3 = %#X\n", &p1, p2, *p3);
    printf(" &a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\n", &a, p1, *p2, **p3);
    return 0;
}
```

运行结果：

```
100, 100, 100, 100
&p2 = 0XC233DA68, p3 = 0XC233DA68
&p1 = 0XC233DA60, p2 = 0XC233DA60, *p3 = 0XC233DA60
 &a = 0XC233DA5C, p1 = 0XC233DA5C, *p2 = 0XC233DA5C, **p3 = 0XC233DA5C
```

以三级指针 p3 为例来分析上面的代码。`***p3`等价于`*(*(*p3))`。*p3 得到的是 p2 的值，也即 p1 的地址；*(*p3) 得到的是 p1 的值，也即 a 的地址；经过三次“取值”操作后，*(*(*p3)) 得到的才是 a 的值。

假设 a、p1、p2、p3 的地址分别是 0X00A0、0X1000、0X2000、0X3000，它们之间的关系可以用下图来描述：
![C语言多级指针演示图](http://c.biancheng.net/uploads/allimg/190117/15443163P-1.jpg)

方框里面是变量本身的值，方框下面是变量的地址。

## 七、空指针NULL以及void指针

### 1、空指针 NULL

一个指针变量可以指向计算机中的任何一块内存，不管该内存有没有被分配，也不管该内存有没有使用权限，只要把地址给它，它就可以指向，C语言没有一种机制来保证指向的内存的正确性，程序员必须自己提高警惕。

很多初学者会在无意间对没有初始化的指针进行操作，这是非常危险的，请看下面的例子：

```c
#include <stdio.h>

int main() {
    char *str;
    gets(str);
    printf("%s\n", str);
    return 0;
}
```

这段程序没有语法错误，能够通过编译和链接，但当用户输入完字符串并按下回车键时就会发生错误，在 Linux 下表现为段错误（Segment Fault）

**强烈建议对没有初始化的指针赋值为 NULL**，例如：

```c
char *str = NULL;
```

NULL 是“零值、等于零”的意思，在C语言中表示空指针。从表面上理解，空指针是不指向任何数据的指针，是无效指针，程序使用它不会产生效果。

> 注意区分大小写，null 没有任何特殊含义，只是一个普通的标识符。

很多库函数都对传入的指针做了判断，如果是空指针就不做任何操作，或者给出提示信息。

我们在自己定义的函数中也可以进行类似的判断，例如：

```c
void func(char *p) {
    if (p == NULL) {
        printf("(null)\n");
    } else {
        printf("%s\n", p);
    }
}
```

这样能够从很大程度上增加程序的健壮性，防止对空指针进行无意义的操作。

其实，NULL 是在`stdio.h`中定义的一个宏，它的具体内容为：

```c
#define NULL ((void *)0)
```

`(void *)0`表示把数值 0 强制转换为`void *`类型，最外层的`( )`把宏定义的内容括起来，防止发生歧义。从整体上来看，NULL 指向了地址为 0 的内存，而不是前面说的不指向任何数据。

在进程的虚拟地址空间中，最低地址处有一段内存区域被称为保留区，这个区域不存储有效数据，也不能被用户程序访问，将 NULL 指向这块区域很容易检测到违规指针。

注意，C语言没有规定 NULL 的指向，只是大部分标准库约定成俗地将 NULL 指向 0，所以不要将 NULL 和 0 等同起来，例如下面的写法是不专业的：

```c
int *p = 0;
```

而应该坚持写为：

```c
int *p = NULL;
```

> 注意 NULL 和 NUL 的区别：NULL 表示空指针，是一个宏定义，可以在代码中直接使用。而 NUL 表示字符串的结束标志 '\0'，它是ASCII码表中的第 0 个字符。NUL 没有在C语言中定义，仅仅是对 '\0' 的称呼，不能在代码中直接使用。

### 2、void 指针

对于空指针 NULL 的宏定义内容，上面只是对`((void *)0)`作了粗略的介绍，这里重点说一下`void *`的含义。**void 用在函数定义中可以表示函数没有返回值或者没有形式参数，用在这里表示指针指向的数据的类型是未知的**。

也就是说，**`void *`表示一个有效指针，它确实指向实实在在的数据，只是数据的类型尚未确定，在后续使用过程中一般要进行强制类型转换**。

C语言动态内存分配函数 malloc() 的返回值就是`void *`类型，在使用时要进行强制类型转换，请看下面的例子：

```c
#include <stdio.h>

int main() {
    //分配可以保存30个字符的内存，并把返回的指针转换为 char *
    char *str = (char *)malloc(sizeof(char) * 30);
    gets(str);
    printf("%s\n", str);
    return 0;
}
```

理解`void *`，它不是空指针的意思，而是实实在在的指针，只是指针指向的内存中不知道保存的是什么类型的数据。

## 八、数组和指针绝不等价，数组是另外一种类型

### 1、数组类型是`int [6]`，指针类型是`int *`

**数组和指针不等价的一个典型案例就是求数组的长度，这个时候只能使用数组名，不能使用数组指针**

```c
#include <stdio.h>

int main() {
    int a[6] = {0, 1, 2, 3, 4, 5};
    int *p = a;
    int len_a = sizeof(a) / sizeof(int);
    int len_p = sizeof(p) / sizeof(int);
    printf("len_a = %d, len_p = %d\n", len_a, len_p);
    return 0;
}
// len_a = 6, len_p = 2
```

**数组是一系列数据的集合，没有开始和结束标志，p 仅仅是一个指向 int 类型的指针，编译器不知道它指向的是一个整数还是一堆整数，对 p 使用 sizeof 求得的是指针变量本身的长度**。也就是说，编译器并没有把 p 和数组关联起来，p 仅仅是一个指针变量，不管它指向哪里，sizeof 求得的永远是它本身所占用的字节数。

站在编译器的角度讲，变量名、数组名都是一种符号，它们最终都要和数据绑定起来。变量名用来指代一份数据，数组名用来指代一组数据（数据集合），它们都是有类型的，以便推断出所指代的数据的长度。

对，**数组也有类型**，这是很多读者没有意识到的，大部分C语言书籍对这一点也含糊其辞！我们可以将 int、float、char 等理解为基本类型，将数组理解为由基本类型派生得到的稍微复杂一些的类型。sizeof 就是根据符号的类型来计算长度的。

- 对于数组 a，它的类型是`int [6]`，表示这是一个拥有 6 个 int 数据的集合，1 个 int 的长度为 4，6 个 int 的长度为 4×6 = 24，sizeof 很容易求得。

- 对于指针变量 p，它的类型是`int *`，在 32 位环境下长度为 4，在 64 位环境下长度为 8。

归根结底，a 和 p 这两个符号的类型不同，指代的数据也不同，它们不是一码事，sizeof 是根据符号类型来求长度的，a 和 p 的类型不同，求得的长度自然也不一样。

对于二维数组，也是类似的道理，例如 `int a[3][3]={1, 2, 3, 4, 5, 6, 7, 8, 9};`，它的类型是`int [3][3]`，长度是 4×3×3 = 36，读者可以亲自测试。

### 2、数组在什么时候会转换为指针

在使用过程中，数组名有时候会转换为指向数据集合的指针（地址），而不是表示数据集合本身

**C语言标准规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、sizeof 或 & 的操作数时，它才表示整个数组本身，在其他的表达式中，数组名会被转换为指向第 0 个元素的指针（地址）**。

#### 1）再谈数组下标[ ]

C语言标准还规定，数组下标与指针的偏移量相同。通俗地理解，就是对数组下标的引用总是可以写成“一个指向数组的起始地址的指针加上偏移量”。假设现在有一个数组 a 和指针变量 p，它们的定义形式为：

```c
int a = {1, 2, 3, 4, 5}, *p, i = 2;
```

读者可以通过以下任何一种方式来访问 a[i]：

```c
p = a;
p[i];

p = a;
*(p + i);

p = a + i;
*p;
```

对数组的引用 a[i] 在编译时总是被编译器改写成`*(a+i)`的形式，C语言标准也要求编译器必须具备这种行为。

取下标操作符`[ ]`是建立在指针的基础上，它的作用是使一个指针和一个整数相加，产生出一个新的指针，然后从这个新指针（新地址）上取得数据；假设指针的类型为`T *`，所产生的结果的类型就是`T`。

取下标操作符的两个操作数是可以交换的，它并不在意操作数的先后顺序，就像在加法中 3+5 和 5+3 并没有什么不一样。以上面的数组 a 为例，如果希望访问第 3 个元素，那么可以写作`a[3]`，也可以写作`3[a]`，这两种形式都是正确的，只不过后面的形式从不曾使用，它除了可以把初学者搞晕之外，实在没有什么实际的意义。

> a[3] 等价于 *(a + 3)，3[a] 等价于 *(3 + a)，仅仅是把加法的两个操作数调换了位置。

使用下标时，编译器会自动把下标的步长调整到数组元素的大小。数组 a 中每个元素都是 int 类型，长度为 4 个字节，那么`a[i+1]`和`a[i]`在内存中的距离是 4（而不是 1）。

#### 2）数组作函数参数

C语言标准规定，作为“类型的数组”的形参应该调整为“类型的指针”。**在函数形参定义这个特殊情况下，编译器必须把数组形式改写成指向数组第 0 个元素的指针形式。编译器只向函数传递数组的地址，而不是整个数组的拷贝**。

这种隐式转换意味着下面三种形式的函数定义是完全等价的：

```c
void func(int *parr){ ...... }
void func(int arr[]){ ...... }
void func(int arr[5]){ ...... }
```

**在函数内部，arr 会被转换成一个指针变量，编译器为 arr 分配 4 个字节的内存**，用 sizeof(arr) 求得的是指针变量的长度，而不是数组长度。要想在函数内部获得数组长度必须额外增加一个参数，在调用函数之前求得数组长度

参数传递是一次赋值的过程，赋值也是一个表达式，函数调用时不管传递的是数组名还是数组指针，效果都是一样的，相当于给一个指针变量赋值。

把作为形参的数组和指针等同起来是出于效率方面的考虑。数组是若干类型相同的数据的集合，数据的数目没有限制，可能只有几个，也可能成千上万，如果要传递整个数组，无论在时间还是内存空间上的开销都可能非常大。而且绝大部分情况下，我们其实并不需要整个数组的拷贝，我们只想告诉函数在那一时刻对哪个特定的数组感兴趣。

#### 3）关于数组和指针可交换性的总结

- 用 a[i] 这样的形式对数组进行访问总是会被编译器改写成（或者说解释为）像 *(a+i) 这样的指针形式。
- 指针始终是指针，它绝不可以改写成数组。你可以用下标形式访问数组，一般都是指针作为函数参数时，而且你知道实际传递给函数的是一个数组。
- 在特定的环境中，也就是数组作为函数形参，也只有这种情况，一个数组可以看做是一个指针。作为函数形参的数组始终会被编译器修改成指向数组第一个元素的指针。
- 当希望向函数传递数组时，可以把函数参数定义为数组形式（可以指定长度也可以不指定长度），也可以定义为指针。不管哪种形式，在函数内部都要作为指针变量对待。

## 九、指针数组（数组每个元素都是指针）

如果一个数组中的所有元素保存的都是指针，那么我们就称它为指针数组。指针数组的定义形式一般为：

```c
dataType *arrayName[length];
```

`[ ]`的优先级高于`*`，该定义形式应该理解为：

```c
dataType *(arrayName[length]);
```

括号里面说明`arrayName`是一个数组，包含了`length`个元素，括号外面说明每个元素的类型为`dataType *`。

除了每个元素的数据类型不同，指针数组和普通数组在其他方面都是一样的，下面是一个简单的例子：

```c
#include <stdio.h>
int main() {
    int a = 16, b = 932, c = 100;
    //定义一个指针数组
    int *arr[3] = {&a, &b, &c};//也可以不指定长度，直接写作 int *arr[]
    //定义一个指向指针数组的指针
    int **parr = arr;
    printf("%d, %d, %d\n", *arr[0], *arr[1], *arr[2]);
    printf("%d, %d, %d\n", **(parr+0), **(parr+1), **(parr+2));
    return 0;
}
```

指针数组还可以和字符串数组结合使用，请看下面的例子：

```c
#include <stdio.h>
int main(){
    char *str[3] = {
        "python",
        "c++",
        "golang"
    };
    printf("%s\n%s\n%s\n", str[0], str[1], str[2]);
    return 0;
}
```

需要注意的是，字符数组 str 中存放的是字符串的首地址，不是字符串本身，字符串本身位于其他的内存区域，和字符数组是分开的。

也只有当指针数组中每个元素的类型都是`char *`时，才能像上面那样给指针数组赋值，其他类型不行。

为了便于理解，可以将上面的字符串数组改成下面的形式，它们都是等价的。

```c
#include <stdio.h>
int main(){
    char *str0 = "python";
    char *str1 = "c++";
    char *str2 = "golang";
    char *str[3] = {str0, str1, str2};
    printf("%s\n%s\n%s\n", str[0], str[1], str[2]);
    return 0;
}
```

## 十、二维数组指针（指向二维数组的指针）

二维数组在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的，它们之间没有“缝隙”。以下面的二维数组 a 为例：

```c
int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
```

从概念上理解，a 的分布像一个矩阵：

```
0   1   2   3
4   5   6   7
8   9  10  11
```

但在内存中，a 的分布是一维线性的，整个数组占用一块连续的内存：
![二维数组在内存中的存储](http://c.biancheng.net/uploads/allimg/190117/16011C417-0.jpg)

C语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4) = 48 个字节。

C语言允许把一个二维数组分解成多个一维数组来处理。对于数组 a，它可以分解成三个一维数组，即 a[0]、a[1]、a[2]。每一个一维数组又包含了 4 个元素，例如 a[0] 包含 `a[0][0]、a[0][1]、a[0][2]、a[0][3]`

假设数组 a 中第 0 个元素的地址为 1000，那么每个一维数组的首地址如下图所示：
![把二维数组拆解成一维数组](http://c.biancheng.net/uploads/allimg/190117/1601164D5-1.png)

为了更好的理解指针和二维数组的关系，我们先来定义一个指向 a 的指针变量 p：

```c
int (*p)[4] = a;
```

括号中的`*`表明 p 是一个指针，它指向一个数组，数组的类型为`int [4]`，这正是 a 所包含的每个一维数组的类型。

`[ ]`的优先级高于`*`，`( )`是必须要加的，如果赤裸裸地写作`int *p[4]`，那么应该理解为`int *(p[4])`，p 就成了一个指针数组，而不是二维数组指针。

对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关，p 指向的数据类型是`int [4]`，那么`p+1`就前进 4×4 = 16 个字节，`p-1`就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说，`p+1`会使得指针指向二维数组的下一行，`p-1`会使得指针指向数组的上一行。

**数组名 a 在表达式中也会被转换为和 p 等价的指针**！

下面我们就来探索一下如何使用指针 p 来访问二维数组中的每个元素。按照上面的定义：

- `p`指向数组 a 的开头，也即第 0 行；`p+1`前进一行，指向第 1 行。

- `*(p+1)`表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素，下面的运行结果有力地证明了这一点：

```c
#include <stdio.h>
int main(){
    int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
    int (*p)[4] = a;
    printf("%d\n", sizeof(*(p+1)));
    return 0;
}
// 16
```

- `*(p+1)+1`表示第 1 行第 1 个元素的地址。

`*(p+1)`单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；就像一维数组的名字，在定义时或者和 sizeof、& 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 0 个元素的指针。

- `*(*(p+1)+1)`表示第 1 行第 1 个元素的值。

根据上面的结论，可以很容易推出以下的等价关系：

```c
a+i == p+i
a[i] == p[i] == *(a+i) == *(p+i)
a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j)
```

### 【实例】使用指针遍历二维数组

```c
#include <stdio.h>
int main(){
    int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};
    int(*p)[4];
    int i,j;
    p=a;
    for(i=0; i<3; i++){
        for(j=0; j<4; j++) printf("%2d  ",*(*(p+i)+j));
        printf("\n");
    }
    return 0;
}
```

### 指针数组和二维数组指针的区别

指针数组和二维数组指针在定义时非常相似，只是括号的位置不同：

```c
int *(p1[5]);  //指针数组，可以去掉括号直接写作 int *p1[5];
int (*p2)[5];  //二维数组指针，不能去掉括号
```

指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1 为例，在32位环境下它占用 4×5 = 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。

## 十一、函数指针（指向函数的指针）

**一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似**。

**我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针**。

函数指针的定义形式为：

```c
returnType (*pointerName)(param list);
```

returnType 为函数返回值类型，pointerName 为指针名称，param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。

注意`( )`的优先级高于`*`，第一个括号不能省略，如果写作`returnType *pointerName(param list);`就成了函数原型，它表明函数的返回值类型为`returnType *`。

【实例】用指针来实现对函数的调用。

```c
#include <stdio.h>

//返回两个数中较大的一个
int max(int a, int b){
    return a>b ? a : b;
}

int main(){
    int x, y, maxval;
    //定义函数指针
    int (*pmax)(int, int) = max;  //也可以写作int (*pmax)(int a, int b)
    
    printf("Input two numbers:");
    scanf("%d %d", &x, &y);
    maxval = (*pmax)(x, y);
    printf("Max value: %d\n", maxval);
    return 0;
}
```

第 14 行代码对函数进行了调用。pmax 是一个函数指针，在前面加 * 就表示对它指向的函数进行调用。注意`( )`的优先级高于`*`，第一个括号不能省略。

## 十二、回调函数

**函数指针作为某个函数的参数**

函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。

**实例**

实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。

实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。

populate_array 将调用 5 次回调函数，并将回调函数的返回值赋值给数组。

```c
#include <stdio.h>
#include <stdlib.h>

// 回调函数
void populate_array(int *array, size_t arraySize, int (*getNextValue)(void)) {
  for (size_t i = 0; i < arraySize; i++)
    array[i] = getNextValue();
}

// 获取随机值
int getNextRandomValue(void) {
  return rand();
}

int main(void) {
  int myarray[10];
  /* getNextRandomValue 不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了 int , 而不是函数指针*/
  populate_array(myarray, 5, getNextRandomValue);
  for (int i = 0; i < 5; i++) {
    printf("%d ", myarray[i]);
  }
  printf("\n");
  return 0;
}

// 1804289383 846930886 1681692777 1714636915 1957747793
```
