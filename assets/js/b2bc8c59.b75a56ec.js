"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[73408],{3905:(n,_,e)=>{e.d(_,{Zo:()=>d,kt:()=>g});var r=e(67294);function t(n,_,e){return _ in n?Object.defineProperty(n,_,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[_]=e,n}function i(n,_){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);_&&(r=r.filter((function(_){return Object.getOwnPropertyDescriptor(n,_).enumerable}))),e.push.apply(e,r)}return e}function s(n){for(var _=1;_<arguments.length;_++){var e=null!=arguments[_]?arguments[_]:{};_%2?i(Object(e),!0).forEach((function(_){t(n,_,e[_])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):i(Object(e)).forEach((function(_){Object.defineProperty(n,_,Object.getOwnPropertyDescriptor(e,_))}))}return n}function a(n,_){if(null==n)return{};var e,r,t=function(n,_){if(null==n)return{};var e,r,t={},i=Object.keys(n);for(r=0;r<i.length;r++)e=i[r],_.indexOf(e)>=0||(t[e]=n[e]);return t}(n,_);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(r=0;r<i.length;r++)e=i[r],_.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(t[e]=n[e])}return t}var l=r.createContext({}),o=function(n){var _=r.useContext(l),e=_;return n&&(e="function"==typeof n?n(_):s(s({},_),n)),e},d=function(n){var _=o(n.components);return r.createElement(l.Provider,{value:_},n.children)},p="mdxType",c={inlineCode:"code",wrapper:function(n){var _=n.children;return r.createElement(r.Fragment,{},_)}},u=r.forwardRef((function(n,_){var e=n.components,t=n.mdxType,i=n.originalType,l=n.parentName,d=a(n,["components","mdxType","originalType","parentName"]),p=o(e),u=t,g=p["".concat(l,".").concat(u)]||p[u]||c[u]||i;return e?r.createElement(g,s(s({ref:_},d),{},{components:e})):r.createElement(g,s({ref:_},d))}));function g(n,_){var e=arguments,t=_&&_.mdxType;if("string"==typeof n||t){var i=e.length,s=new Array(i);s[0]=u;var a={};for(var l in _)hasOwnProperty.call(_,l)&&(a[l]=_[l]);a.originalType=n,a[p]="string"==typeof n?n:t,s[1]=a;for(var o=2;o<i;o++)s[o]=e[o];return r.createElement.apply(null,s)}return r.createElement.apply(null,e)}u.displayName="MDXCreateElement"},61003:(n,_,e)=>{e.r(_),e.d(_,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>o});var r=e(87462),t=(e(67294),e(3905));const i={},s="EXU\u6a21\u5757\u548cCPU\u8fd0\u884c",a={unversionedId:"Skill/ASM/RISC-V/EXU\u6a21\u5757\u548cCPU\u8fd0\u884c",id:"Skill/ASM/RISC-V/EXU\u6a21\u5757\u548cCPU\u8fd0\u884c",title:"EXU\u6a21\u5757\u548cCPU\u8fd0\u884c",description:"\u4e00\u3001rv32i_core\u6a21\u5757",source:"@site/docs/Skill/ASM/RISC-V/8-EXU\u6a21\u5757\u548cCPU\u8fd0\u884c.md",sourceDirName:"Skill/ASM/RISC-V",slug:"/Skill/ASM/RISC-V/EXU\u6a21\u5757\u548cCPU\u8fd0\u884c",permalink:"/docs/Skill/ASM/RISC-V/EXU\u6a21\u5757\u548cCPU\u8fd0\u884c",draft:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{},sidebar:"skillSidebar",previous:{title:"CSR\u8bfb\u5199\u63a7\u5236",permalink:"/docs/Skill/ASM/RISC-V/CSR\u8bfb\u5199\u63a7\u5236"},next:{title:"RISC-V \u603b\u7ebf\u548c\u6d41\u6c34\u7ebf",permalink:"/docs/Skill/ASM/RISC-V/RISC-V\u603b\u7ebf\u548c\u6d41\u6c34\u7ebf"}},l={},o=[{value:"\u4e00\u3001rv32i_core\u6a21\u5757",id:"\u4e00rv32i_core\u6a21\u5757",level:2},{value:"\u76f8\u5173\u4ee3\u7801",id:"\u76f8\u5173\u4ee3\u7801",level:3},{value:"\u6a21\u5757\u4ecb\u7ecd",id:"\u6a21\u5757\u4ecb\u7ecd",level:3},{value:"\u4e8c\u3001CPU\u8fd0\u884c\u8fc7\u7a0b\uff08\u57fa\u4e8e\u6d41\u6c34\u7ebf\uff09",id:"\u4e8ccpu\u8fd0\u884c\u8fc7\u7a0b\u57fa\u4e8e\u6d41\u6c34\u7ebf",level:2},{value:"\u4ee3\u7801\u5206\u6790",id:"\u4ee3\u7801\u5206\u6790",level:3}],d={toc:o};function p(n){let{components:_,...i}=n;return(0,t.kt)("wrapper",(0,r.Z)({},d,i,{components:_,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"exu\u6a21\u5757\u548ccpu\u8fd0\u884c"},"EXU\u6a21\u5757\u548cCPU\u8fd0\u884c"),(0,t.kt)("h2",{id:"\u4e00rv32i_core\u6a21\u5757"},"\u4e00\u3001rv32i_core\u6a21\u5757"),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u5f53\u5b8c\u6210\u6574\u4e2aRISC-V \u5185\u6838\u6a21\u5757\u540e\uff0c \u9700\u8981ITCM \u6a21\u5757 \u8bfb\u53d6\u8f6f\u4ef6\u7f16\u5199\u4ee3\u7801\u7684\u673a\u5668\u7801\uff0c \u6309\u7167\u53d6\u6307\uff0c \u8bd1\u7801\uff0c\u6267\u884c\uff0c\u8bbf\u5b58\uff0c\u5199\u56de\u7b49\u903b\u8f91\u6765\u6267\u884c\u5f53\u524d\u7684\u673a\u5668\u7801"),"\uff0c \u8fd95\u4e2a\u90e8\u5206\u5e76\u4e0d\u662f\u6bcf\u6b21\u90fd\u4f1a\u53d1\u9001\uff0c\u6709\u65f6\u4e5f\u4f1a\u63d0\u524d\u8fd4\u56de\uff0c\u6bd4\u5982 addi\uff0c \u6ca1\u6709\u8bbf\u5b58\u5916\u90e8\u5b58\u50a8\u5668\u3002\u5f53\u524d\u7248\u672c\u662fRISC-V V2.01\u7248\uff0c ",(0,t.kt)("strong",{parentName:"p"},"\u4f7f\u7528\u7684\u662f\u72b6\u6001\u673a\u903b\u8f91"),"\uff0c \u5728\u540e\u7eed\u7684\u7248\u672c\u4e2d\uff0c \u6211\u4eec\u4f1a\u4fee\u6539\u4e3a\u6d41\u6c34\u7ebf\u65b9\u5f0f\u3002"),(0,t.kt)("h3",{id:"\u76f8\u5173\u4ee3\u7801"},"\u76f8\u5173\u4ee3\u7801"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-verilog"},"module fii_rv32i_core \n# (\n    parameter [31:0] TMR_BASEADDR  = 32'h0200_0000,\n    parameter [31:0] PLIC_BASEADDR = 32'h0c00_0000,\n    parameter [31:0] CPU_BASEADDR  = 32'h8000_0000,\n    parameter [31:0] MEM_BASEADDR  = 32'h9000_0000,\n    parameter [31:0] UART_BASEADDR = 32'he000_0000,\n    parameter [31:0] GPIO_BASEADDR = 32'hf000_0000\n)\n(\n    input sys_clk,\n\n//====================================\n    input  [ 31: 0 ] i_GPIO_dina,\n    output [ 31: 0 ] o_GPIO_douta,\n    output [ 31: 0 ] o_GPIO_ta,\n\n    input  [ 31: 0 ] i_GPIO_dinb,\n    output [ 31: 0 ] o_GPIO_doutb,\n    output [ 31: 0 ] o_GPIO_tb,\n\n    input  [ 31: 0 ] i_GPIO_dinc,\n    output [ 31: 0 ] o_GPIO_doutc,\n    output [ 31: 0 ] o_GPIO_tc,\n\n    input  [ 31: 0 ] i_GPIO_dind,\n    output [ 31: 0 ] o_GPIO_doutd,\n    output [ 31: 0 ] o_GPIO_td,\n\n    output txd_start,\n    output [7:0] txd_data,\n    input  txd_done,\n\n//====================================\n    output [31:0] o_sft_int_v,\n    output [31:0] o_timer_l,\n    output [31:0] o_timer_h,\n\n    input  [31:0] i_timer_l,\n    input  [31:0] i_timer_h, \n\n    output [31:0] o_tcmp_l,\n    output [31:0] o_tcmp_h,\n\n    output [1:0] o_timer_valid,\n    output [31:0] o_tm_ctrl,\n\n\n    input  [31:0] code_addr,\n    input  [31:0] code_din,\n    input  code_wea,\n//====================================\n    input  i_ext_irq,\n    input  i_sft_irq,\n    input  i_tmr_irq,\n\n    output o_meie,\n    output o_msie,\n    output o_mtie,\n    output o_glb_irq,\n//====================================\n    input  i_cpu_reset,\n    input  rst_n\n);\n\n//===============================================================================\nlocalparam [ 2: 0 ] IDLE = 8'd0,\n                   I_FCH = 8'd1,\n                   I_EXE = 8'd2,\n                    I_LS = 8'd3,\n                    I_WB = 8'd4,\n                   I_RO1 = 8'd5,\n                   I_RO2 = 8'd6,\n                   I_RO3 = 8'd7;\nwire ls_need;\n\n// load program data\n(* mark_debug = \"yes\" *)wire o_CPU_cs;\nwire [ 31: 0 ] o_CPU_PC;\n//===============================================================================\n(* mark_debug = \"yes\" *) reg [ 2: 0 ] instr_st = 0;\nreg [ 2: 0 ] instr_st_nxt = 0;\nalways@( posedge sys_clk )\nif (( rst_n == 1'b0 ) | i_cpu_reset ) instr_st <= IDLE;\nelse instr_st <= instr_st_nxt;\n\nalways @ ( * )\nbegin\n    case ( instr_st )\n    IDLE: // 0\n    begin\n        if(!i_cpu_reset)\n            instr_st_nxt = I_FCH;\n        else\n            instr_st_nxt = IDLE;\n    end\n    I_FCH: // 1\n    begin\n        if(i_cpu_reset) instr_st_nxt = IDLE;\n        else instr_st_nxt = I_EXE;\n    end\n    I_EXE: // 2\n    begin\n        if ( ls_need & o_CPU_cs)\n            instr_st_nxt = I_RO1;\n        else \n            instr_st_nxt = I_WB;\n    end\n    I_WB: // 4\n    begin\n        instr_st_nxt = I_FCH;\n    end\n    I_RO1: // 5\n    begin\n        instr_st_nxt = I_RO2;\n    end\n    I_RO2: // 6\n    begin\n        instr_st_nxt = I_FCH;\n    end\n    I_RO3: // 7\n    begin\n        instr_st_nxt = I_FCH;\n    end\n    default : instr_st_nxt = IDLE;\n    endcase\nend\n//===============================================================================\n(* mark_debug = \"yes\" *)reg irq_tch_r = 0;\nalways @ (posedge sys_clk or negedge rst_n)\nif(~rst_n) irq_tch_r <= 0;\nelse if(instr_st == I_FCH) irq_tch_r <= (i_ext_irq | i_sft_irq | i_tmr_irq);\n\n\n(* mark_debug = \"yes\" *)wire w_irq_src = o_CPU_cs ? 1'b0 : irq_tch_r;\n(* mark_debug = \"yes\" *)wire jump_irq_pc = w_irq_src & o_glb_irq;\nwire w_exp_src = 0;\nwire irq_exp = w_irq_src | w_exp_src ;\n\nwire mret;\nwire [31:0] mepc;\nwire [31:0] w_irq_pc;\n(* mark_debug = \"yes\" *) reg [ 31: 0 ] i_fch_PC = 0;\nreg [ 31: 0 ] res_PC = 0;\nwire [31:0] w_exe_PC;\n\nalways @( posedge sys_clk or negedge rst_n )\nif ( !rst_n ) i_fch_PC <= CPU_BASEADDR;\nelse \nbegin\n    if ( instr_st == IDLE ) //0\n        i_fch_PC <= CPU_BASEADDR;\n    else if ( instr_st == I_EXE ) //2\n    begin\n        if( mret )\n            i_fch_PC <= mepc;\n        else if (jump_irq_pc)\n            i_fch_PC <= w_irq_pc;\n        else if( o_CPU_cs )\n        begin\n            i_fch_PC <= o_CPU_PC;\n            res_PC <= w_exe_PC;\n        end\n        else i_fch_PC <= w_exe_PC;\n    end\n    else if ( instr_st == I_RO1 )\n    begin\n        i_fch_PC <= res_PC;\n    end\nend\n\n//===============================================================================\n(* mark_debug = \"yes\" *) reg EXE_vld = 0;\nalways @( posedge sys_clk or negedge rst_n )\nif ( !rst_n ) EXE_vld <= 0;\nelse\nbegin\n    if ( instr_st == I_FCH ) //1\n        EXE_vld <= 1'b1;\n    else\n        EXE_vld <= 1'b0;\nend\n\n\nwire [ 31: 0 ] instr;\n\n(* mark_debug = \"yes\" *)reg [ 31: 0 ] exe_instr = 0;\nalways @( posedge sys_clk or negedge rst_n )\nif ( !rst_n ) exe_instr <= 0;\nelse if ( instr_st == I_FCH )\n    exe_instr <= instr;\n\n(* mark_debug = \"true\" *)reg i_CPU_load_vld = 0;\n(* mark_debug = \"true\" *)reg [ 31: 0 ] i_CPU_load_data = 0;\nalways @( posedge sys_clk or negedge rst_n )\nif ( !rst_n ) \nbegin\n    i_CPU_load_data <= 0;\n    i_CPU_load_vld <= 0;\nend\nelse if ( instr_st == I_RO2 )\nbegin\n    i_CPU_load_data <= instr;\n    i_CPU_load_vld <= 1'b1;\nend\nelse i_CPU_load_vld <= 1'b0;\n\n//===============================================================================\n\n(* mark_debug = \"yes\" *) wire [ 31: 0 ] instr_PC = i_fch_PC;\n\nrv32I_exu #\n(\n    .TMR_BASEADDR  ( TMR_BASEADDR ),\n    .PLIC_BASEADDR ( PLIC_BASEADDR ),\n    .CPU_BASEADDR  ( CPU_BASEADDR ),\n    .MEM_BASEADDR  ( MEM_BASEADDR ),\n    .UART_BASEADDR ( UART_BASEADDR ),\n    .GPIO_BASEADDR ( GPIO_BASEADDR )\n)\nrv32I_exu_inst\n(\n    .sys_clk       ( sys_clk ),\n\n    .i_ir          ( exe_instr ), // The instruction register\n    .i_PC          ( instr_PC ), // The PC register along with\n    .i_EXE_vld     ( EXE_vld ),\n\n    .i_CPU_load_vld  ( i_CPU_load_vld),\n    .i_CPU_load_data ( i_CPU_load_data ),\n\n    .o_ls_need     ( ls_need ),\n\n    .o_exe_PC      ( w_exe_PC ),\n\n// load program data\n    .o_CPU_cs      ( o_CPU_cs ),\n    .o_CPU_PC      ( o_CPU_PC ),\n\n    .i_ext_irq     ( i_ext_irq ),\n    .i_sft_irq     ( i_sft_irq ),\n    .i_tmr_irq     ( i_tmr_irq ),\n\n    .o_meie        ( o_meie ),\n    .o_msie        ( o_msie ),\n    .o_mtie        ( o_mtie ),\n    .o_glb_irq     ( o_glb_irq ),\n\n    .i_irq_src     ( w_irq_src ),\n    .i_exp_src     ( w_exp_src ),\n\n    .o_mret        ( mret ),\n    .o_irq_pc      ( w_irq_pc ),\n    .o_mepc        ( mepc ),\n\n//===============================================================================\n    .i_GPIO_dina   ( i_GPIO_dina ),\n    .o_GPIO_douta  ( o_GPIO_douta ),\n    .o_GPIO_ta     ( o_GPIO_ta ),\n\n    .i_GPIO_dinb   ( i_GPIO_dinb ),\n    .o_GPIO_doutb  ( o_GPIO_doutb ),\n    .o_GPIO_tb     ( o_GPIO_tb ),\n\n    .i_GPIO_dinc   ( i_GPIO_dinc ),\n    .o_GPIO_doutc  ( o_GPIO_doutc ),\n    .o_GPIO_tc     ( o_GPIO_tc ),\n\n    .i_GPIO_dind   ( i_GPIO_dind ),\n    .o_GPIO_doutd  ( o_GPIO_doutd ),\n    .o_GPIO_td     ( o_GPIO_td ),\n\n    .txd_start     ( txd_start ),\n    .txd_data      ( txd_data ),\n    .txd_done      ( txd_done ),\n\n    .o_sft_int_v   ( o_sft_int_v ),\n    .i_timer_l     ( i_timer_l ),\n    .i_timer_h     ( i_timer_h ),\n\n    .o_timer_l     ( o_timer_l ),\n    .o_timer_h     ( o_timer_h ),\n\n    .o_tcmp_l      ( o_tcmp_l ),\n    .o_tcmp_h      ( o_tcmp_h ),\n\n    .o_timer_valid ( o_timer_valid ),\n    .o_tm_ctrl     ( o_tm_ctrl),\n\n    .i_cpu_reset   ( i_cpu_reset),\n    .rst_n         ( rst_n )\n);\n//===============================================================================\nwire instr_ena = ( instr_PC[ 31: 16 ] == CPU_BASEADDR[31:16] ) ? 1'b1 : 1'b0;\n\nTDP_RAM_INSTR program_inst\n(\n    .clka  ( sys_clk ),\n    .ena   ( 1'b1 ),\n    .wea   ( code_wea ),\n    .addra ( code_addr[31:2] ),\n    .dina  ( code_din ),\n    .douta ( ),\n\n    .clkb  ( sys_clk ),\n    .enb   ( instr_ena ),\n    .web   ( 1'b0 ),\n    .addrb ( instr_PC[ 31: 2 ] ), //8K 32bits, 32K byte\n    .dinb  ( 32'b0 ),\n    .doutb ( instr )\n);\n//===============================================================================\n\n\nendmodule\n")),(0,t.kt)("h3",{id:"\u6a21\u5757\u4ecb\u7ecd"},"\u6a21\u5757\u4ecb\u7ecd"),(0,t.kt)("p",null,"\u6267\u884c\u72b6\u6001\u673a\uff0c \u4f7f\u7528\u4e24\u6bb5\u5f0f\u72b6\u6001\u673a\u3002 "),(0,t.kt)("p",null,"\u5728\u53d6\u6307\u72b6\u6001\u4e0b\u9501\u5b58 \u5404\u79cd\u4e2d\u65ad\u72b6\u6001\uff0c\u5305\u62ec\u5916\u90e8\u4e2d\u65ad\uff0c\u8f6f\u4ef6\u4e2d\u65ad\uff0ctimer \u4e2d\u65ad\u3002"),(0,t.kt)("p",null,"\u5982\u679c\u4e0a\u4e00\u6761\u6307\u4ee4\u4e3a\u666e\u6797\u65af\u987f\u67b6\u6784\uff0c\u9700\u8981\u8ba9\u8fd9\u6761\u6307\u4ee4\u6267\u884c\u5b8c\u6bd5\uff0c \u540c\u65f6\u5728CSR \u5bc4\u5b58\u5668\u4e2d\u8bbe\u7f6e\u7684\u5168\u5c40\u4e2d\u65adenable \uff08o_glb_irq) \uff0c \u8fd9\u65f6\u4ea7\u751f\u7684jump_irq_pc \u6709\u6548\u3002"),(0,t.kt)("p",null,"\u5728\u666e\u6797\u65af\u987f\u67b6\u6784\u4e0b\uff0c\u5c06load \u6307\u4ee4\u8bfb\u5230\u7684\u6570\u636e \u9001\u7ed9 lsu \u6a21\u5757 \u3002"),(0,t.kt)("p",null,"nstr_ena \u9009\u62e9\u7684\u65f6ITCM \u5730\u5740\u7a7a\u95f4\u3002"),(0,t.kt)("p",null,"\u8fd9\u4e2a\u53cc\u7aef\u53e3\u4e3aITCM \uff1a"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"\u7aef\u53e3A \uff1a\u7528\u6237\u53ef\u4ee5\u901a\u8fc7uart \u53e3\uff0c\u5c06\u8f6f\u4ef6\u7684\u6c47\u7f16\u673a\u5668\u7801\u4e0b\u8f7d\u5230 ITCM; "),(0,t.kt)("li",{parentName:"ul"},"\u7aef\u53e3B\uff1a instr_ena \u662f\u9009\u4e2ditcm, instr_PC","[31\uff1a2]"," \u662f\u5f53\u524d\u6307\u4ee4PC\u3002instr \u8bfb\u53d6ITCM \u7684\u6307\u4ee4\uff08\u5982\u679c\u662f\u666e\u6797\u65af\u987f\u67b6\u6784\uff0c\u4e5f\u53ef\u4ee5\u8bfb\u53d6\u5230\u7684\u662f\u6570\u636e\uff09\u3002")),(0,t.kt)("h2",{id:"\u4e8ccpu\u8fd0\u884c\u8fc7\u7a0b\u57fa\u4e8e\u6d41\u6c34\u7ebf"},"\u4e8c\u3001CPU\u8fd0\u884c\u8fc7\u7a0b\uff08\u57fa\u4e8e\u6d41\u6c34\u7ebf\uff09"),(0,t.kt)("p",null,"\u5f53\u5b8c\u6210\u6574\u4e2aRISC-V \u5185\u6838\u6a21\u5757\u540e\uff0c \u9700\u8981ITCM \u6a21\u5757 \u8bfb\u53d6\u8f6f\u4ef6\u7f16\u5199\u7684\u4ee3\u7801\u7684\u673a\u5668\u7801\uff0c \u6309\u7167\u53d6\u6307\uff0c \u8bd1\u7801\uff0c\u6267\u884c\uff0c\u8bbf\u5b58\uff0c\u5199\u56de\u7b49\u903b\u8f91\u6765\u6267\u884c\u5f53\u524d\u7684\u673a\u5668\u7801\uff0c \u8fd95\u4e2a\u90e8\u5206\u5e76\u4e0d\u662f\u6bcf\u6b21\u90fd\u4f1a\u53d1\u9001\uff0c\u6709\u65f6\u4e5f\u4f1a\u63d0\u524d\u8fd4\u56de\uff0c\u6bd4\u5982 addi\uff0c \u6ca1\u6709\u8bbf\u5b58\u5916\u90e8\u5b58\u50a8\u5668\u3002\u5728\u7248\u672c\u662fRISC-V V3.00\u7248\u548c\u4e4b\u540e\u7684\u7248\u672c\u4e2d\uff0c \u4f7f\u7528\u7684\u662f\u6d41\u6c34\u7ebf\u65b9\u5f0f\u6765\u5904\u7406cpu \u6307\u4ee4\u3002\u6211\u4eec\u91c7\u7528\u7684\u662f3\u7ea7\u6d41\u6c34\u7ebf\u65b9\u5f0f\u3002 "),(0,t.kt)("p",null,(0,t.kt)("img",{src:e(57205).Z,width:"1683",height:"880"})),(0,t.kt)("p",null,"\u56fe\u4e2d\u84dd\u8272\u65b9\u5757\u90fd\u662fD\u89e6\u53d1\u5668\u9501\u5b58\u3002 \u4ee3\u8868\u6d41\u6c34\u7ebf\u7684\u7ea7\u522b\u3002"),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u7b2c\u4e00\u7ea7\u6d41\u6c34\u7ebf\uff1a")),(0,t.kt)("p",null,"\u7531\u4e8e\u6211\u4eec\u4f7f\u7528dual port memory \u4f5c\u4e3aITCM (\u6307\u4ee4\u5b58\u50a8\u5668\uff09\uff0c\u6240\u4ee5\u6bcf\u6b21\u7ed9\u51fa\u5730\u5740\u4e4b\u540e\uff0c \u9700\u8981\u7b49\u5f85\u4e00\u4e2a\u65f6\u949f\u5468\u671f\uff0c \u7136\u540e\u624d\u80fd\u5f97\u5230\u76f8\u5e94\u7684\u6307\u4ee4\u6570\u636e\u3002\u6240\u4ee5\u53d6\u6307\u7684\u8fc7\u7a0b\u9700\u89812\u4e2a\u65f6\u949f\u5468\u671f\u3002 \u4f46\u8fd9\u4e2a\u90e8\u5206\u4f9d\u7136\u5c5e\u4e8e\u7b2c\u4e00\u7ea7\u6d41\u6c34\u7ebf\u8303\u7574\uff08\u53d6\u6307\uff09\u3002\u5982\u679c\u4f7f\u7528reg \u5806\u79ef\u51fa\u6765\u4e00\u4e2aram\uff0c \u5c06\u4f1a\u8282\u7701\u4e00\u4e2a\u65f6\u949f\u5468\u671f\uff0c \u7f3a\u70b9\u662f\u5360\u7528\u5927\u91cf\u7684fpga \u7cfb\u7edf\u8d44\u6e90\u3002"),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u7b2c\u4e8c\u7ea7\u6d41\u6c34\u7ebf\uff1a")),(0,t.kt)("p",null,"\u5904\u7406\u6574\u4e2a\u7684\u8bd1\u7801\uff0c\u6267\u884c\u9636\u6bb5\u3002\u5305\u62ecdecoder \uff08\u8bd1\u7801\uff09\uff0c ALU\uff08\u6267\u884c\uff09\uff0cbranch \uff08\u5206\u652f\u6307\u4ee4\u6267\u884c\uff09\uff0cCSR \uff08\u5bc4\u5b58\u5668\u76f8\u5173\u7684\u6267\u884c\uff09"),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u7b2c\u4e09\u7ea7\u6d41\u6c34\u7ebf\uff1a")),(0,t.kt)("p",null,"\u5199\u56de 32\u4e2a\u901a\u7528\u5bc4\u5b58\u5668\uff08regfile\uff09\u3002\u5982\u679c\u662fLOAD/STORE \u76f8\u5173\u7684\u6307\u4ee4\uff0c\u5904\u7406\u5916\u8bbe\u76f8\u5173\u7684\u64cd\u4f5c\u3002\u8fd9\u4e2a\u90e8\u5206\u4f1a\u88ab\u8fde\u63a5\u5230\u603b\u7ebf\u4e0a\uff0c\u5305\u62ecgpio \uff0ctimer\uff0c Uart, \u4ee5\u53ca\u4e4b\u540erisc-v cpu \u6269\u5c55\u6240\u9700\u8981\u7684\u5916\u8bbe\u3002"),(0,t.kt)("p",null,"cpu \u53d6\u6307\u6a21\u5757\u6d41\u6c34\u7ebf\uff1a"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-verilog"},"`timescale 1ns / 1ps \n\nmodule fii_instr_rib \n# (\n    parameter [31:0] DBG_BASEADDR  = 32'h0000_0800,\n    parameter [31:0] TMR_BASEADDR  = 32'h0200_0000,\n    parameter [31:0] PLIC_BASEADDR = 32'h0c00_0000,\n    parameter [31:0] CPU_BASEADDR  = 32'h8000_0000,\n    parameter [31:0] MEM_BASEADDR  = 32'h9000_0000,\n    parameter [31:0] UART_BASEADDR = 32'he000_0000,\n    parameter [31:0] PWM_BASEADDR  = 32'hf000_2000,\n    parameter [31:0] GPIO_BASEADDR = 32'hf000_0000\n)\n(\n    input  sys_clk,\n\n    output reg [31:0] o_curr_pc,\n    output [31:0]   o_curr_instr,\n\n//===============================================================================\n    input           i_pc_chg_flag,\n    input           i_ir_hold_flag,\n    input  [31:0]   i_exe_next_PC,\n\n    output          o_CPU_load_vld,\n//===============================================================================\n\n    input  i_ext_irq,\n    input  i_sft_irq,\n    input  i_tmr_irq,\n\n    input  o_glb_irq,                 // mstatus[3]; enable all Machine Mode interrupt\n\n    input  [31:0] i_dbg_entry_adr,    // jtag debug entry address\n    input  i_dbg_entry_set,           // jtag debug entry address enable ( one clock )\n\n    input  [31:0] i_dpc_r,\n    input  [31:0] i_dbg_instr,\n    input  dret,\n\n    input  [31:0]  i_mepc,\n    input  [31:0]  i_vect_pc,                    // mtvec regitesr content\n    output o_irq_src,\n    output o_exp_src,\n    input  mret,\n    input  dbg_start,\n\n//===============================================================================\n    input  itcm_wea,\n    input  [31:0] itcm_addra,\n    input  [31:0] itcm_dina,    \n\n//===============================================================================\n    input  [31:0] i_rib_saddr,\n    input  [31:0] i_rib_sdin,\n    output [31:0] o_rib_sdout,\n    input  i_rib_svalid,\n    output [1:0] o_rib_sready,\n    input  [3:0]  i_rib_swe,\n    input  i_rib_srd,\n    input  i_rib_sop,\n//===============================================================================\n    // master bus signal\n    input  i_rib_mvalid,\n    input  [1:0] i_rib_mready,\n//===============================================================================\n\n    input  i_cpu_reset,    \n    input  rst_n\n);\n\n//===============================================================================\n// cpu master bus operation\n\n// long instruction : dec_instr should be set as 'INST_NOP, during long instruction.\nreg  rib_delay_op = 0;\nalways @ ( posedge sys_clk or negedge rst_n)\nif(!rst_n) rib_delay_op <= 0;\n//else if ( o_rib_mvalid & ~i_rib_mready[0] ) rib_delay_op <= 1;\nelse if ( i_rib_mvalid ^ i_rib_mready[0] ) rib_delay_op <= 1;\nelse rib_delay_op <= 0;\n\n\nwire  bus_hsk_ok = i_rib_mvalid & i_rib_mready[0];\n\n// long period load & store operation; normal operation long_ir_flag is 0\n  wire  long_ir_flag = ( i_rib_mvalid & (~i_rib_mready[0]) ) | rib_delay_op;\n\n// long period instruction pos edge; normal operation long_ir_cs is 0 \n  wire  long_ir_cs = ( i_rib_mvalid & (~i_rib_mready[0]) ) & i_rib_sop;\n\n//===============================================================================\n  wire o_CPU_load_cs = ( i_rib_saddr[ 31: 16 ] == CPU_BASEADDR[ 31: 16 ] ) ? i_rib_sop : 1'b0;\n/*\nls_r is used for 0x8000_0000 DATA load instruction, becasue 0x8000_0000 is dual\nport ram , it will be delay 2 clock (output data form dual port ram), the ls_r[1]\nis signal that o_cpu_load_cs delay 2 clock\n*/\n\n\nreg [1:0] ls_r = 0;\nalways @( posedge sys_clk or negedge rst_n)\nif(!rst_n) ls_r <= 0;\nelse\n    ls_r <= {ls_r[0], o_CPU_load_cs};\n\n\nassign o_CPU_load_vld = ls_r[1];\nassign o_rib_sready = {1'b0, ls_r[1]};\n//===============================================================================\nwire [31:0] pc_instr;\n\nwire [31:0]   i_CPU_load_data = pc_instr;\n\nwire [ 4: 0 ] data_sft = {i_rib_saddr[ 1: 0 ], 3'b000};  //i_D_PC[ 1: 0 ] * 8;  \nwire [ 31: 0 ] o_CPU_dout = i_CPU_load_data >> data_sft;\n\nassign o_rib_sdout = o_CPU_dout;\n\n//===============================================================================\nreg [ 31: 0 ] instr_fch_PC = 0;\n//===============================================================================\n\n/*\nnext_addr is relevent o_cpu_load_cs, for example : current program pc is 0x8000_0004,\n(load instruction ,data at 0x8000_01000), next_addr will be next program pc\n0x8000_0004 + 4, after load instruction finish. \n*/\n\nreg [31:0] next_addr = 0;\nalways @( posedge sys_clk )\nif(!rst_n | i_cpu_reset) next_addr <= CPU_BASEADDR;\nelse if(i_rib_sop) next_addr <= instr_fch_PC;\n//===============================================================================\nassign o_exp_src = 0;\nwire nop_flag; \n// don't generate interrupt when cpu load & flush instruction\nassign o_irq_src = (long_ir_flag | nop_flag) ? 1'b0 : (i_ext_irq | i_sft_irq | i_tmr_irq);\n\nwire irq_exp_flag = (o_irq_src & o_glb_irq) | o_exp_src ;  // edge o_irq_src high, then o_glb_irq low\n//===============================================================================\nreg  [31:0] jump_addr = 0;\nalways @( * )\nbegin\n    if(i_dbg_entry_set)\n        jump_addr = i_dbg_entry_adr;\n    else if(dret)\n        jump_addr = i_dpc_r;\n    else if (long_ir_cs) // long address & (addr == 0x8000_xxxx)\n        jump_addr = {i_rib_saddr[31:2], 2'b00};\n    else if( irq_exp_flag ) \n        jump_addr = i_vect_pc;    // mtvec regitesr content\n    else if( mret )\n        jump_addr = i_mepc;       // The PC before enter interrupt\n    else if( i_ir_hold_flag )\n        jump_addr = o_curr_pc;    // long term instruction ,pc hold at current position\n    else jump_addr = i_exe_next_PC;\nend\n\nwire w_jump_flag = i_dbg_entry_set | dret | irq_exp_flag | i_pc_chg_flag | mret | long_ir_cs | i_ir_hold_flag;\n//===============================================================================\n//stage  1\nalways @( posedge sys_clk )\nif (( !rst_n ) | i_cpu_reset ) instr_fch_PC <= CPU_BASEADDR;\nelse \nbegin\n    if (w_jump_flag)\n        instr_fch_PC <= jump_addr;\n    else if( ~bus_hsk_ok & rib_delay_op ) // long period load & store \n        instr_fch_PC <= next_addr;\n    else\n        instr_fch_PC <= instr_fch_PC + 4;\nend\n\n\n//===============================================================================\n//stage  2\nalways @( posedge sys_clk or negedge rst_n )\nif ( !rst_n ) o_curr_pc <= CPU_BASEADDR;\nelse  o_curr_pc <= i_ir_hold_flag ? o_curr_pc : (bus_hsk_ok & rib_delay_op) ? next_addr : instr_fch_PC;\n//else  o_curr_pc <= instr_fch_PC;\n\n//===============================================================================\n/*\n next clock should be output a inst_nop , because dual port ram , address jump, \n the pipeline address (current address + 4) will be ignore, \n*/\n\nreg waiting_r = 0;\nalways @ (posedge sys_clk or negedge rst_n)\nif(!rst_n) waiting_r <= 0;\nelse  waiting_r <= w_jump_flag;\n\n//===============================================================================\n// w_dbg_pc  point to 0x8000_xxxxx address , we need get data from dual port ram ,\n// so, w_dbg_pc need 2 clock to get the data(0x8000_xxxx)\n\nwire [31:0] w_dbg_pc = instr_fch_PC;\n\nlocalparam [ 31: 0 ] DBG_RAM_ADDR    = 32'h0000_0400;\n\n// 0x400 - 0x800\n\n\nwire dbg_addr_sel = (w_dbg_pc[31:12] ==  DBG_BASEADDR[31:12]) & (w_dbg_pc[11:10] !=  2'b00) ? 1'b1 : 1'b0;\nreg dbg_addr_cs = 0;\n\nalways @ (posedge sys_clk or negedge rst_n)\nif(!rst_n) dbg_addr_cs <= 0;\nelse    dbg_addr_cs <= dbg_addr_sel;\n\n//===============================================================================\nwire [31:0] instr_data_sel = dbg_addr_cs ? i_dbg_instr : pc_instr ;\nassign o_curr_instr = (waiting_r) ? `INST_NOP : instr_data_sel;\n\n\nassign nop_flag = (o_curr_instr == `INST_NOP) ? 1'b1 : 1'b0;\n//===============================================================================\nwire instr_ena = ( instr_fch_PC[ 31: 16 ] == CPU_BASEADDR[31:16] ) ? 1'b1 : 1'b0;\n\nTDP_RAM_INSTR  program_inst\n(\n    .clka   ( sys_clk ),\n    .ena    ( 1'b1 ),\n    .wea    ( itcm_wea ),\n    .addra  ( itcm_addra[31:2] ),\n    .dina   ( itcm_dina ),\n    .douta  ( ),\n\n    .clkb   ( sys_clk ),\n    .enb    ( instr_ena ),\n    .web    ( 1'b0 ),\n    .addrb  ( instr_fch_PC[ 31: 2 ] ), //8K 32bits, 32K byte\n    .dinb   ( 32'b0 ),\n    .doutb  ( pc_instr )\n);\n\n//===============================================================================\n\n\n\nendmodule\n")),(0,t.kt)("h3",{id:"\u4ee3\u7801\u5206\u6790"},"\u4ee3\u7801\u5206\u6790"),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u7aef\u53e3\u8bf4\u660e\uff1a")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-verilog"},"input sys_clk,                              // \u7cfb\u7edf\u65f6\u949f\n\noutput reg [31:0] o_curr_pc,             // \u8f93\u51fa \u5f53\u524d\u7684PC \u503c\noutput       [31:0] o_curr_instr,          // \u8f93\u51fa \u5f53\u524d\u7684 \u6307\u4ee4\u503c\n\n//=======================================================================\ninput i_pc_chg_flag,               // \u8bd1\u7801\uff0c\u6267\u884c\u6a21\u5757\u901a\u77e5 pc \u503c\u9700\u8981\u66f4\u6539\uff0c\u4e0d\u518d\u662f\u6b63\u5e38\u7684 + 4\ninput i_ir_hold_flag,                // \u5904\u7406\u4e58\u9664\u6cd5\u6307\u4ee4\ninput [31:0] i_exe_next_PC, // \u8bd1\u7801\uff0c\u6267\u884c\u6a21\u5757\u901a\u77e5 \u4e0b\u4e00\u4e2apc \u503c \n\noutput o_CPU_load_vld,        // \u666e\u6797\u65af\u987f\u67b6\u6784 itcm \u63d0\u4f9b\u7684\u6570\u636e\u6709\u6548\n//=======================================================================\n\ninput i_ext_irq,                        // \u5916\u90e8\u4e2d\u65ad\ninput i_sft_irq,                         // \u8f6f\u4ef6\u4e2d\u65ad\ninput i_tmr_irq,                       // timer\u4e2d\u65ad \n\ninput o_glb_irq,                       // CSR \u5168\u5c40\u4e2d\u65ad\u4f4d\uff0cmstatus[3]; enable all Machine Mode interrupt\n\ninput [31:0] i_dbg_entry_adr, // jtag \u8c03\u8bd5\u5165\u53e3\u5730\u5740\uff0cjtag debug entry address\ninput i_dbg_entry_set,           // jtag \u8c03\u8bd5\u5165\u53e3 enable\uff0c jtag debug entry address enable ( one clock )\n\ninput [31:0] w_dpc_r,             // jtag \u8c03\u8bd5 pc\ninput [31:0] w_dbg_instr,      // jtag \u8c03\u8bd5 \u6307\u4ee4 \ninput dret,                                  // jtag \u8c03\u8bd5\u4e2d\u65ad \u8fd4\u56de\n\ninput [31:0] i_mepc,                // \u4e2d\u65ad\u65f6\uff0c\u5b58\u50a8\u7684\u5f53\u524dpc \u503c\ninput [31:0] i_vect_pc,           // \u4e2d\u65ad\u65f6\uff0c \u8df3\u5165\u4e2d\u65ad\u7684pc \u503c\uff0cmtvec regitesr content\noutput o_irq_src,                   // \u901a\u77e5 CSR \u6a21\u5757 \u4e2d\u65ad\u4fe1\u53f7\u7ebf\noutput o_exp_src,                  // \u901a\u77e5 CSR \u6a21\u5757 \u5f02\u5e38\u4fe1\u53f7\u7ebf\ninput mret,                                // \u4e2d\u65ad\u8fd4\u56de \u4fe1\u53f7\ninput dbg_start,                       // \u8fdb\u5165jtag \u8c03\u8bd5 \u4fe1\u53f7\n\n//=======================================================================\ninput itcm_wea,                      // ITCM \u66f4\u65b0 \u5199 enable \ninput [31:0] itcm_addra,      // ITCM \u66f4\u65b0 \u5730\u5740\ninput [31:0] itcm_dina,        // ITCM \u66f4\u65b0 \u6570\u636e\n\n//=======================================================================\n\n// riscv \u5185\u90e8\u603b\u7ebf slave \u603b\u7ebf\ninput [31:0] i_rib_saddr,    // riscv \u5185\u90e8\u603b\u7ebf \u5730\u5740\ninput [31:0] i_rib_sdin,      // riscv \u5185\u90e8\u603b\u7ebf \u5199\u6570\u636e\noutput [31:0] o_rib_sdout,// riscv \u5185\u90e8\u603b\u7ebf \u8bfb\u6570\u636e\ninput i_rib_svalid,               // riscv \u5185\u90e8\u603b\u7ebf \u6307\u4ee4\u6709\u6548\noutput [1:0] o_rib_sready, // riscv \u5185\u90e8\u603b\u7ebf \uff0c\u5916\u8bbe\u8bfb\u53d6\u7684\u6570\u636e\u6709\u6548\ninput [3:0] i_rib_swe,        // riscv \u5185\u90e8\u603b\u7ebf \u5199 enable\ninput i_rib_srd,                    // riscv \u5185\u90e8\u603b\u7ebf \u8bfb \u4fe1\u53f7\ninput i_rib_sop,                  // riscv \u5185\u90e8\u603b\u7ebf \u6307\u4ee4\u64cd\u4f5c enable\n//=======================================================================\n// riscv \u5185\u90e8\u603b\u7ebf master \u603b\u7ebf\uff0cmaster bus signal\ninput i_rib_mvalid,           // riscv \u5185\u90e8\u603b\u7ebf\u6307\u4ee4\u6709\u6548\ninput [1:0] i_rib_mready,// riscv \u5185\u90e8\u603b\u7ebf\uff0c\u5916\u90e8\u8bfb\u53d6\u7684\u6570\u636e\u6709\u6548\n//=======================================================================\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u957f\u5468\u671f\u6307\u4ee4\u64cd\u4f5c\uff1a")),(0,t.kt)("p",null,"\u5728\u957f\u5468\u671f\u7684\u64cd\u4f5c\u65f6\uff0c\u9700\u8981\u63d2\u5165\u7a7a\u6307\u4ee4\uff0c\u4fdd\u6301\u6d41\u6c34\u7ebf\u8fde\u7eed\u3002"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-verilog"},"// cpu master bus operation\n\n// long instruction : dec_instr should be set as \u2018INST_NOP, during long instruction.\nreg rib_delay_op = 0;\nalways @ ( posedge sys_clk or negedge rst_n)\nif(!rst_n) rib_delay_op <= 0;\nelse if ( i_rib_mvalid ^ i_rib_mready[0] ) rib_delay_op <= 1;\nelse rib_delay_op <= 0;\n\n\nwire bus_hsk_ok = i_rib_mvalid & i_rib_mready[0];\n\n// long period load & store operation; normal operation long_ir_flag is 0\nwire long_ir_flag = ( i_rib_mvalid & (~i_rib_mready[0]) ) | rib_delay_op;\n\n// long period instruction pos edge; normal operation long_ir_cs is 0\nwire long_ir_cs = ( i_rib_mvalid & (~i_rib_mready[0]) ) & i_rib_sop;\n")),(0,t.kt)("p",null,"\u957f\u5468\u671f\u6307\u4ee4\uff0c\u5305\u62ec\u666e\u6797\u65af\u987f\u7ed3\u6784\u6570\u636e\u8bfb\u53d6\uff0c jtag \u76f8\u5173\u6307\u4ee4\u3002"),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"107",src:e(58043).Z,width:"1824",height:"664"})),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u666e\u6797\u65af\u987f\u67b6\u6784\u4e0b\uff0c \u8bfb\u53d6\u7684\u6570\u636e\u5ef6\u8fdf\uff1a")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-verilog"},"reg [1:0] ls_r = 0;\nalways @( posedge sys_clk or negedge rst_n)\nif(!rst_n) ls_r <= 0;\nelse\nls_r <= {ls_r[0], o_CPU_load_cs};\n\n\nassign o_CPU_load_vld = ls_r[1];\nassign o_rib_sready = {1\u2019b0, ls_r[1]};\n")),(0,t.kt)("p",null,"\u7531\u4e8e\u4f7f\u7528\u7684\u65f6\u53cc\u7aef\u53e3 memory\uff0c \u9700\u8981\u5ef6\u8fdf\u4e00\u4e2a\u65f6\u949f\u5468\u671f\uff0c\u914d\u5408\u603b\u7ebf\u4e00\u8d77\u4f7f\u7528\u3002"),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"lb,lw,lh\u7b49load \u6307\u4ee4\u7684\u76f8\u5173\u5904\u7406\uff1a")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-verilog"},"wire [ 4: 0 ] data_sft = {i_rib_saddr[ 1: 0 ], 3\u2019b000}; //i_D_PC[ 1: 0 ] * 8;\nwire [ 31: 0 ] o_CPU_dout = i_CPU_load_data >> data_sft;\n\nassign o_rib_sdout = o_CPU_dout;\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u666e\u6797\u65af\u987f\u67b6\u6784\u4e0b\uff0c\u4fdd\u5b58\u5f53\u524dpc\u64cd\u4f5c\uff1a")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-verilog"},"reg [31:0] next_addr = 0;\nalways @( posedge sys_clk )\nif(!rst_n | i_cpu_reset) next_addr <= CPU_BASEADDR;\nelse if(i_rib_sop) next_addr <= instr_fch_PC;\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u4e2d\u65ad\u6e90\u5904\u7406\uff1a")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-verilog"},"assign o_exp_src = 0;\nwire nop_flag;\n// don\u2019t generate interrupt when cpu load & flush instruction\nassign o_irq_src = (long_ir_flag | nop_flag) ? 1\u2019b0 : (i_ext_irq | i_sft_irq | i_tmr_irq);\n\nwire irq_exp_flag = (o_irq_src & o_glb_irq) | o_exp_src ; // edge w_irq_src high, then o_glb_irq low\n")),(0,t.kt)("p",null,"\u957f\u5468\u671f\u6307\u4ee4\uff0c \u7a7a\u6307\u4ee4\u7b49\u9700\u8981\u7b49\u5f85\uff0c \u5176\u4ed6\u60c5\u51b5\u65f6\uff0c\u89e6\u53d1\u4e2d\u65ad\u3002"),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u5404\u79cd\u60c5\u51b5\u4e0b\u7684\u7684pc \u8df3\u8f6c\uff1a")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-verilog"},"reg [31:0] jump_addr = 0;\nalways @( * )\nbegin\n    if(i_dbg_entry_set)\n        jump_addr = i_dbg_entry_adr;\n    else if(dret)\n        jump_addr = i_dpc_r;\n    else if (long_ir_cs)               // long address & (addr == 0x8000_xxxx)\n        jump_addr = {i_rib_saddr[31:2], 2\u2019b00};\n    else if( irq_exp_flag )\n        jump_addr = i_vect_pc; // mtvec regitesr content\n    else if( mret )\n        jump_addr = i_mepc;      // The PC before enter interrupt\n    else if( i_ir_hold_flag )\n        jump_addr = o_curr_pc; // long term instruction ,pc hold at current position\n    else jump_addr = i_exe_next_PC;\nend\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u51c6\u5907\u8df3\u8f6c\u7684pc\uff1a")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-verilog"},"wire w_jump_flag = i_dbg_entry_set | dret | irq_exp_flag | i_pc_chg_flag | mret | long_ir_cs | i_ir_hold_flag;\n\nalways @( posedge sys_clk )\nif (( !rst_n ) | i_cpu_reset ) instr_fch_PC <= CPU_BASEADDR;\nelse\nbegin\n     if (w_jump_flag)\n         instr_fch_PC <= jump_addr;\n     else if( ~bus_hsk_ok & rib_delay_op ) // long period load & store\n         instr_fch_PC <= next_addr;\n     else\n         instr_fch_PC <= instr_fch_PC + 4;\nend\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u5b9e\u9645\u8981\u8df3\u8f6c\u7684pc\uff1a")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-verilog"},"always @( posedge sys_clk or negedge rst_n )\nif ( !rst_n ) o_curr_pc <= CPU_BASEADDR;\nelse o_curr_pc <= i_ir_hold_flag ? o_curr_pc : (bus_hsk_ok & rib_delay_op) ? next_addr : instr_fch_PC;\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"\u7a7a\u6307\u4ee4enable \u4fe1\u53f7\uff1a")),(0,t.kt)("p",null,"\u5f53\u53d1\u751f\u8df3\u8f6c\u65f6\uff08\u4e0d\u662f\u6b63\u5e38\u7684pc + 4\uff09\uff0c\u9700\u8981\u63d2\u5165\u7a7a\u6307\u4ee4\uff0c\u4fdd\u6301\u6d41\u6c34\u7ebf\u8fde\u7eed\uff0c "),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-verilog"},"reg waiting_r = 0;\nalways @ (posedge sys_clk or negedge rst_n)\nif(!rst_n) waiting_r <= 0;\nelse waiting_r <= w_jump_flag;\n\nassign o_curr_instr = (waiting_r) ? `INST_NOP : instr_data_sel;\n")),(0,t.kt)("p",null,(0,t.kt)("img",{src:e(3044).Z,width:"695",height:"177"})),(0,t.kt)("p",null,(0,t.kt)("img",{src:e(20192).Z,width:"1082",height:"276"})),(0,t.kt)("p",null,"\u6d41\u6c34\u7ebf\u64cd\u4f5c\u8981\u6bd4\u72b6\u6001\u673a\u64cd\u4f5c\u590d\u6742\u4e00\u4e9b\uff0c \u5c24\u5176\u65f6\u589e\u52a0\u4e86jtag \u7684\u8c03\u5f0f\u529f\u80fd\u4e4b\u540e\u3002\u8fd9\u4e2a\u90e8\u5206\u53ef\u4ee5\u53c2\u8003\u4ee5\u4e0a\u7684\u4ee3\u7801\uff0c \u540c\u65f6\u4eff\u771f\u6574\u4e2arisc-v \u7684\u5de5\u7a0b\uff0c\u5e2e\u52a9\u4e86\u89e3\u6d41\u6c34\u7ebf\u64cd\u4f5c\u7684\u76f8\u5173cpu \u8fd0\u4f5c\u3002"))}p.isMDXComponent=!0},57205:(n,_,e)=>{e.d(_,{Z:()=>r});const r=e.p+"assets/images/106-0803634f57f40d3a450e9969cd06cf78.jpeg"},58043:(n,_,e)=>{e.d(_,{Z:()=>r});const r=e.p+"assets/images/107-8002fcc8495a84978f505e83e19ce8bc.jpeg"},3044:(n,_,e)=>{e.d(_,{Z:()=>r});const r=e.p+"assets/images/108-e782648c99aeb269eaab65be7b3cbda2.jpeg"},20192:(n,_,e)=>{e.d(_,{Z:()=>r});const r=e.p+"assets/images/109-ec3455a8b79741b0c61ada06b08155a6.jpeg"}}]);