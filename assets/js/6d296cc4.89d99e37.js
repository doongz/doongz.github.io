"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[17494],{3905:(n,_,e)=>{e.d(_,{Zo:()=>d,kt:()=>c});var t=e(67294);function i(n,_,e){return _ in n?Object.defineProperty(n,_,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[_]=e,n}function r(n,_){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(n);_&&(t=t.filter((function(_){return Object.getOwnPropertyDescriptor(n,_).enumerable}))),e.push.apply(e,t)}return e}function a(n){for(var _=1;_<arguments.length;_++){var e=null!=arguments[_]?arguments[_]:{};_%2?r(Object(e),!0).forEach((function(_){i(n,_,e[_])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(_){Object.defineProperty(n,_,Object.getOwnPropertyDescriptor(e,_))}))}return n}function o(n,_){if(null==n)return{};var e,t,i=function(n,_){if(null==n)return{};var e,t,i={},r=Object.keys(n);for(t=0;t<r.length;t++)e=r[t],_.indexOf(e)>=0||(i[e]=n[e]);return i}(n,_);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(t=0;t<r.length;t++)e=r[t],_.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(i[e]=n[e])}return i}var p=t.createContext({}),s=function(n){var _=t.useContext(p),e=_;return n&&(e="function"==typeof n?n(_):a(a({},_),n)),e},d=function(n){var _=s(n.components);return t.createElement(p.Provider,{value:_},n.children)},u="mdxType",l={inlineCode:"code",wrapper:function(n){var _=n.children;return t.createElement(t.Fragment,{},_)}},m=t.forwardRef((function(n,_){var e=n.components,i=n.mdxType,r=n.originalType,p=n.parentName,d=o(n,["components","mdxType","originalType","parentName"]),u=s(e),m=i,c=u["".concat(p,".").concat(m)]||u[m]||l[m]||r;return e?t.createElement(c,a(a({ref:_},d),{},{components:e})):t.createElement(c,a({ref:_},d))}));function c(n,_){var e=arguments,i=_&&_.mdxType;if("string"==typeof n||i){var r=e.length,a=new Array(r);a[0]=m;var o={};for(var p in _)hasOwnProperty.call(_,p)&&(o[p]=_[p]);o.originalType=n,o[u]="string"==typeof n?n:i,a[1]=o;for(var s=2;s<r;s++)a[s]=e[s];return t.createElement.apply(null,a)}return t.createElement.apply(null,e)}m.displayName="MDXCreateElement"},401:(n,_,e)=>{e.r(_),e.d(_,{assets:()=>p,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var t=e(87462),i=(e(67294),e(3905));const r={},a="LSU & SRAM & GPIO\u6a21\u5757",o={unversionedId:"Skill/ASM/RISC-V/LOAD&STORE-UNIT",id:"Skill/ASM/RISC-V/LOAD&STORE-UNIT",title:"LSU & SRAM & GPIO\u6a21\u5757",description:"\u6765\u6e90\uff1ahttps://www.icfedu.cn/?s=RISC-V+LSU%EF%BC%8CSRAM",source:"@site/docs/Skill/ASM/RISC-V/6-LOAD&STORE-UNIT.md",sourceDirName:"Skill/ASM/RISC-V",slug:"/Skill/ASM/RISC-V/LOAD&STORE-UNIT",permalink:"/docs/Skill/ASM/RISC-V/LOAD&STORE-UNIT",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{},sidebar:"skillSidebar",previous:{title:"ALU \u6a21\u5757\u548c branch \u6a21\u5757",permalink:"/docs/Skill/ASM/RISC-V/ALU\u6a21\u5757&branch\u6a21\u5757"},next:{title:"CSR\u8bfb\u5199\u63a7\u5236",permalink:"/docs/Skill/ASM/RISC-V/CSR\u8bfb\u5199\u63a7\u5236"}},p={},s=[{value:"\u4e00\u3001exu_lsu\u6a21\u5757",id:"\u4e00exu_lsu\u6a21\u5757",level:2},{value:"LSU \u76f8\u5173\u4ee3\u7801",id:"lsu-\u76f8\u5173\u4ee3\u7801",level:3},{value:"\u4ee3\u7801\u5206\u6790",id:"\u4ee3\u7801\u5206\u6790",level:3},{value:"\u4e8c\u3001D_sram\u6a21\u5757",id:"\u4e8cd_sram\u6a21\u5757",level:2},{value:"SRAM \u4ee3\u7801",id:"sram-\u4ee3\u7801",level:3},{value:"\u4ee3\u7801\u5206\u6790",id:"\u4ee3\u7801\u5206\u6790-1",level:3},{value:"\u4e09\u3001fii_GPIO\u6a21\u5757",id:"\u4e09fii_gpio\u6a21\u5757",level:2},{value:"gpio \u6a21\u5757\u4ee3\u7801",id:"gpio-\u6a21\u5757\u4ee3\u7801",level:3},{value:"\u4ee3\u7801\u5206\u6790",id:"\u4ee3\u7801\u5206\u6790-2",level:3}],d={toc:s};function u(n){let{components:_,...r}=n;return(0,i.kt)("wrapper",(0,t.Z)({},d,r,{components:_,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"lsu--sram--gpio\u6a21\u5757"},"LSU & SRAM & GPIO\u6a21\u5757"),(0,i.kt)("p",null,"\u6765\u6e90\uff1a",(0,i.kt)("a",{parentName:"p",href:"https://www.icfedu.cn/?s=RISC-V+LSU%EF%BC%8CSRAM"},"https://www.icfedu.cn/?s=RISC-V+LSU%EF%BC%8CSRAM")),(0,i.kt)("p",null,"RISC-V LSU , SRAM, GPIO \u6a21\u5757\uff0c\u662f",(0,i.kt)("strong",{parentName:"p"},"\u5229\u7528RISC-V \u6307\u4ee4\u96c6\u4e2d\u7684LOAD, STORE \u76f8\u5173\u7684\u6307\u4ee4\u96c6\uff0c\u5bf9memory\uff0c \u6216\u8005\u5916\u8bbeperipheral \u7684\u8bbf\u5b58"),"\u3002"),(0,i.kt)("h2",{id:"\u4e00exu_lsu\u6a21\u5757"},"\u4e00\u3001exu_lsu\u6a21\u5757"),(0,i.kt)("p",null,"RISC-V \u7684LOAD, STORE \u662f\u7531\u4e00\u7ec4\u6307\u4ee4\u96c6\u7ec4\u6210\uff0c\u5305\u62ec"),(0,i.kt)("p",null,"LOAD: LBU, LB, LHU, LH, LW;"),(0,i.kt)("p",null,"STORE: SB, SH, SW"),(0,i.kt)("p",null,"\u4e24\u7ec4\u6307\u4ee4\u96c6\u3002"),(0,i.kt)("p",null,"load\uff0cstore \u6307\u4ee4\u96c6\u53ef\u4ee5\u8ba9risc-v cpu \u8bbf\u5b58 memory\uff0c uart\uff0c pwm \u7b49\u7b49\uff0c\u5f88\u591acpu \u5916\u90e8\u7684\u5b58\u50a8\u6a21\u5757\u3002 \u8fd9\u4e2a\u90e8\u5206\u4e5f\u662f\u4e00\u4e2a\u63a5\u53e3\uff0c\u5f53\u524d\u7684RISC-V \u7248\u672c\u4e3a2.01\uff0c\u5728\u540e\u7eed\u7684RISC-V fpga \u7248\u672c\u4e2d\uff0c \u4f1a\u5bf9\u8fd9\u4e2a\u6a21\u5757\u8fdb\u884c\u6539\u9020\uff1a\u5305\u62ec \u589e\u52a0\u7cfb\u7edf\u603b\u7ebf\uff0c \u8ba9\u6240\u6709\u5916\u8bbe\u90fd\u8fde\u63a5\u5230cpu \u7684\u5185\u90e8\u603b\u7ebf\u4e0a\uff0c \u65b9\u4fbf\u5404\u4e2a\u5916\u8bbe\u6a21\u5757\u7684\u5f00\u53d1\u3002",(0,i.kt)("strong",{parentName:"p"},"LSU \u6a21\u5757\u5c06\u5f62\u6210\u6570\u636e\u603b\u7ebf\u5730\u5740\uff0c \u5199\u4fe1\u53f7\uff0c \u8bfb\u4fe1\u53f7\uff0c \u5199\u6570\u636e\uff0c \u8bfb\u6570\u636e\u7b49"),"\u3002"),(0,i.kt)("p",null,"RISC-V cpu LSU \u67b6\u6784\uff1a"),(0,i.kt)("p",null,(0,i.kt)("img",{src:e(56342).Z,width:"1838",height:"1194"})),(0,i.kt)("p",null,(0,i.kt)("img",{src:e(42943).Z,width:"1334",height:"783"})),(0,i.kt)("h3",{id:"lsu-\u76f8\u5173\u4ee3\u7801"},"LSU \u76f8\u5173\u4ee3\u7801"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"module exu_LSU\n#(\n    parameter [ 31: 0 ] TMR_BASEADDR  = 32'h0200_0000,\n    parameter [ 31: 0 ] PLIC_BASEADDR = 32'h0c00_0000,\n    parameter [ 31: 0 ] CPU_BASEADDR  = 32'h8000_0000,\n    parameter [ 31: 0 ] MEM_BASEADDR  = 32'h9000_0000,\n    parameter [ 31: 0 ] GPIO_BASEADDR = 32'hf000_0000,\n    parameter [ 31: 0 ] UART_BASEADDR = 32'he000_0000,\n\n    parameter MEM_D_DEEP = 1024, //memory data depth\n    parameter MEM_D_W    = 32,   //memory data width\n    parameter MEM_MSK_W  = 4,    //memory data mask width\n    parameter MEM_ADDR_W = 32    //memory address width\n)\n(\ninput sys_clk,                 // \u7cfb\u7edf\u65f6\u949f\n//==============================================================================\ninput i_EXE_vld,               // \u6267\u884c\u6307\u4ee4enable\n// load & store address PC\ninput [ 31: 0 ] i_D_PC,        // load\uff0c store \u6307\u5411\u7684\u6570\u636e\u603b\u7ebf \u6307\u9488\n\ninput i_LOAD,                  // load \u6307\u4ee4\u96c6\ninput [ 4: 0 ] i_load_instr,   // load \u6307\u4ee4\u96c6\u5305\u62ec\uff1a{rv32i_lbu,rv32i_lb,rv32i_lhu,rv32i_lh,rv32i_lw};\n\ninput i_STORE,                 // store \u6307\u4ee4\u96c6\ninput [ 2: 0 ] i_store_instr,  // store \u6307\u4ee4\u96c6\u5305\u62ec\uff1a{rv32i_sb,rv32i_sh,rv32i_sw};\ninput [ 4: 0 ] i_rd_idx,       // \u8bd1\u7801\u6a21\u5757 \u8bd1\u7801\u51fa\u6765\u7684rd \u901a\u7528\u5bc4\u5b58\u5668id \ninput [ 31: 0 ] i_rs2_val,     // rs2 \u901a\u7528\u5bc4\u5b58\u5668\u503c\n//==============================================================================\ninput [ 31: 0 ] i_GPIO_dina,   // gpio \u6a21\u5757a\u7ec4 cpu\u5199\u5165\u6570\u636e\noutput [ 31: 0 ] o_GPIO_douta, // gpio \u6a21\u5757a\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\noutput [ 31: 0 ] o_GPIO_ta,    // gpio \u6a21\u5757a\u7ec4 \u65b9\u5411\u63a7\u5236\n\ninput [ 31: 0 ] i_GPIO_dinb,   // gpio \u6a21\u5757b\u7ec4 cpu\u5199\u5165\u6570\u636e\noutput [ 31: 0 ] o_GPIO_doutb, // gpio \u6a21\u5757b\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\noutput [ 31: 0 ] o_GPIO_tb,    // gpio \u6a21\u5757b\u7ec4 \u65b9\u5411\u63a7\u5236\n\ninput [ 31: 0 ] i_GPIO_dinc,   // gpio \u6a21\u5757c\u7ec4 cpu\u5199\u5165\u6570\u636e\noutput [ 31: 0 ] o_GPIO_doutc, // gpio \u6a21\u5757c\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\noutput [ 31: 0 ] o_GPIO_tc,    // gpio \u6a21\u5757c\u7ec4 \u65b9\u5411\u63a7\u5236\n\ninput [ 31: 0 ] i_GPIO_dind,   // gpio \u6a21\u5757d\u7ec4 cpu\u5199\u5165\u6570\u636e\noutput [ 31: 0 ] o_GPIO_doutd, // gpio \u6a21\u5757d\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\noutput [ 31: 0 ] o_GPIO_td,    // gpio \u6a21\u5757d\u7ec4 \u65b9\u5411\u63a7\u5236\n\n//==============================================================================\noutput txd_start,              // \u901a\u77e5uart \u5916\u8bbe\u6a21\u5757 \u5199 byte enable\noutput [ 7: 0 ] txd_data,      // \u53d1\u9001\u5230uart \u5916\u8bbe\u6a21\u5757 \u5199\u6570\u636e\ninput txd_done,                // uart \u5916\u8bbe\u6a21\u5757 \u8fd4\u56de\u7684 uart \u53d1\u9001\u6570\u636e\u5b8c\u6210\n//==============================================================================\noutput [ 31: 0 ] o_sft_int_v,  // \u8f6f\u4ef6\u4e2d\u65ad\u63a7\u5236\u5bc4\u5b58\u5668\noutput [ 31: 0 ] o_timer_l,    // timer \u8bbe\u7f6e\u5bc4\u5b58\u5668 \u4f4e32\u4f4d \noutput [ 31: 0 ] o_timer_h,    // timer \u8bbe\u7f6e\u5bc4\u5b58\u5668 \u9ad832\u4f4d\n\ninput [ 31: 0 ] i_timer_l,     // \u8bfb\u53d6\u5f53\u524dtimer \u8ba1\u6570\u5668 \u4f4e32\u4f4d \ninput [ 31: 0 ] i_timer_h,     // \u8bfb\u53d6\u5f53\u524dtimer \u8ba1\u6570\u5668 \u9ad832\u4f4d\n\noutput [ 31: 0 ] o_tcmp_l,     // timer \u6bd4\u8f83 \u5bc4\u5b58\u5668 \u4f4e32\u4f4d\noutput [ 31: 0 ] o_tcmp_h,     // timer \u6bd4\u8f83 \u5bc4\u5b58\u5668 \u9ad832\u4f4d\n\noutput [ 1: 0 ] o_timer_valid, // timer \u6709\u6548\u6807\u5fd7\n\noutput [ 31: 0 ] o_tm_ctrl,    // timer \u63a7\u5236\u5bc4\u5b58\u5668\n//==============================================================================\noutput o_CPU_cs,               // \u666e\u6797\u65af\u987f\u67b6\u6784\u4e2d \uff0c\u9009\u62e9\u7684\u6570\u636e\u5728 ITCM\u7a7a\u95f4 \u6807\u8bc6\noutput [ 31: 0 ] o_CPU_PC,     // \u666e\u6797\u65af\u987f\u67b6\u6784\u4e2d \uff0c\u9009\u62e9\u7684\u6570\u636e\u5728 ITCM\u7a7a\u95f4 \u5730\u5740\ninput [ 31: 0 ] i_CPU_load_data,// \u666e\u6797\u65af\u987f\u67b6\u6784\u4e2d \uff0c\u4eceITCM\u7a7a\u95f4\u8bfb\u53d6\u7684\u6570\u636e\n\noutput o_ls_need,              // load\u6216\u8005store \u6307\u4ee4 \u6807\u8bc6\noutput o_ls_rdy,               // load \u6216\u8005 stroe \u6709\u6548\n\noutput o_rd_wen,               // \u5199\u56de \u901a\u7528\u5bc4\u5b58\u5668 enable\noutput [ 4: 0 ] o_wb_rd_idx,   // \u5199\u56de \u901a\u7528\u5bc4\u5b58\u5668 id \noutput reg[ 31: 0 ] o_wb_data, // \u5199\u56de \u901a\u7528\u5bc4\u5b58\u5668 \u503c\n\ninput i_cpu_reset,             // cpu \u5185\u6838 reset\ninput rst_n\n);\n\nwire [31: 0] cpu_data_in = i_rs2_val << {i_D_PC[1:0],3'b000};\n//==============================================================================\n// Memory section\nwire mem_cs = ( i_D_PC[ 31: 16 ] == MEM_BASEADDR[ 31: 16 ] );\nreg mem_we;\nreg [ 3: 0 ] mem_wem;        // memory mask\nwire [ 31: 0 ] mem_dout;     // memory dout\nwire [ 31: 0 ] mem_addr_out; // not at all\n//wire mem_init_rdy;\n//==============================================================================\n// GPIO section\nwire [ 31: 0 ] rb_GPIO_d;\nwire GPIO_cs = ( i_D_PC[ 31: 16 ] == GPIO_BASEADDR[ 31: 16 ] ) ? 1'b1 : 1'b0;\n\nwire GPIO_we;\nwire [ 3: 0 ] GPIO_wem; // gpio mask\n//==============================================================================\nwire UART_cs = ( i_D_PC[ 31: 16 ] == UART_BASEADDR[ 31: 16 ] ) ? 1'b1 : 1'b0;\nwire [ 31: 0 ] o_UART_dout;\n//==============================================================================\nwire PLIC_cs = ( i_D_PC[ 31: 16 ] == PLIC_BASEADDR[ 31: 16 ] ) ? 1'b1 : 1'b0;\nwire [ 31: 0 ] o_PLIC_dout;\n//==============================================================================\n\nwire t_sft_cs   = ( i_D_PC[ 31: 16 ] == TMR_BASEADDR[ 31: 16 ] ) ? 1'b1 : 1'b0;\nwire sft_cs     = t_sft_cs & ( ( ~i_D_PC[ 12 ] ) & ( i_D_PC[ 5: 2 ] == 0 ) );\nwire tm_ctrl_cs = t_sft_cs & ( ( ~i_D_PC[ 12 ] ) & ( i_D_PC[ 5: 2 ] == 1 ) );\nwire t_cs0      = t_sft_cs & ( ( ~i_D_PC[ 12 ] ) & ( i_D_PC[ 5: 2 ] == 2 ) );\nwire t_cs1      = t_sft_cs & ( ( ~i_D_PC[ 12 ] ) & ( i_D_PC[ 5: 2 ] == 3 ) );\nwire tcmp_cs0   = t_sft_cs & ( ( ~i_D_PC[ 12 ] ) & ( i_D_PC[ 5: 2 ] == 4 ) );\nwire tcmp_cs1   = t_sft_cs & ( ( ~i_D_PC[ 12 ] ) & ( i_D_PC[ 5: 2 ] == 5 ) );\n\nwire fpga_ver_cs  = t_sft_cs & ( i_D_PC[ 12 ] & ( i_D_PC[ 5: 2 ] == 0 ) );\nwire fpga_test_cs = t_sft_cs & ( i_D_PC[ 12 ] & ( i_D_PC[ 5: 2 ] == 1 ) );\n\nwire [31:0] fpga_ver = 32'h0000_0201;\nreg [31:0] fpga_test = 32'h0000_0000;\n\n\nalways @ (posedge sys_clk) \nif ( fpga_test_cs )\nbegin\n    if (mem_wem[0])\n        fpga_test[ 7: 0] <= cpu_data_in[ 7: 0] ;\n    if (mem_wem[1])\n        fpga_test[15: 8] <= cpu_data_in[15: 8] ;\n    if (mem_wem[2])\n        fpga_test[23:16] <= cpu_data_in[23:16] ;\n    if (mem_wem[3])\n        fpga_test[31:24] <= cpu_data_in[31:24] ;\nend\n//==============================================================================\n//assign o_CPU_cs = ( i_D_PC[ 31: 16 ] == CPU_BASEADDR[ 31: 16 ] ) ? i_LOAD & i_EXE_vld : 1'b0;\nreg CPU_cs = 0;\nalways @ (*)\nif(i_EXE_vld)\n    CPU_cs = ( i_D_PC[ 31: 16 ] == CPU_BASEADDR[ 31: 16 ] ) ? i_LOAD : 1'b0;\n\nassign o_CPU_cs = CPU_cs;\n//assign o_CPU_cs = ( i_D_PC[ 31: 16 ] == CPU_BASEADDR[ 31: 16 ] ) ? i_LOAD : 1'b0;\nassign o_CPU_PC = { i_D_PC[ 31: 2 ], 2'b00 };\n\n\n// lock current data address\nreg [ 1: 0 ] data_sft_r = 0;\nalways @ (posedge sys_clk)\nif(o_CPU_cs & i_EXE_vld)\n    data_sft_r <= i_D_PC[1:0];\n\nwire [ 4: 0 ] data_sft = {data_sft_r[ 1: 0 ], 3'b000};\n\n//wire [ 4: 0 ] data_sft = {i_D_PC[ 1: 0 ], 3'b000};\nwire [ 31: 0 ] o_CPU_dout = i_CPU_load_data >> data_sft;\n\n//==============================================================================\nwire [ 31: 0 ] ls_rb_d_t_sft = sft_cs         ? o_sft_int_v :\n                               ( tm_ctrl_cs   ? o_tm_ctrl :\n                               ( t_cs0        ? i_timer_l :\n                               ( t_cs1        ? i_timer_h :\n                               ( fpga_ver_cs  ? fpga_ver :\n                               ( fpga_test_cs ? (fpga_test>>{i_D_PC[1:0],3'b000}) :\n                               ( tcmp_cs0     ? o_tcmp_l :\n                               ( tcmp_cs1     ? o_tcmp_h : o_CPU_dout ) ) ) ) )));\n\nwire [ 31: 0 ] ls_rb_d = mem_cs ? mem_dout : ( GPIO_cs ? rb_GPIO_d : ( UART_cs ? o_UART_dout : ls_rb_d_t_sft ) );\n\n//wire [ 31: 0 ] ls_rb_d = mem_cs ? mem_dout : ( GPIO_cs ? rb_GPIO_d : ( UART_cs ? o_UART_dout : o_CPU_dout ) );\nalways@( * )\nbegin\n    mem_we <= 1'b0;\n    mem_wem <= 4'b0;\n    o_wb_data <= 32'b0;\n\n    if ( i_LOAD )\n    begin //&mem_init_rdy\n        case ( i_load_instr ) // i_load_instr ={rv32i_lbu, rv32i_lb, rv32i_lhu, rv32i_lh, rv32i_lw};\n        5'b00001:\n        begin //rv32i_lw\n            o_wb_data <= ls_rb_d;\n        end\n        5'b00010:\n        begin //rv32i_lh\n            o_wb_data <= { { 16{ ls_rb_d[ 15 ] } }, ls_rb_d[ 15: 0 ] };\n        end\n        5'b00100:\n        begin //rv32i_lhu\n            o_wb_data <= { { 16{ 1'b0 } }, ls_rb_d[ 15: 0 ] };\n        end\n        5'b01000:\n        begin //rv32i_lb\n            o_wb_data <= { { 24{ ls_rb_d[ 7 ] } }, ls_rb_d[ 7: 0 ] };\n        end\n        5'b10000:\n        begin //rv32i_lbu\n            o_wb_data <= { { 24{ 1'b0 } }, ls_rb_d[ 7: 0 ] };\n        end\n        default: ;\n        endcase\n    end\n\n    if ( i_STORE )\n    begin //&mem_init_rdy\n        mem_we <= 1'b1;\n\n        case ( i_store_instr ) //i_store_instr ={rv32i_sb, rv32i_sh, rv32i_sw};\n        3'b001:\n        begin //rv32i_sw\n            mem_wem <= 4'b1111; \n        end\n        3'b010:\n        begin //rv32i_sh\n            mem_wem <= 4'b0011 << {i_D_PC[1],1'b0}; \n        end\n        3'b100:\n        begin //rv32i_sb\n            mem_wem <= 4'b0001 << i_D_PC[1:0]; \n        end\n        default:\n            mem_wem <= 4'b0;\n\n        endcase\n    end\nend\n\n//==============================================================================\nD_sram\n#(\n    .MEM_D_DEEP ( MEM_D_DEEP ),\n    .MEM_D_W    ( MEM_D_W ),\n    .MEM_MSK_W  ( MEM_MSK_W ),\n    .MEM_ADDR_W ( MEM_ADDR_W )\n)\nD_sram_inst\n(\n    .clk   ( sys_clk ),\n    .rst_n ( rst_n ),\n\n    .din   ( cpu_data_in ),\n    .addr  ( i_D_PC ),\n    .dout  ( mem_dout ),\n\n    .cs    ( mem_cs ),\n    .we    ( mem_we ),\n    .wem   ( mem_wem ),\n\n//.mem_init_rdy (mem_init_rdy),\n    .o_D_PC ( mem_addr_out ) //not at all\n);\n\n//==============================================================================\nassign GPIO_we = mem_we;\nassign GPIO_wem = mem_wem;\n\nfii_GPIO\n#(\n    .GPIO_DEEP   ( 8 ), // register number\n    .GPIO_W      ( MEM_D_W ),\n    .GPIO_MSK_W  ( MEM_MSK_W ),\n    .GPIO_ADDR_W ( MEM_ADDR_W )\n) fii_GPIO_inst\n(\n    .clk          ( sys_clk ),\n    .rst_n        ( rst_n ),\n\n    .i_ls_GPIO_din  ( cpu_data_in ),\n    .o_rb_GPIO_dout ( rb_GPIO_d ),\n\n    .i_addr       ( i_D_PC ),\n    .i_cs         ( GPIO_cs ),\n    .i_we         ( GPIO_we ),\n    .i_wem        ( GPIO_wem ),\n\n    .i_GPIO_dina  ( i_GPIO_dina ),\n    .o_GPIO_douta ( o_GPIO_douta ),\n    .o_GPIO_ta    ( o_GPIO_ta ),\n\n    .i_GPIO_dinb  ( i_GPIO_dinb ),\n    .o_GPIO_doutb ( o_GPIO_doutb ),\n    .o_GPIO_tb    ( o_GPIO_tb ),\n\n    .i_GPIO_dinc  ( i_GPIO_dinc ),\n    .o_GPIO_doutc ( o_GPIO_doutc ),\n    .o_GPIO_tc    ( o_GPIO_tc ),\n\n    .i_GPIO_dind  ( i_GPIO_dind ),\n    .o_GPIO_doutd ( o_GPIO_doutd ),\n    .o_GPIO_td    ( o_GPIO_td )\n);\n//===============================================================================\nwire UART_we = mem_we;\nwire UART_wem = mem_wem;\n\nfii_UART fii_UART_inst\n(\n    .clk         ( sys_clk ),\n\n    .i_PERI_din  ( cpu_data_in ),\n    .o_PERI_dout ( o_UART_dout ),\n\n    .i_addr      ( i_D_PC ),\n    .i_cs        ( UART_cs ),\n    .i_we        ( UART_we ),\n    .i_wem       ( UART_wem ),\n\n    .txd_start   ( txd_start ),\n    .txd_data    ( txd_data ),\n    .txd_done    ( txd_done ),\n\n    .rst_n       ( rst_n )\n);\n\n\n//===============================================================================\n\nwire tmr_sft_we = mem_we;\n\nfii_timer_lsu fii_timer_lsu_inst\n(\n    .clk             ( sys_clk ),\n\n    .i_sft_timer_din ( cpu_data_in ),\n    .i_tmr_sft_we    ( tmr_sft_we ),\n\n    .i_tm_ctrl_cs    ( tm_ctrl_cs ),\n    .o_tm_ctrl       ( o_tm_ctrl ),\n\n    .i_sft_cs        ( sft_cs ),\n    .o_sft_int_v     ( o_sft_int_v ),\n\n    .i_tcs0          ( t_cs0 ),\n    .o_timer_l       ( o_timer_l ),\n\n    .i_tcs1          ( t_cs1 ),\n    .o_timer_h       ( o_timer_h ),\n\n    .i_tcmp_cs0      ( tcmp_cs0 ),\n    .o_tcmp_l        ( o_tcmp_l ),\n\n    .i_tcmp_cs1      ( tcmp_cs1 ),\n    .o_tcmp_h        ( o_tcmp_h ),\n\n    .o_timer_valid   ( o_timer_valid ),\n\n    .rst_n           ( rst_n & (!i_cpu_reset))\n);\n\n\n//===============================\n\n\nassign o_rd_wen  = i_LOAD; //o_wb_need\nassign o_ls_need = i_LOAD | i_STORE;\nassign o_ls_rdy  = 1;\n\nassign o_wb_rd_idx = i_rd_idx;\n//===============================================================================\n\nendmodule\n")),(0,i.kt)("h3",{id:"\u4ee3\u7801\u5206\u6790"},"\u4ee3\u7801\u5206\u6790"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u7aef\u53e3\u63cf\u8ff0\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"input i_EXE_vld,          // \u6267\u884c\u6307\u4ee4enable\n// load & store address PC\ninput [ 31: 0 ] i_D_PC,     // load\uff0c store \u6307\u5411\u7684\u6570\u636e\u603b\u7ebf \u6307\u9488\n\ninput i_LOAD,            // load \u6307\u4ee4\u96c6\ninput [ 4: 0 ] i_load_instr,  // load \u6307\u4ee4\u96c6\u5305\u62ec\uff1a{rv32i_lbu, rv32i_lb, rv32i_lhu, rv32i_lh, rv32i_lw};\n\ninput i_STORE,           // store \u6307\u4ee4\u96c6\ninput [ 2: 0 ] i_store_instr, // store \u6307\u4ee4\u96c6\u5305\u62ec\uff1a{rv32i_sb, rv32i_sh, rv32i_sw};\ninput [ 4: 0 ] i_rd_idx,     // \u8bd1\u7801\u6a21\u5757 \u8bd1\u7801\u51fa\u6765\u7684rd \u901a\u7528\u5bc4\u5b58\u5668id\ninput [ 31: 0 ] i_rs2_val,    // rs2 \u901a\u7528\u5bc4\u5b58\u5668\u503c\n")),(0,i.kt)("p",null,"\u4ee5\u4e0a\u8fd9\u4e9b\u4fe1\u53f7\u548c cpu \u5185\u6838\u76f8\u5173\uff0c \u90fd\u662f\u4ece\u8bd1\u7801\u6a21\u5757 \u548c \u6267\u884c\u6a21\u5757 \u8fc7\u6765\u7684\u3002"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"gpio \u7ec4 \u7aef\u53e3\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"input [ 31: 0 ] i_GPIO_dina,        // gpio \u6a21\u5757a\u7ec4 cpu\u5199\u5165\u6570\u636e\noutput [ 31: 0 ] o_GPIO_douta,  // gpio \u6a21\u5757a\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\noutput [ 31: 0 ] o_GPIO_ta,         // gpio \u6a21\u5757a\u7ec4 \u65b9\u5411\u63a7\u5236\n\ninput [ 31: 0 ] i_GPIO_dinb,       // gpio \u6a21\u5757b\u7ec4 cpu\u5199\u5165\u6570\u636e\noutput [ 31: 0 ] o_GPIO_doutb, // gpio \u6a21\u5757b\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\noutput [ 31: 0 ] o_GPIO_tb,        // gpio \u6a21\u5757b\u7ec4 \u65b9\u5411\u63a7\u5236\n\ninput [ 31: 0 ] i_GPIO_dinc,        // gpio \u6a21\u5757c\u7ec4 cpu\u5199\u5165\u6570\u636e\noutput [ 31: 0 ] o_GPIO_doutc,  // gpio \u6a21\u5757c\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\noutput [ 31: 0 ] o_GPIO_tc,         // gpio \u6a21\u5757c\u7ec4 \u65b9\u5411\u63a7\u5236\n\ninput [ 31: 0 ] i_GPIO_dind,        // gpio \u6a21\u5757d\u7ec4 cpu\u5199\u5165\u6570\u636e\noutput [ 31: 0 ] o_GPIO_doutd,  // gpio \u6a21\u5757d\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\noutput [ 31: 0 ] o_GPIO_td,         // gpio \u6a21\u5757d\u7ec4 \u65b9\u5411\u63a7\u5236\n")),(0,i.kt)("p",null,"\u5728\u5f53\u524dLSU\u6a21\u5757\u63a5\u53e3\u4e2d\uff0c \u6211\u4eec\u8bbe\u8ba1\u4e86gpio \u7684\u5916\u8bbe\uff0c \u5b9a\u4e49\u4e864\u4e2a\u7ec4 gpio a\uff0cb\uff0c c\uff0c d \u3002 \u5176\u4e2d\u6bcf\u4e00\u4e2a\u7ec4\u5185\u5305\u62ec32\u4e2agpio pin \u3002 \u6240\u6709gpio pin \u90fd\u662f inout \uff0c\u8fd9\u4e9b\u4fe1\u53f7\u5728\u6574\u4e2a\u5de5\u7a0b\u7684\u9876\u5c42\u6a21\u5757\u6709\u76f8\u5173\u7684\u5b9a\u4e49\u6765\u914d\u5408 gpio \u7ec4\u7aef\u53e3\u3002"),(0,i.kt)("p",null,"\u6574\u4e2aRISC-V \u5de5\u7a0b\u7684",(0,i.kt)("strong",{parentName:"p"},"\u9876\u5c42\u6a21\u5757"),"\u793a\u4f8b\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"fii_iobuf #( .IO_WIDTH( 32 ) )\nfii_iobuf_insta\n(\n    .i_dio_t  ( gpio_ta ),  // \u5bf9\u5e94\u5f53\u524d\u6a21\u5757\u7684 o_GPIO_ta\n    .i_dio    ( gpio_oa ),  // \u5bf9\u5e94\u5f53\u524d\u6a21\u5757\u7684 o_GPIO_douta\n    .o_dio    ( gpio_ia ),  // \u5bf9\u5e94\u5f53\u524d\u6a21\u5757\u7684 o_GPIO_dina\n    .io_dio_p ( gpio_a )    // \u5bf9\u5e94fpga \u771f\u6b63\u7684PIN\n);\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"uart \u6a21\u5757\u7aef\u53e3\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"output txd_start,          // \u901a\u77e5uart \u5916\u8bbe\u6a21\u5757 \u5199 byte enable\noutput [ 7: 0 ] txd_data,  // \u53d1\u9001\u5230uart \u5916\u8bbe\u6a21\u5757 \u5199\u6570\u636e\ninput txd_done,            // uart \u5916\u8bbe\u6a21\u5757 \u8fd4\u56de\u7684 uart \u53d1\u9001\u6570\u636e\u5b8c\u6210\n")),(0,i.kt)("p",null,"\u5728\u5f53\u524dLSU\u6a21\u5757\u63a5\u53e3\u4e2d\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86uart \u6a21\u5757\u3002 \u8fd9\u4e9b\u63a5\u53e3 \u4e00\u7aef \u548c cpu load\uff0cstore\u4fe1\u53f7 \u63a5\u53e3\uff0c \u53e6\u5916\u4e00\u7aef txd_start, txd_data, txd_done \u5c06\u8fde\u63a5\u5230\u771f\u6b63\u7684uart \u901a\u8baf\u6a21\u5757\u3002"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"timer \u63a5\u53e3\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"output [ 31: 0 ] o_sft_int_v,   // \u8f6f\u4ef6\u4e2d\u65ad\u63a7\u5236\u5bc4\u5b58\u5668\noutput [ 31: 0 ] o_timer_l,     // timer \u8bbe\u7f6e\u5bc4\u5b58\u5668 \u4f4e32\u4f4d\noutput [ 31: 0 ] o_timer_h,     // timer \u8bbe\u7f6e\u5bc4\u5b58\u5668 \u9ad832\u4f4d\n\ninput [ 31: 0 ] i_timer_l,      // \u8bfb\u53d6\u5f53\u524dtimer \u8ba1\u6570\u5668 \u4f4e32\u4f4d\ninput [ 31: 0 ] i_timer_h,      // \u8bfb\u53d6\u5f53\u524dtimer \u8ba1\u6570\u5668 \u9ad832\u4f4d\n\noutput [ 31: 0 ] o_tcmp_l,      // timer \u6bd4\u8f83 \u5bc4\u5b58\u5668 \u4f4e32\u4f4d\noutput [ 31: 0 ] o_tcmp_h,      // timer \u6bd4\u8f83 \u5bc4\u5b58\u5668 \u9ad832\u4f4d\n\noutput [ 1: 0 ] o_timer_valid,  // timer \u6709\u6548\u6807\u5fd7\n\noutput [ 31: 0 ] o_tm_ctrl,     // timer \u63a7\u5236\u5bc4\u5b58\u5668\n")),(0,i.kt)("p",null,"\u5728\u5f53\u524d\u7684LSU \u6a21\u5757\u63a5\u53e3\u4e2d\uff0c \u6211\u4eec\u5b9a\u4e49\u4e86timer \u6a21\u5757\u3002"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"ITCM \u6a21\u5757\u7684\u63a5\u53e3\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"output o_CPU_cs,                 // \u666e\u6797\u65af\u987f\u67b6\u6784\u4e2d \uff0c\u9009\u62e9\u7684\u6570\u636e\u5728 ITCM\u7a7a\u95f4 \u6807\u8bc6\noutput [ 31: 0 ] o_CPU_PC,       // \u666e\u6797\u65af\u987f\u67b6\u6784\u4e2d \uff0c\u9009\u62e9\u7684\u6570\u636e\u5728 ITCM\u7a7a\u95f4 \u5730\u5740\ninput [ 31: 0 ] i_CPU_load_data, // \u666e\u6797\u65af\u987f\u67b6\u6784\u4e2d \uff0c\u4eceITCM\u7a7a\u95f4\u8bfb\u53d6\u7684\u6570\u636e\n")),(0,i.kt)("p",null,"\u8fd9\u51e0\u4e2a\u4fe1\u53f7\u7528\u4e8e\u8bfb\u53d6\u76f8\u5173\u7684\u6570\u636e\uff0c \u5728\u6211\u4eec\u4f7f\u7528\u6c47\u7f16\u6307\u4ee4\u65f6\uff0c\u6709\u65f6 load \u7684\u6570\u636e \u6b63\u597d\u5728ITCM \u533a\u57df\uff0c \u8fd9\u65f6\uff0c \u6307\u4ee4pc \u5c31\u9700\u8981\u8df3\u8f6c\u5230itcm \u6570\u636e\u7aef\uff0c \u5c06\u6570\u636e\u8bfb\u51fa\uff08\u4e0d\u8ba4\u4e3a\u8bfb\u51fa\u6570\u636e\u65f6\u6307\u4ee4\u673a\u5668\u7801\uff09\uff0c\u8bfb\u51fa\u4e4b\u540e\uff0c \u5728\u5c06pc \u8fd8\u539f\u4f1a\u5f53\u4e2d\u6b63\u5728\u6267\u884c\u4ee3\u7801\u7684pc \u503c\u3002"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u5916\u90e8\u63a5\u53e3\u4fe1\u53f7\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"output o_ls_need,  // load\u6216\u8005store \u6307\u4ee4 \u6807\u8bc6\uff0c\u4e3a\u5176\u4ed6\u6a21\u5757\u505a\u6307\u793a\u3002\noutput o_ls_rdy,   // load \u6216\u8005 stroe \u6709\u6548 \uff0c\u8fd9\u4e2a\u4fe1\u53f7\u4e00\u76f4\u4e3a\u4e00\u3002\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u901a\u7528\u5bc4\u5b58\u5668\u5199\u56de \u7aef\u53e3:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"output o_rd_wen,                // \u5199\u56de \u901a\u7528\u5bc4\u5b58\u5668 enable\noutput [ 4: 0 ] o_wb_rd_idx,    // \u5199\u56de \u901a\u7528\u5bc4\u5b58\u5668 id\noutput reg[ 31: 0 ] o_wb_data,  // \u5199\u56de \u901a\u7528\u5bc4\u5b58\u5668 \u503c\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u4ee3\u7801\u5206\u6790\uff1a")),(0,i.kt)("p",null,"wire ","[31: 0]"," cpu_data_in = i_rs2_val << {i_D_PC","[1:0]",",3\u2019b000};"),(0,i.kt)("p",null,"\u5728store \u76f8\u5173\u7684\u6307\u4ee4\u5305\u62ec SB, SH, SW ,\u5176\u4e2d\uff1a"),(0,i.kt)("p",null,"SB \u7684\u5730\u5740 \uff08i_D_PC) \u53ef\u4ee5\u65f6 0 \u2013 4G \u7684\u4efb\u4f55\u5730\u5740\u3002 \u6ce8\u610f\uff1a\u8fd9\u4e2a\u5730\u5740\u662f\u54c8\u4f5b\u67b6\u6784\u4e2d\u7684\u6570\u636e\u5730\u5740\uff0c\uff08\u6ca1\u6709\u50cf\u6307\u4ee4\u5730\u5740\u90a3\u6837\uff1a RV32 \u5fc5\u987b\u662f 4bytes \u5bf9\u9f50\u7684\uff0c RV32C \u4e2d \u53ef\u4ee5\u67092bytes \u5bf9\u9f50\u7684\uff09\uff0c\u5b83\u53ef\u4ee5\u662f\u4efb\u4f55\u5730\u5740 \uff0c\u4f8b\u5982\uff1a 0x9000_00000, 0x9000_00001, 0x9000_00002, 0x9000_00003\u3002\u6ca1\u6709\u5bf9\u9f50\u4e00\u8bf4\u3002sb \u6307\u4ee4\u53ef\u4ee5\u8bbf\u95ee\u4efb\u4f55\u4e00\u4e2a\u5730\u5740\u3002 \u6240\u4ee5 \u6211\u4eec\u4f1a\u5206\u6790i_D_PC","[1:0]",", \u5b83\u67094\u79cd\u9009\u62e9\uff1a"),(0,i.kt)("p",null,"2\u2019b00:  \u8868\u793a\u5f53\u524d\u5730\u5740\u6b63\u597d\u662f4bytes \u5bf9\u9f50\u7684\uff08\u5730\u5740\u53ef\u4ee5\u88ab4 \u6574\u9664\uff09\uff0c \u6b63\u597d\u5bf9\u5e94\u7684\u6570\u636e\u4e3a i_rs2_val","[7:0]"," \uff0c \u5de6\u79fb 0 \u4f4d"),(0,i.kt)("p",null,"2\u2019b01: \u8868\u793a\u5f53\u524d\u5730\u5740\u88ab4 \u6574\u9664\u540e \u4f59\u6570 1\uff0c \u5c06\u6570\u636e\u4e3a i_rs2_val","[7:0]"," \uff0c \u5de6\u79fb 8 \u4f4d"),(0,i.kt)("p",null,"2\u2019b10: \u8868\u793a\u5f53\u524d\u5730\u5740\u88ab4 \u6574\u9664\u540e \u4f59\u6570 2\uff0c \u5c06\u6570\u636e\u4e3a i_rs2_val","[7:0]"," \uff0c \u5de6\u79fb 16 \u4f4d"),(0,i.kt)("p",null,"2b\u201911: \u8868\u793a\u5f53\u524d\u5730\u5740\u88ab4 \u6574\u9664\u540e \u4f59\u6570 3\uff0c \u5c06\u6570\u636e\u4e3a i_rs2_val","[7:0]"," \uff0c \u5de6\u79fb 24 \u4f4d"),(0,i.kt)("p",null,"SH \u7684\u5730\u5740\u548c\u4e0a\u9762\u7684\u60c5\u51b5\u7c7b\u4f3c\uff0c \u53ea\u662f\u53ea\u6709 2\u201900, 2\u2019b10 \u8fd92\u79cd\u60c5\u51b5\u800c\u5df2\u3002"),(0,i.kt)("p",null,"SW \u7684\u5730\u5740\u548c\u4e0a\u9762\u7684\u60c5\u51b5\u7c7b\u4f3c\uff0c \u53ea\u662f\u53ea\u6709 2\u201900, \u8fd91\u79cd\u60c5\u51b5\u800c\u5df2\u3002"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"memory \u6bb5:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire mem_cs = ( i_D_PC[ 31: 16 ] == MEM_BASEADDR[ 31: 16 ] );  //\u7247\u9009\u4fe1\u53f7\uff0c \u5bf9\u5e94\u7684\u6b63\u597d\u662fDTCM \u5730\u5740\u7a7a\u95f4\u3002\nreg mem_we; // store \u6307\u4ee4\u7ec4\u4e2d\uff0c\u4efb\u4f55\u4e00\u4e2a\u6709\u6548(sb,sh,sw) , \u5f53\u524d\u8fd9\u4e2a\u4fe1\u53f7\u6709\u6548\nreg [ 3: 0 ] mem_wem; // \u5199\u5c4f\u853d\uff0c 4bit\uff0c \u4efb\u4f55\u4e00\u4e2abit \u4f4d 1\uff0c \u76f8\u5e94\u7684\u6570\u636e\u88ab\u5199\u5165\u5230DTCM\u3002\u4e3e\u4f8b\uff1a mem_wem = 4\u2019b0100, \u90a3\u4e48 cpu_data_in[23:16] \u88ab\u5199\u5165\u5230DTCM\nwire [ 31: 0 ] mem_dout; // \u4ecedtcm \u4e2d\u8bfb\u53d6\u6570\u636e\nwire [ 31: 0 ] mem_addr_out; // \u76ee\u524d\u6ca1\u6709\u4f7f\u7528\u3002\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"gpio \u6bb5\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire [ 31: 0 ] rb_GPIO_d; // \u4ecegpio \u5bc4\u5b58\u5668\u4e2d\u8bfb\u51fa\u7684\u6570\u636e\nwire GPIO_cs = ( i_D_PC[ 31: 16 ] == GPIO_BASEADDR[ 31: 16 ] ) ? 1\u2019b1 : 1\u2019b0; // gpio \u5bc4\u5b58\u5668 \u7247\u9009\n\nwire GPIO_we; // gpio \u5bc4\u5b58\u5668 \u5199\u4fe1\u53f7 \u548c mem_we \u4e00\u6837\u4f7f\u7528\u3002\nwire [ 3: 0 ] GPIO_wem; // gpio \u5bc4\u5b58\u5668 \u5199\u5c4f\u853d \uff0c\u548c mem_wem \u4f7f\u7528\u4e00\u6837\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"uart \u6bb5\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire UART_cs = ( i_D_PC[ 31: 16 ] == UART_BASEADDR[ 31: 16 ] ) ? 1\u2019b1 : 1\u2019b0;  // uart \u5bc4\u5b58\u5668\u7ec4 \u7247\u9009\nwire [ 31: 0 ] o_UART_dout;  // uart \u5bc4\u5b58\u5668 \u4e2d\u8bfb\u51fa\u7684\u6570\u636e\n\nwire PLIC_cs = ( i_D_PC[ 31: 16 ] == PLIC_BASEADDR[ 31: 16 ] ) ? 1\u2019b1 : 1\u2019b0;  // \u76ee\u524d\u6ca1\u6709\u4f7f\u7528\nwire [ 31: 0 ] o_PLIC_dout;   // \u76ee\u524d\u6ca1\u6709\u4f7f\u7528\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"timer \u5bc4\u5b58\u5668 \u7247\u9009\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire t_sft_cs   = ( i_D_PC[ 31: 16 ] == TMR_BASEADDR[ 31: 16 ] ) ? 1'b1 : 1'b0;  // timer \u5bc4\u5b58\u5668\u7ec4\u6bb5 \u7247\u9009\nwire sft_cs     = t_sft_cs & ( ( ~i_D_PC[ 12 ] ) & ( i_D_PC[ 5: 2 ] == 0 ) );    // \u8f6f\u4ef6\u4e2d\u65ad \u9009\u62e9\nwire tm_ctrl_cs = t_sft_cs & ( ( ~i_D_PC[ 12 ] ) & ( i_D_PC[ 5: 2 ] == 1 ) );    // timer \u63a7\u5236\u5bc4\u5b58\u5668 \u9009\u62e9\nwire t_cs0      = t_sft_cs & ( ( ~i_D_PC[ 12 ] ) & ( i_D_PC[ 5: 2 ] == 2 ) );    // timer \u5bc4\u5b58\u5668 \u4f4e32\u4f4d\u9009\u62e9\nwire t_cs1      = t_sft_cs & ( ( ~i_D_PC[ 12 ] ) & ( i_D_PC[ 5: 2 ] == 3 ) );    // timer \u5bc4\u5b58\u5668 \u9ad832\u4f4d\u9009\u62e9\nwire tcmp_cs0   = t_sft_cs & ( ( ~i_D_PC[ 12 ] ) & ( i_D_PC[ 5: 2 ] == 4 ) );    // timer\u6bd4\u8f83\u5bc4\u5b58\u5668\u4f4e32\u4f4d \u9009\u62e9\nwire tcmp_cs1   = t_sft_cs & ( ( ~i_D_PC[ 12 ] ) & ( i_D_PC[ 5: 2 ] == 5 ) );    // timer\u6bd4\u8f83\u5bc4\u5b58\u5668\u9ad832\u4f4d \u9009\u62e9\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u7248\u672c\u548c\u6d4b\u8bd5\u5bc4\u5b58\u5668\u7247\u9009\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire fpga_ver_cs  = t_sft_cs & ( i_D_PC[ 12 ] & ( i_D_PC[ 5: 2 ] == 0 ) );\nwire fpga_test_cs = t_sft_cs & ( i_D_PC[ 12 ] & ( i_D_PC[ 5: 2 ] == 1 ) );\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u6d4b\u8bd5\u5bc4\u5b58\u5668\u5199\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"always @ (posedge sys_clk)\nif ( fpga_test_cs )\nbegin\n    if (mem_wem[0])\n        fpga_test[ 7: 0] <= cpu_data_in[ 7: 0] ;\n    if (mem_wem[1])\n        fpga_test[15: 8] <= cpu_data_in[15: 8] ;\n    if (mem_wem[2])\n        fpga_test[23:16] <= cpu_data_in[23:16] ;\n    if (mem_wem[3])\n        fpga_test[31:24] <= cpu_data_in[31:24] ;\nend\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"load ITCM \u4e2d\u7684\u6570\u636e\uff1a")),(0,i.kt)("p",null,"\u666e\u6797\u65af\u987f\u67b6\u6784\u4e2d\u4f1a\u4f7f\u7528, \u901a\u77e5 itcm \uff0c\u5f53\u524d\u9700\u8981\u4eceitcm \u533a\u57df\u4e2d\u8bfb\u53d6\u4e00\u4e2a\u6570\u636e\uff08\u4e0d\u662f\u6307\u4ee4\uff09"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"reg CPU_cs = 0;\nalways @ (*)\nif(i_EXE_vld)\n    CPU_cs = ( i_D_PC[ 31: 16 ] == CPU_BASEADDR[ 31: 16 ] ) ? i_LOAD : 1'b0;\n\nassign o_CPU_cs = CPU_cs;\nassign o_CPU_PC = { i_D_PC[ 31: 2 ], 2'b00 };\n\nreg [ 1: 0 ] data_sft_r = 0;\nalways @ (posedge sys_clk)\nif(o_CPU_cs & i_EXE_vld)\n    data_sft_r <= i_D_PC[1:0];\n\nwire [ 4: 0 ] data_sft = {data_sft_r[ 1: 0 ], 3'b000};\n\nwire [ 31: 0 ] o_CPU_dout = i_CPU_load_data >> data_sft;  // \u4eceitcm \u4e2d\u8bfb\u53d6\u7684\u6570\u636e \u6765\u5bf9\u7528LB, LH, LW \u7b49\u7b49\u3002\n")),(0,i.kt)("p",null,"\u6574\u4e2a\u6a21\u5757\u7684 load \u6307\u4ee4\u96c6 \u8bfb\u51fa\u7684\u6570\u636e\u9009\u62e9\uff0c \u6839\u636e\u4e0d\u540c\u7684\u7247\u9009\u4fe1\u53f7\uff0c \u4ece\u4e0d\u540c\u7684\u6a21\u5757\u4e2d\uff0c\u5c06\u76f8\u5e94\u7684\u6570\u636e\u9001\u7ed9cpu"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire [ 31: 0 ] ls_rb_d_t_sft = sft_cs       ? o_sft_int_v :\n                             ( tm_ctrl_cs   ? o_tm_ctrl :\n                             ( t_cs0        ? i_timer_l :\n                             ( t_cs1        ? i_timer_h :\n                             ( fpga_ver_cs  ? fpga_ver :\n                             ( fpga_test_cs ? (fpga_test>>{i_D_PC[1:0],3'b000}) :\n                             ( tcmp_cs0     ? o_tcmp_l :\n                             ( tcmp_cs1     ? o_tcmp_h : o_CPU_dout ) ) ) ) )));\nwire [ 31: 0 ] ls_rb_d = mem_cs ? mem_dout : ( GPIO_cs ? rb_GPIO_d : ( UART_cs ? o_UART_dout : ls_rb_d_t_sft ) );\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"LOAD, STORE \u6307\u4ee4\u96c6\u7ec4 \u8bfb\u5199\u64cd\u4f5c\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"always@( * )\nbegin\n    mem_we <= 1'b0;\n    mem_wem <= 4'b0;\n    o_wb_data <= 32'b0;\n\n    if ( i_LOAD )\n    begin //&mem_init_rdy\n        case ( i_load_instr ) // i_load_instr ={rv32i_lbu, rv32i_lb, rv32i_lhu, rv32i_lh, rv32i_lw};\n        5'b00001:\n        begin //rv32i_lw\n            o_wb_data <= ls_rb_d;\n        end\n        5'b00010:\n        begin //rv32i_lh\n            o_wb_data <= { { 16{ ls_rb_d[ 15 ] } }, ls_rb_d[ 15: 0 ] };\n        end\n        5'b00100:\n        begin //rv32i_lhu\n            o_wb_data <= { { 16{ 1'b0 } }, ls_rb_d[ 15: 0 ] };\n        end\n        5'b01000:\n        begin //rv32i_lb\n            o_wb_data <= { { 24{ ls_rb_d[ 7 ] } }, ls_rb_d[ 7: 0 ] };\n        end\n        5'b10000:\n        begin //rv32i_lbu\n            o_wb_data <= { { 24{ 1'b0 } }, ls_rb_d[ 7: 0 ] };\n        end\n        default: ;\n        endcase\n    end\n\n    if ( i_STORE )\n    begin //&mem_init_rdy\n        mem_we <= 1'b1;\n\n        case ( i_store_instr ) //i_store_instr ={rv32i_sb, rv32i_sh, rv32i_sw};\n        3'b001:\n        begin //rv32i_sw\n            mem_wem <= 4'b1111;\n        end\n        3'b010:\n        begin //rv32i_sh\n            mem_wem <= 4'b0011 << {i_D_PC[1],1'b0};\n        end\n        3'b100:\n        begin //rv32i_sb\n            mem_wem <= 4'b0001 << i_D_PC[1:0];\n        end\n        default:\n            mem_wem <= 4'b0;\n\n        endcase\n    end\nend\n\n")),(0,i.kt)("p",null,"\u6839\u636eLOAD, STORE \u6307\u4ee4\u96c6\u7ec4\uff0c \u5c06\u76f8\u5173\u7684\u6570\u636e\u5199\u5165\uff0c\u6216\u8005\u8bfb\u51fa\u3002"),(0,i.kt)("h2",{id:"\u4e8cd_sram\u6a21\u5757"},"\u4e8c\u3001D_sram\u6a21\u5757"),(0,i.kt)("p",null,"RISC-V CPU\u4e2d LOAD, STORE \u6307\u4ee4\u96c6\u4e2d\u5bf9SRAM\uff0c \u548c GPIO \u6a21\u5757\u7684\u63a7\u5236\uff0cSRAM ,GPIO \u7b49\uff0c\u90fd\u53ef\u4ee5\u770b\u505acpu \u7684\u5916\u90e8\u5b58\u50a8\u3002\u5728\u54c8\u4f5b\u67b6\u6784\u4e2d\uff0c \u4f7f\u7528\u6570\u636e\u603b\u7ebf\uff0c\u8bbf\u5b58\u8fd9\u4e9b\u5916\u90e8\u6a21\u5757"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u5728 RISC-V v2.01 \u7248\u672c\u4e2d\uff0c SRAM, GPIO \u7b49\u6a21\u5757\u5728 lsu \u6a21\u5757 \u5f53\u4e2d"),"\uff0c lsu \u6a21\u5757\u4f5c\u4e3a\u548ccpu \u5185\u6838\u8fde\u63a5\u7684\u63a5\u53e3\uff0c \u5728\u4e4b\u540e\u7684\u7248\u672c\u4e2d\u4f1a\u505a\u76f8\u5e94\u7684\u4fee\u6539\uff0c \u5305\u62ec\u589e\u52a0\u603b\u7ebf\u3002 \u5305\u62ec\u603b\u7ebf\u6269\u5c55\u3002 \u540c\u65f6\u5c06\u5176\u4ed6\u5916\u8bbe\u4ece\u5f53\u524d\u6a21\u5757\u4e2d\u79fb\u51fa\uff0c\u4ee5\u4fbf\u589e\u52a0\u66f4\u591a\u7684\u5916\u8bbe\u3002\u76ee\u524dsram \u5728\u5730\u5740\u7a7a\u95f4\u7684\u4f4d\u7f6e\u662f 0x9000_0000 \u8d77\u59cb\u7684 256M \u7a7a\u95f4\u3002SRAM \u548c DTCM \u662f\u4e00\u81f4\u7684\u3002\u76ee\u524d\u7248\u672c\u4e2d\uff0c DTCM \u5c31\u662f\u7531SRAM \u8fd9\u4e2a\u6a21\u5757\u7ec4\u6210\u7684\u3002"),(0,i.kt)("p",null,(0,i.kt)("img",{src:e(10511).Z,width:"1852",height:"1246"})),(0,i.kt)("h3",{id:"sram-\u4ee3\u7801"},"SRAM \u4ee3\u7801"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"module D_sram\n#( \n    parameter MEM_D_DEEP = 1024, //memory data depth\n    parameter MEM_D_W = 32,      //memory data width\n    parameter MEM_MSK_W = 4,     //memory data mask width\n    parameter MEM_ADDR_W = 32    //memory address width\n)\n(\n    input clk,                            // \u7cfb\u7edf\u65f6\u949f \n\n    input [ MEM_D_W - 1 : 0 ] din,        // \u6570\u636e\u5199\u5165\n    input [ MEM_ADDR_W - 1 : 0 ] addr,    // \u6570\u636e\u603b\u7ebf\u5730\u5740\n    output [ MEM_ADDR_W - 1 : 0 ] o_D_PC, // \u6ca1\u6709\u4f7f\u7528\n\n    input cs,                             // \u6a21\u5757\u7247\u9009\n    input we,                             // \u5199\u4fe1\u53f7 \n    input [ MEM_MSK_W - 1: 0 ] wem,       // \u5199\u5c4f\u853d\u4f4d \n//    output reg mem_init_rdy, \n    output [ MEM_D_W - 1: 0 ] dout,       // \u6570\u636e\u8bfb\n\n    input rst_n\n);\n\n//===============================================================================\nreg [ MEM_D_W - 1: 0 ] mem_r[ 0: MEM_D_DEEP - 1 ];\n//===============================================================================\nwire ren = cs & ( ~we );\nwire [ MEM_MSK_W - 1: 0 ] wen = ( { MEM_MSK_W{ cs & we } } & wem );\n\nreg [ MEM_ADDR_W - 1: 0 ] addr_r = 0;\nalways @( posedge clk )\naddr_r <= addr;\n\nwire [ MEM_ADDR_W - 1: 0 ] addr_mem = {addr[31:2]};\n\n// integer mem_init_addr;\n//===============================================================================\ngenvar wi;\ngenerate\nfor ( wi = 0; wi < MEM_MSK_W; wi = wi + 1 )\nbegin: mem_write\n    always @( posedge clk )\n    begin\n        if ( wen[ wi ] )\n        begin\n            mem_r[ addr_mem ][ 8 * wi + 7: 8 * wi ] <= din[ 8 * wi + 7: 8 * wi ];\n        end\n    end\nend\nendgenerate\n//===============================================================================\nwire [ MEM_D_W - 1: 0 ] dout_pre;\nwire [ MEM_D_W - 1: 0 ] dout_w;\n//assign dout_pre = mem_r[ addr_r ];\nassign dout_pre = mem_r[ addr_mem ];\n\ngenvar ri;\ngenerate\n    for ( ri = 0; ri < MEM_D_W; ri = ri + 1 )\n    begin: mem_read\n`ifdef SIM//{\n        assign dout_w[ ri ] = ( dout_pre[ ri ] === 1'bx ) ? 1'b0 : dout_pre[ ri ];\n`else //}{\n        assign dout_w[ ri ] = dout_pre[ ri ];\n`endif//}\n    end\nendgenerate\n//===============================================================================\n//wire [4:0] data_sft = addr[1:0] * 8;\nwire [4:0] data_sft = {addr[1:0], 3'b000};\nassign dout = dout_w >> data_sft;\n\nassign o_D_PC = addr_r;\n//===============================================================================\n\nendmodule\n")),(0,i.kt)("h3",{id:"\u4ee3\u7801\u5206\u6790-1"},"\u4ee3\u7801\u5206\u6790"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u7aef\u53e3\u4ecb\u7ecd\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"input clk,                         // \u7cfb\u7edf\u65f6\u949f \n\ninput [ MEM_D_W - 1 : 0 ] din,     // \u6570\u636e\u5199\u5165\ninput [ MEM_ADDR_W - 1 : 0 ] addr, // \u6570\u636e\u603b\u7ebf\u5730\u5740\n\ninput cs,                          // \u6a21\u5757\u7247\u9009\ninput we,                          // \u5199\u4fe1\u53f7 \ninput [ MEM_MSK_W - 1: 0 ] wem,    // \u5199\u5c4f\u853d\u4f4d \n\noutput [ MEM_D_W - 1: 0 ] dout,    // \u6570\u636e\u8bfb\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u5b58\u50a8\u5bc4\u5b58\u5668\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"reg [ MEM_D_W \u2013 1: 0 ] mem_r[ 0: MEM_D_DEEP \u2013 1 ];\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u8bfb\u4fe1\u53f7\uff0c \u5199\u4fe1\u53f7\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire ren = cs & ( ~we );\nwire [ MEM_MSK_W \u2013 1: 0 ] wen = ( { MEM_MSK_W{ cs & we } } & wem );\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"SRAM \u5730\u5740\uff1a")," "),(0,i.kt)("p",null,"\u7531\u4e8e\u5f53\u524d\u8bbe\u5907\u4f4d32bit\u7684\u8bbe\u5907\uff0c \u6240\u4ee5\u8f93\u5165\u5730\u5740\u53ea\u9700\u8981","[31:2]"," ,\u4f5c\u4e3a\u8bbf\u5b58\u7684\u5355\u5143\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire [ MEM_ADDR_W \u2013 1: 0 ] addr_mem = {addr[31:2]};\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u5199\u6570\u636e\u5230\u5b58\u50a8\u5355\u5143\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"genvar wi;\ngenerate\nfor ( wi = 0; wi < MEM_MSK_W; wi = wi + 1 )\nbegin: mem_write\n    always @( posedge clk )\n    begin\n        if ( wen[ wi ] )\n        begin\n            mem_r[ addr_mem ][ 8 * wi + 7: 8 * wi ] <= din[ 8 * wi + 7: 8 * wi ];\n        end\n    end\nend\nendgenerate\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u8bfb\u6570\u636e\u5355\u5143\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire [ MEM_D_W - 1: 0 ] dout_pre;\nwire [ MEM_D_W - 1: 0 ] dout_w;\n//assign dout_pre = mem_r[ addr_r ];\nassign dout_pre = mem_r[ addr_mem ];\n\ngenvar ri;\ngenerate\nfor ( ri = 0; ri < MEM_D_W; ri = ri + 1 )\nbegin: mem_read\n`ifdef SIM//{\n    assign dout_w[ ri ] = ( dout_pre[ ri ] === 1'bx ) ? 1'b0 : dout_pre[ ri ];\n`else //}{\n    assign dout_w[ ri ] = dout_pre[ ri ];\n`endif//}\nend\nendgenerate\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"load \u6307\u4ee4\u76f8\u5173\u64cd\u4f5c\uff1a")," LB, LH, LW"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire [4:0] data_sft = {addr[1:0], 3'b000};\nassign dout = dout_w >> data_sft;\n")),(0,i.kt)("p",null,"\u6574\u4e2aSRAM \u6a21\u5757 \u76ee\u524d\u662f\u7531d\u89e6\u53d1\u5668\u7ec4\u6210\uff0c \u4e4b\u540e\u4e5f\u53ef\u4ee5\u88ab\u66ff\u6362\u4f4dblock memory \uff08IP), \u4f46\u8981\u6ce8\u610f\uff0c block memory \u901a\u5e38\u9700\u8981\u5ef6\u8fdf\u4e00\u4e2a\u65f6\u949f\u5468\u671f\uff0c\u6240\u4ee5\u5728\u6574\u4e2acpu \u8bbe\u8ba1\u4e2d\uff0c \u4e00\u5b9a\u8981\u6ce8\u610f\uff0c\u9700\u8981\u5728\u72b6\u6001\u673a\uff0c\u6216\u8005\u6d41\u6c34\u7ebf\u4e2d\u589e\u52a0\u4e00\u4e2a\u65f6\u949f\uff0c\u4f5c\u4e3a\u8bbf\u5b58\u3002\u5f53\u7136\u4e5f\u6709\u5176\u4ed6\u7684\u65b9\u6cd5\u53ef\u4ee5\u4f7f\u7528\u3002"),(0,i.kt)("h2",{id:"\u4e09fii_gpio\u6a21\u5757"},"\u4e09\u3001fii_GPIO\u6a21\u5757"),(0,i.kt)("p",null,"RISC-V CPU\u4e2d LOAD, STORE \u6307\u4ee4\u96c6\u4e2d\u5bf9SRAM\uff0c \u548c GPIO \u6a21\u5757\u7684\u63a7\u5236\uff0cSRAM ,GPIO \u7b49\uff0c\u90fd\u53ef\u4ee5\u770b\u505acpu \u7684\u5916\u90e8\u5b58\u50a8\u3002\u5728\u54c8\u4f5b\u67b6\u6784\u4e2d\uff0c \u4f7f\u7528\u6570\u636e\u603b\u7ebf\uff0c\u8bbf\u5b58\u8fd9\u4e9b\u5916\u90e8\u6a21\u5757"),(0,i.kt)("p",null,"GPIO \u7684\u5730\u5740\u7a7a\u95f4\uff1a"),(0,i.kt)("p",null,(0,i.kt)("img",{src:e(63028).Z,width:"671",height:"246"})),(0,i.kt)("p",null,"gpio \u5bc4\u5b58\u5668\u5730\u5740\u7a7a\u95f4\u662f\u4ece0xf000_0000 \u5f00\u59cb\u76848k \u5730\u5740\u7a7a\u95f4\u3002"),(0,i.kt)("p",null,(0,i.kt)("img",{src:e(58255).Z,width:"1814",height:"1250"})),(0,i.kt)("h3",{id:"gpio-\u6a21\u5757\u4ee3\u7801"},"gpio \u6a21\u5757\u4ee3\u7801"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"module fii_GPIO \n#(\n    parameter GPIO_DEEP   = 8,  //memory data width\n    parameter GPIO_W      = 32, //memory data width\n    parameter GPIO_MSK_W  = 4,  //memory data mask width\n    parameter GPIO_ADDR_W = 32  //memory address width\n)\n(\n    input clk,                                // \u7cfb\u7edf\u65f6\u949f\n    input rst_n,\n\n    input [ GPIO_W - 1 : 0 ] i_ls_GPIO_din,   // cpu \u5199\u6570\u636e\n    output [ GPIO_W - 1 : 0 ] o_rb_GPIO_dout, // cpu \u8bfb\u6570\u636e\n\n    input [ GPIO_ADDR_W - 1 : 0 ] i_addr,     // \u6570\u636e\u603b\u7ebf\u5730\u5740\n    input i_cs,                               // gpio \u6a21\u5757 \u7247\u9009\n    input i_we,                               // \u5199\u4fe1\u53f7\n    input [ GPIO_MSK_W - 1: 0 ] i_wem,        // \u5199\u5c4f\u853d\u4fe1\u53f7\n// t = 0, output; t = 1, input\n    input [ 31: 0 ] i_GPIO_dina,              // gpio \u6a21\u5757a\u7ec4 cpu\u5199\u5165\u6570\u636e\n    output [ 31: 0 ] o_GPIO_douta,            // gpio \u6a21\u5757a\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\n    output [ 31: 0 ] o_GPIO_ta,               // gpio \u6a21\u5757a\u7ec4 \u65b9\u5411\u63a7\u5236\n\n    input [ 31: 0 ] i_GPIO_dinb,              // gpio \u6a21\u5757b\u7ec4 cpu\u5199\u5165\u6570\u636e\n    output [ 31: 0 ] o_GPIO_doutb,            // gpio \u6a21\u5757b\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\n    output [ 31: 0 ] o_GPIO_tb,               // gpio \u6a21\u5757b\u7ec4 \u65b9\u5411\u63a7\u5236\n\n    input [ 31: 0 ] i_GPIO_dinc,              // gpio \u6a21\u5757c\u7ec4 cpu\u5199\u5165\u6570\u636e\n    output [ 31: 0 ] o_GPIO_doutc,            // gpio \u6a21\u5757c\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\n    output [ 31: 0 ] o_GPIO_tc,               // gpio \u6a21\u5757c\u7ec4 \u65b9\u5411\u63a7\u5236\n\n    input [ 31: 0 ] i_GPIO_dind,              // gpio \u6a21\u5757d\u7ec4 cpu\u5199\u5165\u6570\u636e\n    output [ 31: 0 ] o_GPIO_doutd,            // gpio \u6a21\u5757d\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\n    output [ 31: 0 ] o_GPIO_td                // gpio \u6a21\u5757d\u7ec4 \u65b9\u5411\u63a7\u5236\n);\n//===============================================================================\nreg [ GPIO_W - 1: 0 ] GPIO_r [ 0: GPIO_DEEP - 1 ];\nwire [ GPIO_MSK_W - 1: 0 ] wen;\nwire ren;\nwire [ 2: 0 ] w_addr = i_addr[ 4: 2 ];\n\n//===============================================================================\nassign ren = i_cs & ( ~i_we );\nassign wen = ( { GPIO_MSK_W{ i_cs & i_we } } & i_wem );\n\nreg [ GPIO_ADDR_W - 1: 0 ] addr_r = 0;\nalways@( posedge clk )\nif ( ren )\n    addr_r <= i_addr;\n\n//===============================================================================\nreg [7:0] i = 0;\ninitial\nbegin\n    for ( i = 0; i < GPIO_DEEP; i = i + 1 )\n    begin:IO_GPIO_INIT\n        GPIO_r [ i ] <= ~0;\n    end\nend\n\ngenvar wi;\ngenerate\n    for ( wi = 0; wi < GPIO_MSK_W; wi = wi + 1 )\n    begin:IO_write\n        always @( posedge clk )\n        begin\n           if ( wen[ wi ] )\n           begin\n               GPIO_r[ w_addr ][ 8 * wi + 7: 8 * wi ] <= i_ls_GPIO_din[ 8 * wi + 7: 8 * wi ];\n           end\n        end\n    end\nendgenerate\n//===============================================================================\nwire [ GPIO_W - 1: 0 ] dout_pre;\nwire [ GPIO_W - 1: 0 ] t_pre;\nwire [ GPIO_W - 1: 0 ] reg_dout;\nwire [ GPIO_W - 1: 0 ] in_dout[ 0: GPIO_DEEP / 2 - 1 ];\n\nassign in_dout[ 0 ] = i_GPIO_dina;\nassign in_dout[ 1 ] = i_GPIO_dinb;\nassign in_dout[ 2 ] = i_GPIO_dinc;\nassign in_dout[ 3 ] = i_GPIO_dind;\n\n//wire [ 31: 0 ] in_dout_tmp = in_dout[ i_addr[ GPIO_DEEP / 2 - 1: 1 ] ];\nwire [ 31: 0 ] in_dout_tmp = in_dout[ w_addr[ 2: 1 ]];\n\n\n//assign t_pre = GPIO_r[ { addr_r[ GPIO_ADDR_W - 1: 1 ], 1'b1 } ];\n//assign dout_pre = GPIO_r[ { addr_r[ GPIO_ADDR_W - 1: 1 ], 1'b0 } ];\nassign t_pre = GPIO_r[ { w_addr[ 2: 1 ], 1'b1 } ];\nassign dout_pre = GPIO_r[ { w_addr[ 2: 1 ], 1'b0 } ];\n\n//===============================================================================\ngenvar rbi;\ngenerate\n    for ( rbi = 0; rbi < GPIO_W; rbi = rbi + 1 )\n    begin:GPIO_readb\n    // input reg output reg\n        assign o_rb_GPIO_dout[ rbi ] = t_pre[ rbi ] ? in_dout_tmp[ rbi ] : dout_pre[ rbi ];\n    end\nendgenerate\n//===============================================================================\nassign o_GPIO_douta = GPIO_r[ 0 ];\nassign o_GPIO_ta    = GPIO_r[ 1 ];\n\nassign o_GPIO_doutb = GPIO_r[ 2 ];\nassign o_GPIO_tb    = GPIO_r[ 3 ];\n\nassign o_GPIO_doutc = GPIO_r[ 4 ];\nassign o_GPIO_tc    = GPIO_r[ 5 ];\n\nassign o_GPIO_doutd = GPIO_r[ 6 ];\nassign o_GPIO_td    = GPIO_r[ 7 ];\n//===============================================================================\n\nendmodule\n")),(0,i.kt)("h3",{id:"\u4ee3\u7801\u5206\u6790-2"},"\u4ee3\u7801\u5206\u6790"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u7aef\u53e3\u4ecb\u7ecd\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"input [ GPIO_W - 1 : 0 ] i_ls_GPIO_din,   // cpu \u5199\u6570\u636e\noutput [ GPIO_W - 1 : 0 ] o_rb_GPIO_dout, // cpu \u8bfb\u6570\u636e\n\ninput [ GPIO_ADDR_W - 1 : 0 ] i_addr,     // \u6570\u636e\u603b\u7ebf\u5730\u5740\ninput i_cs, // gpio \u6a21\u5757 \u7247\u9009\ninput i_we, // \u5199\u4fe1\u53f7\ninput [ GPIO_MSK_W - 1: 0 ] i_wem,        // \u5199\u5c4f\u853d\u4fe1\u53f7\n\ninput [ 31: 0 ] i_GPIO_dina,              // gpio \u6a21\u5757a\u7ec4 cpu\u5199\u5165\u6570\u636e\noutput [ 31: 0 ] o_GPIO_douta,            // gpio \u6a21\u5757a\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\noutput [ 31: 0 ] o_GPIO_ta,               // gpio \u6a21\u5757a\u7ec4 \u65b9\u5411\u63a7\u5236\n\ninput [ 31: 0 ] i_GPIO_dinb,              // gpio \u6a21\u5757b\u7ec4 cpu\u5199\u5165\u6570\u636e\noutput [ 31: 0 ] o_GPIO_doutb,            // gpio \u6a21\u5757b\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\noutput [ 31: 0 ] o_GPIO_tb,               // gpio \u6a21\u5757b\u7ec4 \u65b9\u5411\u63a7\u5236\n\ninput [ 31: 0 ] i_GPIO_dinc,              // gpio \u6a21\u5757c\u7ec4 cpu\u5199\u5165\u6570\u636e\noutput [ 31: 0 ] o_GPIO_doutc,            // gpio \u6a21\u5757c\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\noutput [ 31: 0 ] o_GPIO_tc,               // gpio \u6a21\u5757c\u7ec4 \u65b9\u5411\u63a7\u5236\n\ninput [ 31: 0 ] i_GPIO_dind,              // gpio \u6a21\u5757d\u7ec4 cpu\u5199\u5165\u6570\u636e\noutput [ 31: 0 ] o_GPIO_doutd,            // gpio \u6a21\u5757d\u7ec4 cpu\u8bfb\u51fa\u6570\u636e\noutput [ 31: 0 ] o_GPIO_td                // gpio \u6a21\u5757d\u7ec4 \u65b9\u5411\u63a7\u5236\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u5b9a\u4e49gpio \u5bc4\u5b58\u5668\u7ec4\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"reg [ GPIO_W - 1: 0 ] GPIO_r [ 0: GPIO_DEEP - 1 ];\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u5b9a\u4e49\u8bfb\uff0c\u5199\uff0c\u5730\u5740\u4fe1\u53f7\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire [ GPIO_MSK_W \u2013 1: 0 ] wen;\nwire ren;\nwire [ 2: 0 ] w_addr = i_addr[ 4: 2 ];\nassign ren = i_cs & ( ~i_we );\nassign wen = ( { GPIO_MSK_W{ i_cs & i_we } } & i_wem );\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"gpio \u6a21\u5757\u5bc4\u5b58\u5668\u7ec4\uff0c\u5199\u903b\u8f91\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"genvar wi;\ngenerate\n    for ( wi = 0; wi < GPIO_MSK_W; wi = wi + 1 )\n    begin:IO_write\n        always @( posedge clk )\n        begin\n            if ( wen[ wi ] )\n            begin\n                GPIO_r[ w_addr ][ 8 * wi + 7: 8 * wi ] <= i_ls_GPIO_din[ 8 * wi + 7: 8 * wi ];\n            end\n        end\n    end\nendgenerate\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u8bfb\u53d6gpio\u7ec4\u4e2d\u7684\u65b9\u5411\u5bc4\u5b58\u5668\uff0c \u6570\u636e\u5bc4\u5b58\u5668\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire [ GPIO_W - 1: 0 ] dout_pre;\nwire [ GPIO_W - 1: 0 ] t_pre;\nwire [ GPIO_W - 1: 0 ] reg_dout;\nwire [ GPIO_W - 1: 0 ] in_dout[ 0: GPIO_DEEP / 2 - 1 ];\n\nassign in_dout[ 0 ] = i_GPIO_dina;\nassign in_dout[ 1 ] = i_GPIO_dinb;\nassign in_dout[ 2 ] = i_GPIO_dinc;\nassign in_dout[ 3 ] = i_GPIO_dind;\n\nwire [ 31: 0 ] in_dout_tmp = in_dout[ w_addr[ 2: 1 ]];\n\n\nassign t_pre = GPIO_r[ { w_addr[ 2: 1 ], 1'b1 } ];     // \u5f53\u524d\u5730\u5740\u9009\u4e2d\u7684GPIO ,A,B,C,D \u7ec4\u4e2d \u65b9\u5411\u5bc4\u5b58\u5668\nassign dout_pre = GPIO_r[ { w_addr[ 2: 1 ], 1'b0 } ];  // \u8bfb\u53d6\u5f53\u524d\u5730\u5740\u9009\u4e2d\u7684GPIO ,A,B,C,D \u7ec4\u4e2dgpio \u503c\u5bc4\u5b58\u5668\n\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"cpu \u5199gpio \u5bc4\u5b58\u5668\u7ec4"),"\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"genvar wi;\ngenerate\n    for ( wi = 0; wi < GPIO_MSK_W; wi = wi + 1 )\n    begin:IO_write\n        always @( posedge clk )\n        begin\n            if ( wen[ wi ] )\n            begin\n                GPIO_r[ w_addr ][ 8 * wi + 7: 8 * wi ] <= i_ls_GPIO_din[ 8 * wi + 7: 8 * wi ];\n            end\n        end\n    end\nendgenerate\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"cpu \u8bfb\u53d6gpio \u5bc4\u5b58\u5668\u7ec4\u4e2d\u7684\u5185\u5bb9\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"genvar rbi;\ngenerate\n    for ( rbi = 0; rbi < GPIO_W; rbi = rbi + 1 )\n    begin:GPIO_readb\n    //                                                input reg            output reg\n        assign o_rb_GPIO_dout[ rbi ] = t_pre[ rbi ] ? in_dout_tmp[ rbi ] : dout_pre[ rbi ];\n    end\nendgenerate\n")),(0,i.kt)("p",null,"\u5f53t_pre == 1 \u65f6\uff0c \u8bfb\u53d6 input fpga pin \u7684\u6570\u503c\uff1b\u5f53t_pre == 0 \u65f6\uff0c \u8bfb\u53d6 \u5f53\u524dgpio\u6570\u503c\u5bc4\u5b58\u5668\u4e2d\u7684\u503c\uff1b"),(0,i.kt)("p",null,(0,i.kt)("img",{src:e(3297).Z,width:"1046",height:"597"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u5c06gpio \u5bc4\u5b58\u5668\u7ec4\u7684\u76f8\u5173\u5185\u5bb9\u8f93\u51fa\u5230\u9876\u5c42\u6587\u4ef6\u7684\u539f\u8bed\u4e2d\uff1a")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"assign o_GPIO_douta = GPIO_r[ 0 ];\nassign o_GPIO_ta    = GPIO_r[ 1 ];\n\nassign o_GPIO_doutb = GPIO_r[ 2 ];\nassign o_GPIO_tb    = GPIO_r[ 3 ];\n\nassign o_GPIO_doutc = GPIO_r[ 4 ];\nassign o_GPIO_tc    = GPIO_r[ 5 ];\n\nassign o_GPIO_doutd = GPIO_r[ 6 ];\nassign o_GPIO_td    = GPIO_r[ 7 ];\n")))}u.isMDXComponent=!0},58255:(n,_,e)=>{e.d(_,{Z:()=>t});const t=e.p+"assets/images/100-c50aba5bf67b9aade8beed443ebaaa76.jpeg"},3297:(n,_,e)=>{e.d(_,{Z:()=>t});const t=e.p+"assets/images/101-e46f137fac5e94fedbee56f0a365555c.jpeg"},56342:(n,_,e)=>{e.d(_,{Z:()=>t});const t=e.p+"assets/images/96-2a2c61ff89a60c42a66abd16a3e69598.jpeg"},42943:(n,_,e)=>{e.d(_,{Z:()=>t});const t=e.p+"assets/images/97-6f90031e5e5cb8154f52f7d985236a8c.jpeg"},10511:(n,_,e)=>{e.d(_,{Z:()=>t});const t=e.p+"assets/images/98-14919bfe099ac1765ea6d845664afcab.jpeg"},63028:(n,_,e)=>{e.d(_,{Z:()=>t});const t=e.p+"assets/images/99-a13335f4e7cf9f9b1b019955fcd98fa1.jpeg"}}]);